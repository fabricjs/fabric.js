!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("fabric"),require("westures")):"function"==typeof define&&define.amd?define(["exports","fabric","westures"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).fabricExtensions={},t.fabric,t.wes)}(this,function(t,e,i){"use strict";function n(t,e,i){return(e=function(t){var e=function(t,e){if("object"!=typeof t||!t)return t;var i=t[Symbol.toPrimitive];if(void 0!==i){var n=i.call(t,e);if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:e+""}(e))in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}function s(t,e){return Math.abs(t-e)}function r(t,e,i){let n=1/0,r=[];for(const o of e){const e=s(t[i],o[i]);n>e&&(r=[],n=e),n==e&&r.push(o)}return{dis:n,arr:r}}function o(t){const{target:e,isScale:i,isUniform:n,corner:s,point:o,diagonalPoint:a,list:c,isCenter:l}=t,{dis:h,arr:f}=r(o,c,"x");if(h>this.margin/this.canvas.getZoom())return[];let g=f[f.length-1].x-o.x;g*=s.includes("l")?-1:1;const{width:d,height:u,scaleX:p,scaleY:v}=e,m=p*d+(e.strokeUniform?0:e.strokeWidth),b=(g+m)/m;if(0==b)return[];if(i?(e.set("scaleX",p*b),n&&e.set("scaleY",v*b)):(e.set("width",d*b),n&&e.set("height",u*b)),l)e.setRelativeXY(a,"center","center");else{const t=this.contraryOriginMap;e.setRelativeXY(a,...t[s])}return e.setCoords(),f.map(t=>({origin:o,target:t}))}function a(t){const{target:e,isScale:i,isUniform:n,corner:s,point:o,diagonalPoint:a,list:c,isCenter:l}=t,{dis:h,arr:f}=r(o,c,"y");if(h>this.margin/this.canvas.getZoom())return[];let g=f[f.length-1].y-o.y;g*=s.includes("t")?-1:1;const{width:d,height:u,scaleX:p,scaleY:v}=e,m=v*u+(e.strokeUniform?0:e.strokeWidth),b=(g+m)/m;if(0==b)return[];if(i?(e.set("scaleY",v*b),n&&e.set("scaleX",p*b)):(e.set("height",u*b),n&&e.set("width",d*b)),l)e.setRelativeXY(a,"center","center");else{const t=this.contraryOriginMap;e.setRelativeXY(a,...t[s])}return e.setCoords(),f.map(t=>({origin:o,target:t}))}function c(t,e){const i=this.canvas.getTopContext(),n=this.canvas.viewportTransform,s=this.canvas.getZoom();i.save(),i.transform(...n),i.lineWidth=this.width/s,this.lineDash&&i.setLineDash(this.lineDash),i.strokeStyle=this.color,i.beginPath(),i.moveTo(t.x,t.y),i.lineTo(e.x,e.y),i.stroke(),this.lineDash&&i.setLineDash([]),this.drawX(t,-1),this.drawX(e,1),i.restore()}function l(t,e){const i=this.canvas.getTopContext(),n=this.canvas.getZoom(),s=this.xSize/n;i.save(),i.translate(t.x,t.y),i.beginPath(),i.moveTo(-s,-s),i.lineTo(s,s),i.moveTo(s,-s),i.lineTo(-s,s),i.stroke(),i.restore()}function h(t){const e=this.canvas.getTopContext(),i=this.canvas.viewportTransform,n=this.canvas.getZoom();e.save(),e.transform(...i),e.lineWidth=this.width/n,e.strokeStyle=this.color;for(const e of t)this.drawX(e,0);e.restore()}function f(){const t=[];if(!this.closeVLine)for(const e of this.verticalLines)t.push(JSON.parse(e));if(!this.closeHLine)for(const e of this.horizontalLines)t.push(JSON.parse(e));const e=t.map(t=>t.target);h.call(this,e)}function g(){if(!this.closeVLine)for(const t of this.verticalLines){const{origin:i,target:n}=JSON.parse(t),s=new e.Point(n.x,i.y);this.drawLine(s,n)}}function d(){if(!this.closeHLine)for(const t of this.horizontalLines){const{origin:i,target:n}=JSON.parse(t),s=new e.Point(i.x,n.y);this.drawLine(s,n)}}function u(t,e){const i=t.getCoords();i.push(t.getCenterPoint());const n={target:t,list:i,points:e,margin:this.margin/this.canvas.getZoom()};return{vLines:v({...n,type:"x"}),hLines:v({...n,type:"y"})}}const p=[["left","top"],["right","top"],["right","bottom"],["left","bottom"],["center","center"]];function v(t){const{target:e,list:i,points:n,margin:s,type:o}=t,a=[],c=[];let l=1/0;for(const t of i){const e=r(t,n,o);c.push(e),l>e.dis&&(l=e.dis)}if(l>s)return a;let h=!1;for(let t=0;t<i.length;t++){if(c[t].dis!=l)continue;for(const e of c[t].arr)a.push({origin:i[t],target:e});if(h)continue;h=!0;const n=c[t].arr[0][o]-i[t][o];i.forEach(t=>{t[o]+=n}),e.setXY(i[t],...p[t]),e.setCoords()}return a}function m(t){const i=new Set,n=t.canvas;if(!n)return i;const s=t instanceof e.ActiveSelection?t.getObjects():[t];return n.forEachObject(t=>{t.isOnScreen()&&t.visible&&(t.constructor!=e.Group?i.add(t):y(i,t))}),b(i,s),i}function b(t,i){for(const n of i)n.constructor==e.Group?b(t,n.getObjects()):t.delete(n)}function y(t,i){const n=i.getObjects();for(const i of n)i.visible&&(i.constructor!=e.Group?t.add(i):y(t,i))}const w=function(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"left",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"top";return async function(s){const{originX:r=i,originY:o=n}=s;delete s.originX,delete s.originY;for(var a=arguments.length,c=new Array(a>1?a-1:0),l=1;l<a;l++)c[l-1]=arguments[l];const h=await t.call(this,s,...c),f=new e.Point(h.left,h.top);return h.setPositionByOrigin(f,r,o),h}},O=t=>async function(i){const{colorStops:n}=i,s=null==n?void 0:n.map(t=>{let{color:i,opacity:n,offset:s}=t;if(void 0===n||1===n)return{color:i,offset:s};return{color:new e.Color(i).setAlpha(n).toRgba(),offset:s}});return await t.call(this,{...i,colorStops:s})};t.AligningGuidelines=class{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(this,"canvas",void 0),n(this,"horizontalLines",new Set),n(this,"verticalLines",new Set),n(this,"cacheMap",new Map),n(this,"onlyDrawPoint",!1),n(this,"contraryOriginMap",{tl:["right","bottom"],tr:["left","bottom"],br:["left","top"],bl:["right","top"],mt:["center","bottom"],mr:["left","center"],mb:["center","top"],ml:["right","center"]}),n(this,"xSize",2.4),n(this,"lineDash",void 0),n(this,"margin",4),n(this,"width",1),n(this,"color","rgba(255,0,0,0.9)"),n(this,"closeVLine",!1),n(this,"closeHLine",!1),this.canvas=t,Object.assign(this,e),this.mouseUp=this.mouseUp.bind(this),this.scalingOrResizing=this.scalingOrResizing.bind(this),this.moving=this.moving.bind(this),this.beforeRender=this.beforeRender.bind(this),this.afterRender=this.afterRender.bind(this),this.initBehavior()}initBehavior(){this.canvas.on("mouse:up",this.mouseUp),this.canvas.on("object:resizing",this.scalingOrResizing),this.canvas.on("object:scaling",this.scalingOrResizing),this.canvas.on("object:moving",this.moving),this.canvas.on("before:render",this.beforeRender),this.canvas.on("after:render",this.afterRender)}getObjectsByTarget(t){return m(t)}getPointMap(t){return function(t){const e=t.getCoords();return{tl:e[0],tr:e[1],br:e[2],bl:e[3],mt:e[0].add(e[1]).scalarDivide(2),mr:e[1].add(e[2]).scalarDivide(2),mb:e[2].add(e[3]).scalarDivide(2),ml:e[3].add(e[0]).scalarDivide(2)}}(t)}getContraryMap(t){return function(t){var e;const i=null!==(e=t.aCoords)&&void 0!==e?e:t.calcACoords();return{tl:i.br,tr:i.bl,br:i.tl,bl:i.tr,mt:i.br.add(i.bl).scalarDivide(2),mr:i.bl.add(i.tl).scalarDivide(2),mb:i.tl.add(i.tr).scalarDivide(2),ml:i.tr.add(i.br).scalarDivide(2)}}(t)}getCaCheMapValue(t){const e=[t.calcTransformMatrix().toString(),t.width,t.height].join(),i=this.cacheMap.get(e);if(i)return i;const n=t.getCoords();return n.push(t.getCenterPoint()),this.cacheMap.set(e,n),n}drawLine(t,e){c.call(this,t,e)}drawX(t,e){l.call(this,t,e)}mouseUp(){this.verticalLines.clear(),this.horizontalLines.clear(),this.cacheMap.clear(),this.canvas.requestRenderAll()}scalingOrResizing(t){const i=t.target;i.setCoords();const n=String(t.transform.action).startsWith("scale");this.verticalLines.clear(),this.horizontalLines.clear();const s=this.getObjectsByTarget(i);let r=t.transform.corner;i.flipX&&(r.includes("l")?r=r.replace("l","r"):r.includes("r")&&(r=r.replace("r","l"))),i.flipY&&(r.includes("t")?r=r.replace("t","b"):r.includes("b")&&(r=r.replace("b","t")));const c=this.getPointMap(i);if(!(r in c))return;if(this.onlyDrawPoint=r.includes("m"),this.onlyDrawPoint){if(i.getTotalAngle()%90!=0)return}const l=this.getContraryMap(i),h=c[r];let f=l[r];const g="center"==t.transform.original.originX&&"center"==t.transform.original.originY;if(g){const t=i.group?h.transform(e.util.invertTransform(i.group.calcTransformMatrix())):h;f=f.add(t).scalarDivide(2)}const d=t.e[this.canvas.uniScaleKey];let u=this.canvas.uniformScaling&&!d||!this.canvas.uniformScaling&&d;this.onlyDrawPoint&&(u=!1);const p=[];for(const t of s){const e=this.getCaCheMapValue(t);p.push(...e)}const v={target:i,point:h,diagonalPoint:f,corner:r,list:p,isScale:n,isUniform:u,isCenter:g},m=this.onlyDrawPoint&&(r.includes("t")||r.includes("b")),b=this.onlyDrawPoint&&(r.includes("l")||r.includes("r")),y=m?[]:o.call(this,v),w=b?[]:a.call(this,v);y.forEach(t=>{this.verticalLines.add(JSON.stringify(t))}),w.forEach(t=>{this.horizontalLines.add(JSON.stringify(t))})}moving(t){const e=t.target;e.setCoords(),this.onlyDrawPoint=!1,this.verticalLines.clear(),this.horizontalLines.clear();const i=this.getObjectsByTarget(e),n=[];for(const t of i)n.push(...this.getCaCheMapValue(t));const{vLines:s,hLines:r}=u.call(this,e,n);s.forEach(t=>{this.verticalLines.add(JSON.stringify(t))}),r.forEach(t=>{this.horizontalLines.add(JSON.stringify(t))})}beforeRender(){this.canvas.clearContext(this.canvas.contextTop)}afterRender(){this.onlyDrawPoint?f.call(this):(g.call(this),d.call(this))}dispose(){this.canvas.off("mouse:up",this.mouseUp),this.canvas.off("object:resizing",this.scalingOrResizing),this.canvas.off("object:scaling",this.scalingOrResizing),this.canvas.off("object:moving",this.moving),this.canvas.off("before:render",this.beforeRender),this.canvas.off("after:render",this.afterRender)}},t.addGestures=t=>{const e=new i.Region(t.upperCanvasEl);e.addGesture((t=>new i.Rotate(t.upperCanvasEl,e=>{let{rotation:i,event:n}=e;t.fireEventFromPointerEvent(n,"rotate",{rotation:i})}))(t)),e.addGesture((t=>new i.Pinch(t.upperCanvasEl,e=>{let{scale:i,event:n}=e;t.fireEventFromPointerEvent(n,"pinch",{scale:i})}))(t))},t.gradientUpdaterWrapper=O,t.installGradientUpdater=()=>{e.Gradient.fromObject=O(e.Gradient.fromObject)},t.installOriginWrapperUpdater=(t,i)=>{e.BaseFabricObject._fromObject=w(e.BaseFabricObject._fromObject,t,i),e.FabricImage.fromObject=w(e.FabricImage.fromObject,t,i),e.Group.fromObject=w(e.Group.fromObject,t,i)},t.originUpdaterWrapper=w,t.pinchEventHandler=function(t){let{scale:e,target:i,scenePoint:n}=t;i&&this.getActiveObject()===i?(i.scaleX*=e,i.scaleY*=e):this.zoomToPoint(n,this.getZoom()*e)},t.rotateEventHandler=function(t){let{rotation:i,target:n}=t;n&&this.getActiveObject()===n&&n.rotate(n.angle+e.util.radiansToDegrees(i))}});
//# sourceMappingURL=fabric-extensions.min.js.map
