!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("fabric"),require("westures")):"function"==typeof define&&define.amd?define(["exports","fabric","westures"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).fabricExtensions={},t.fabric,t.westures)}(this,function(t,e,i){"use strict";function n(t,e,i){return(e=function(t){var e=function(t,e){if("object"!=typeof t||!t)return t;var i=t[Symbol.toPrimitive];if(void 0!==i){var n=i.call(t,e);if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:e+""}(e))in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}function r(t,e){return Math.abs(t-e)}function s(t,e,i){let n=1/0,s=[];for(const o of e){const e=r(t[i],o[i]);n>e&&(s=[],n=e),n==e&&s.push(o)}return{dis:n,arr:s}}function o(t){const{target:e,isScale:i,isUniform:n,corner:r,point:o,diagonalPoint:a,list:c,isCenter:l}=t,{dis:h,arr:f}=s(o,c,"x");if(h>this.margin/this.canvas.getZoom())return[];let d=f[f.length-1].x-o.x;d*=r.includes("l")?-1:1;const{width:g,height:u,scaleX:v,scaleY:p}=e,m=v*g+(e.strokeUniform?0:e.strokeWidth),b=(d+m)/m;if(0==b)return[];if(i?(e.set("scaleX",v*b),n&&e.set("scaleY",p*b)):(e.set("width",g*b),n&&e.set("height",u*b)),l)e.setRelativeXY(a,"center","center");else{const t=this.contraryOriginMap;e.setRelativeXY(a,...t[r])}return e.setCoords(),f.map(t=>({origin:o,target:t}))}function a(t){const{target:e,isScale:i,isUniform:n,corner:r,point:o,diagonalPoint:a,list:c,isCenter:l}=t,{dis:h,arr:f}=s(o,c,"y");if(h>this.margin/this.canvas.getZoom())return[];let d=f[f.length-1].y-o.y;d*=r.includes("t")?-1:1;const{width:g,height:u,scaleX:v,scaleY:p}=e,m=p*u+(e.strokeUniform?0:e.strokeWidth),b=(d+m)/m;if(0==b)return[];if(i?(e.set("scaleY",p*b),n&&e.set("scaleX",v*b)):(e.set("height",u*b),n&&e.set("width",g*b)),l)e.setRelativeXY(a,"center","center");else{const t=this.contraryOriginMap;e.setRelativeXY(a,...t[r])}return e.setCoords(),f.map(t=>({origin:o,target:t}))}function c(t,e){const i=this.canvas.getTopContext(),n=this.canvas.viewportTransform,r=this.canvas.getZoom();i.save(),i.transform(...n),i.lineWidth=this.width/r,this.lineDash&&i.setLineDash(this.lineDash),i.strokeStyle=this.color,i.beginPath(),i.moveTo(t.x,t.y),i.lineTo(e.x,e.y),i.stroke(),this.lineDash&&i.setLineDash([]),this.drawX(t,-1),this.drawX(e,1),i.restore()}function l(t,e){const i=this.canvas.getTopContext(),n=this.canvas.getZoom(),r=this.xSize/n;i.save(),i.translate(t.x,t.y),i.beginPath(),i.moveTo(-r,-r),i.lineTo(r,r),i.moveTo(r,-r),i.lineTo(-r,r),i.stroke(),i.restore()}function h(t){const e=this.canvas.getTopContext(),i=this.canvas.viewportTransform,n=this.canvas.getZoom();e.save(),e.transform(...i),e.lineWidth=this.width/n,e.strokeStyle=this.color;for(const e of t)this.drawX(e,0);e.restore()}function f(){const t=[];if(!this.closeVLine)for(const e of this.verticalLines)t.push(JSON.parse(e));if(!this.closeHLine)for(const e of this.horizontalLines)t.push(JSON.parse(e));const e=t.map(t=>t.target);h.call(this,e)}function d(){if(!this.closeVLine)for(const t of this.verticalLines){const{origin:i,target:n}=JSON.parse(t),r=new e.Point(n.x,i.y);this.drawLine(r,n)}}function g(){if(!this.closeHLine)for(const t of this.horizontalLines){const{origin:i,target:n}=JSON.parse(t),r=new e.Point(i.x,n.y);this.drawLine(r,n)}}function u(t,e){const i=t.getCoords();i.push(t.getCenterPoint());const n={target:t,list:i,points:e,margin:this.margin/this.canvas.getZoom()};return{vLines:p({...n,type:"x"}),hLines:p({...n,type:"y"})}}const v=[["left","top"],["right","top"],["right","bottom"],["left","bottom"],["center","center"]];function p(t){const{target:e,list:i,points:n,margin:r,type:o}=t,a=[],c=[];let l=1/0;for(const t of i){const e=s(t,n,o);c.push(e),l>e.dis&&(l=e.dis)}if(l>r)return a;let h=!1;for(let t=0;t<i.length;t++){if(c[t].dis!=l)continue;for(const e of c[t].arr)a.push({origin:i[t],target:e});if(h)continue;h=!0;const n=c[t].arr[0][o]-i[t][o];i.forEach(t=>{t[o]+=n}),e.setXY(i[t],...v[t]),e.setCoords()}return a}function m(t){const i=new Set,n=t.canvas;if(!n)return i;const r=t instanceof e.ActiveSelection?t.getObjects():[t];return n.forEachObject(t=>{t.isOnScreen()&&t.visible&&(t.constructor!=e.Group?i.add(t):y(i,t))}),b(i,r),i}function b(t,i){for(const n of i)n.constructor==e.Group?b(t,n.getObjects()):t.delete(n)}function y(t,i){const n=i.getObjects();for(const i of n)i.visible&&(i.constructor!=e.Group?t.add(i):y(t,i))}const w=function(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"left",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"top";return async function(r){const{originX:s=i,originY:o=n}=r;delete r.originX,delete r.originY;for(var a=arguments.length,c=new Array(a>1?a-1:0),l=1;l<a;l++)c[l-1]=arguments[l];const h=await t.call(this,r,...c),f=new e.Point(h.left,h.top);return h.setPositionByOrigin(f,s,o),h}},O=t=>async function(i){const{colorStops:n}=i,r=null==n?void 0:n.map(t=>{let{color:i,opacity:n,offset:r}=t;if(void 0===n||1===n)return{color:i,offset:r};return{color:new e.Color(i).setAlpha(n).toRgba(),offset:r}});return await t.call(this,{...i,colorStops:r})};t.AligningGuidelines=class{constructor(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(this,"canvas",void 0),n(this,"horizontalLines",new Set),n(this,"verticalLines",new Set),n(this,"cacheMap",new Map),n(this,"onlyDrawPoint",!1),n(this,"contraryOriginMap",{tl:["right","bottom"],tr:["left","bottom"],br:["left","top"],bl:["right","top"],mt:["center","bottom"],mr:["left","center"],mb:["center","top"],ml:["right","center"]}),n(this,"xSize",2.4),n(this,"lineDash",void 0),n(this,"margin",4),n(this,"width",1),n(this,"color","rgba(255,0,0,0.9)"),n(this,"closeVLine",!1),n(this,"closeHLine",!1),this.canvas=t,Object.assign(this,e),this.mouseUp=this.mouseUp.bind(this),this.scalingOrResizing=this.scalingOrResizing.bind(this),this.moving=this.moving.bind(this),this.beforeRender=this.beforeRender.bind(this),this.afterRender=this.afterRender.bind(this),this.initBehavior()}initBehavior(){this.canvas.on("mouse:up",this.mouseUp),this.canvas.on("object:resizing",this.scalingOrResizing),this.canvas.on("object:scaling",this.scalingOrResizing),this.canvas.on("object:moving",this.moving),this.canvas.on("before:render",this.beforeRender),this.canvas.on("after:render",this.afterRender)}getObjectsByTarget(t){return m(t)}getPointMap(t){return function(t){const e=t.getCoords();return{tl:e[0],tr:e[1],br:e[2],bl:e[3],mt:e[0].add(e[1]).scalarDivide(2),mr:e[1].add(e[2]).scalarDivide(2),mb:e[2].add(e[3]).scalarDivide(2),ml:e[3].add(e[0]).scalarDivide(2)}}(t)}getContraryMap(t){return function(t){var e;const i=null!==(e=t.aCoords)&&void 0!==e?e:t.calcACoords();return{tl:i.br,tr:i.bl,br:i.tl,bl:i.tr,mt:i.br.add(i.bl).scalarDivide(2),mr:i.bl.add(i.tl).scalarDivide(2),mb:i.tl.add(i.tr).scalarDivide(2),ml:i.tr.add(i.br).scalarDivide(2)}}(t)}getCaCheMapValue(t){const e=[t.calcTransformMatrix().toString(),t.width,t.height].join(),i=this.cacheMap.get(e);if(i)return i;const n=t.getCoords();return n.push(t.getCenterPoint()),this.cacheMap.set(e,n),n}drawLine(t,e){c.call(this,t,e)}drawX(t,e){l.call(this,t,e)}mouseUp(){this.verticalLines.clear(),this.horizontalLines.clear(),this.cacheMap.clear(),this.canvas.requestRenderAll()}scalingOrResizing(t){const i=t.target;i.setCoords();const n=String(t.transform.action).startsWith("scale");this.verticalLines.clear(),this.horizontalLines.clear();const r=this.getObjectsByTarget(i);let s=t.transform.corner;i.flipX&&(s.includes("l")?s=s.replace("l","r"):s.includes("r")&&(s=s.replace("r","l"))),i.flipY&&(s.includes("t")?s=s.replace("t","b"):s.includes("b")&&(s=s.replace("b","t")));const c=this.getPointMap(i);if(!(s in c))return;if(this.onlyDrawPoint=s.includes("m"),this.onlyDrawPoint){if(i.getTotalAngle()%90!=0)return}const l=this.getContraryMap(i),h=c[s];let f=l[s];const d="center"==t.transform.original.originX&&"center"==t.transform.original.originY;if(d){const t=i.group?h.transform(e.util.invertTransform(i.group.calcTransformMatrix())):h;f=f.add(t).scalarDivide(2)}const g=t.e[this.canvas.uniScaleKey];let u=this.canvas.uniformScaling&&!g||!this.canvas.uniformScaling&&g;this.onlyDrawPoint&&(u=!1);const v=[];for(const t of r){const e=this.getCaCheMapValue(t);v.push(...e)}const p={target:i,point:h,diagonalPoint:f,corner:s,list:v,isScale:n,isUniform:u,isCenter:d},m=this.onlyDrawPoint&&(s.includes("t")||s.includes("b")),b=this.onlyDrawPoint&&(s.includes("l")||s.includes("r")),y=m?[]:o.call(this,p),w=b?[]:a.call(this,p);y.forEach(t=>{this.verticalLines.add(JSON.stringify(t))}),w.forEach(t=>{this.horizontalLines.add(JSON.stringify(t))})}moving(t){const e=t.target;e.setCoords(),this.onlyDrawPoint=!1,this.verticalLines.clear(),this.horizontalLines.clear();const i=this.getObjectsByTarget(e),n=[];for(const t of i)n.push(...this.getCaCheMapValue(t));const{vLines:r,hLines:s}=u.call(this,e,n);r.forEach(t=>{this.verticalLines.add(JSON.stringify(t))}),s.forEach(t=>{this.horizontalLines.add(JSON.stringify(t))})}beforeRender(){this.canvas.clearContext(this.canvas.contextTop)}afterRender(){this.onlyDrawPoint?f.call(this):(d.call(this),g.call(this))}dispose(){this.canvas.off("mouse:up",this.mouseUp),this.canvas.off("object:resizing",this.scalingOrResizing),this.canvas.off("object:scaling",this.scalingOrResizing),this.canvas.off("object:moving",this.moving),this.canvas.off("before:render",this.beforeRender),this.canvas.off("after:render",this.afterRender)}},t.addGestures=t=>{const e=new i.Region(t.upperCanvasEl);t.addOrRemove(function(t){for(var e=arguments.length,i=new Array(e>1?e-1:0),n=1;n<e;n++)i[n-1]=arguments[n];return t.removeEventListener(...i)}),e.addGesture((t=>new i.Rotate(t.upperCanvasEl,e=>{let{rotation:i,event:n}=e;t.fireEventFromPointerEvent(n,"rotate","rotate",{rotation:i})}))(t)),e.addGesture((t=>new i.Pinch(t.upperCanvasEl,e=>{let{scale:i,event:n}=e;t.fireEventFromPointerEvent(n,"pinch","pinch",{scale:i})}))(t)),e.addGesture((t=>new i.Tap(t.upperCanvasEl,e=>{let{event:i}=e;t.fireEventFromPointerEvent(i,"mouse:tripleclick","mousetripleclick",void 0),i.preventDefault()},{numTaps:3,maxRetain:400}))(t)),e.addGesture((t=>new i.Tap(t.upperCanvasEl,e=>{let{event:i}=e;t.fireEventFromPointerEvent(i,"mouse:dblclick","mousedblclick",void 0),i.preventDefault()},{numTaps:2,maxRetain:300}))(t)),t.addOrRemove(function(t){for(var e=arguments.length,i=new Array(e>1?e-1:0),n=1;n<e;n++)i[n-1]=arguments[n];return t.addEventListener(...i)},!0)},t.gradientUpdaterWrapper=O,t.installGradientUpdater=()=>{e.Gradient.fromObject=O(e.Gradient.fromObject)},t.installOriginWrapperUpdater=(t,i)=>{e.BaseFabricObject._fromObject=w(e.BaseFabricObject._fromObject,t,i),e.FabricImage.fromObject=w(e.FabricImage.fromObject,t,i),e.Group.fromObject=w(e.Group.fromObject,t,i)},t.originUpdaterWrapper=w,t.pinchEventHandler=function(t){let{scale:e,target:i,scenePoint:n}=t;i&&this.getActiveObject()===i?(i.scaleX*=e,i.scaleY*=e):this.zoomToPoint(n,this.getZoom()*e)},t.rotateEventHandler=function(t){let{rotation:i,target:n}=t;n&&this.getActiveObject()===n&&n.rotate(n.angle+e.util.radiansToDegrees(i))}});
//# sourceMappingURL=fabric-extensions.min.js.map
