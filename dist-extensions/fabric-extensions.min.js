!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?i(exports,require("fabric")):"function"==typeof define&&define.amd?define(["exports","fabric"],i):i((t="undefined"!=typeof globalThis?globalThis:t||self).fabricExtensions={},t.fabric)}(this,function(t,i){"use strict";function e(t,i,e){return(i=function(t){var i=function(t,i){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var n=e.call(t,i);if("object"!=typeof n)return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===i?String:Number)(t)}(t,"string");return"symbol"==typeof i?i:i+""}(i))in t?Object.defineProperty(t,i,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[i]=e,t}function n(t,i){return Math.abs(t-i)}function s(t,i,e){let s=1/0,r=[];for(const o of i){const i=n(t[e],o[e]);s>i&&(r=[],s=i),s==i&&r.push(o)}return{dis:s,arr:r}}function r(t){const{target:i,isScale:e,isUniform:n,corner:r,point:o,diagonalPoint:a,list:c,isCenter:l}=t,{dis:h,arr:f}=s(o,c,"x");if(h>this.margin/this.canvas.getZoom())return[];let g=f[f.length-1].x-o.x;g*=r.includes("l")?-1:1;const{width:d,height:u,scaleX:p,scaleY:v}=i,m=p*d+(i.strokeUniform?0:i.strokeWidth),b=(g+m)/m;if(0==b)return[];if(e?(i.set("scaleX",p*b),n&&i.set("scaleY",v*b)):(i.set("width",d*b),n&&i.set("height",u*b)),l)i.setRelativeXY(a,"center","center");else{const t=this.contraryOriginMap;i.setRelativeXY(a,...t[r])}return i.setCoords(),f.map(t=>({origin:o,target:t}))}function o(t){const{target:i,isScale:e,isUniform:n,corner:r,point:o,diagonalPoint:a,list:c,isCenter:l}=t,{dis:h,arr:f}=s(o,c,"y");if(h>this.margin/this.canvas.getZoom())return[];let g=f[f.length-1].y-o.y;g*=r.includes("t")?-1:1;const{width:d,height:u,scaleX:p,scaleY:v}=i,m=v*u+(i.strokeUniform?0:i.strokeWidth),b=(g+m)/m;if(0==b)return[];if(e?(i.set("scaleY",v*b),n&&i.set("scaleX",p*b)):(i.set("height",u*b),n&&i.set("width",d*b)),l)i.setRelativeXY(a,"center","center");else{const t=this.contraryOriginMap;i.setRelativeXY(a,...t[r])}return i.setCoords(),f.map(t=>({origin:o,target:t}))}function a(t,i){const e=this.canvas.getTopContext(),n=this.canvas.viewportTransform,s=this.canvas.getZoom();e.save(),e.transform(...n),e.lineWidth=this.width/s,this.lineDash&&e.setLineDash(this.lineDash),e.strokeStyle=this.color,e.beginPath(),e.moveTo(t.x,t.y),e.lineTo(i.x,i.y),e.stroke(),this.lineDash&&e.setLineDash([]),this.drawX(t,-1),this.drawX(i,1),e.restore()}function c(t,i){const e=this.canvas.getTopContext(),n=this.canvas.getZoom(),s=this.xSize/n;e.save(),e.translate(t.x,t.y),e.beginPath(),e.moveTo(-s,-s),e.lineTo(s,s),e.moveTo(s,-s),e.lineTo(-s,s),e.stroke(),e.restore()}function l(t){const i=this.canvas.getTopContext(),e=this.canvas.viewportTransform,n=this.canvas.getZoom();i.save(),i.transform(...e),i.lineWidth=this.width/n,i.strokeStyle=this.color;for(const i of t)this.drawX(i,0);i.restore()}function h(){const t=[];if(!this.closeVLine)for(const i of this.verticalLines)t.push(JSON.parse(i));if(!this.closeHLine)for(const i of this.horizontalLines)t.push(JSON.parse(i));const i=t.map(t=>t.target);l.call(this,i)}function f(){if(!this.closeVLine)for(const t of this.verticalLines){const{origin:e,target:n}=JSON.parse(t),s=new i.Point(n.x,e.y);this.drawLine(s,n)}}function g(){if(!this.closeHLine)for(const t of this.horizontalLines){const{origin:e,target:n}=JSON.parse(t),s=new i.Point(e.x,n.y);this.drawLine(s,n)}}function d(t,i){const e=t.getCoords();e.push(t.getCenterPoint());const n={target:t,list:e,points:i,margin:this.margin/this.canvas.getZoom()};return{vLines:p({...n,type:"x"}),hLines:p({...n,type:"y"})}}const u=[["left","top"],["right","top"],["right","bottom"],["left","bottom"],["center","center"]];function p(t){const{target:i,list:e,points:n,margin:r,type:o}=t,a=[],c=[];let l=1/0;for(const t of e){const i=s(t,n,o);c.push(i),l>i.dis&&(l=i.dis)}if(l>r)return a;let h=!1;for(let t=0;t<e.length;t++){if(c[t].dis!=l)continue;for(const i of c[t].arr)a.push({origin:e[t],target:i});if(h)continue;h=!0;const n=c[t].arr[0][o]-e[t][o];e.forEach(t=>{t[o]+=n}),i.setXY(e[t],...u[t]),i.setCoords()}return a}function v(t){const e=new Set,n=t.canvas;if(!n)return e;const s=t instanceof i.ActiveSelection?t.getObjects():[t];return n.forEachObject(t=>{t.isOnScreen()&&t.visible&&(t.constructor!=i.Group?e.add(t):b(e,t))}),m(e,s),e}function m(t,e){for(const n of e)n.constructor==i.Group?m(t,n.getObjects()):t.delete(n)}function b(t,e){const n=e.getObjects();for(const e of n)e.visible&&(e.constructor!=i.Group?t.add(e):b(t,e))}const y=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"left",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"top";return async function(s){const{originX:r=e,originY:o=n}=s;delete s.originX,delete s.originY;for(var a=arguments.length,c=new Array(a>1?a-1:0),l=1;l<a;l++)c[l-1]=arguments[l];const h=await t.call(this,s,...c),f=new i.Point(h.left,h.top);return h.setPositionByOrigin(f,r,o),h}},O=t=>async function(e){const{colorStops:n}=e,s=null==n?void 0:n.map(t=>{let{color:e,opacity:n,offset:s}=t;if(void 0===n||1===n)return{color:e,offset:s};return{color:new i.Color(e).setAlpha(n).toRgba(),offset:s}});return await t.call(this,{...e,colorStops:s})};t.AligningGuidelines=class{constructor(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e(this,"canvas",void 0),e(this,"horizontalLines",new Set),e(this,"verticalLines",new Set),e(this,"cacheMap",new Map),e(this,"onlyDrawPoint",!1),e(this,"contraryOriginMap",{tl:["right","bottom"],tr:["left","bottom"],br:["left","top"],bl:["right","top"],mt:["center","bottom"],mr:["left","center"],mb:["center","top"],ml:["right","center"]}),e(this,"xSize",2.4),e(this,"lineDash",void 0),e(this,"margin",4),e(this,"width",1),e(this,"color","rgba(255,0,0,0.9)"),e(this,"closeVLine",!1),e(this,"closeHLine",!1),this.canvas=t,Object.assign(this,i),this.mouseUp=this.mouseUp.bind(this),this.scalingOrResizing=this.scalingOrResizing.bind(this),this.moving=this.moving.bind(this),this.beforeRender=this.beforeRender.bind(this),this.afterRender=this.afterRender.bind(this),this.initBehavior()}initBehavior(){this.canvas.on("mouse:up",this.mouseUp),this.canvas.on("object:resizing",this.scalingOrResizing),this.canvas.on("object:scaling",this.scalingOrResizing),this.canvas.on("object:moving",this.moving),this.canvas.on("before:render",this.beforeRender),this.canvas.on("after:render",this.afterRender)}getObjectsByTarget(t){return v(t)}getPointMap(t){return function(t){const i=t.getCoords();return{tl:i[0],tr:i[1],br:i[2],bl:i[3],mt:i[0].add(i[1]).scalarDivide(2),mr:i[1].add(i[2]).scalarDivide(2),mb:i[2].add(i[3]).scalarDivide(2),ml:i[3].add(i[0]).scalarDivide(2)}}(t)}getContraryMap(t){return function(t){var i;const e=null!==(i=t.aCoords)&&void 0!==i?i:t.calcACoords();return{tl:e.br,tr:e.bl,br:e.tl,bl:e.tr,mt:e.br.add(e.bl).scalarDivide(2),mr:e.bl.add(e.tl).scalarDivide(2),mb:e.tl.add(e.tr).scalarDivide(2),ml:e.tr.add(e.br).scalarDivide(2)}}(t)}getCaCheMapValue(t){const i=[t.calcTransformMatrix().toString(),t.width,t.height].join(),e=this.cacheMap.get(i);if(e)return e;const n=t.getCoords();return n.push(t.getCenterPoint()),this.cacheMap.set(i,n),n}drawLine(t,i){a.call(this,t,i)}drawX(t,i){c.call(this,t,i)}mouseUp(){this.verticalLines.clear(),this.horizontalLines.clear(),this.cacheMap.clear(),this.canvas.requestRenderAll()}scalingOrResizing(t){const e=t.target;e.setCoords();const n=String(t.transform.action).startsWith("scale");this.verticalLines.clear(),this.horizontalLines.clear();const s=this.getObjectsByTarget(e);let a=t.transform.corner;e.flipX&&(a.includes("l")?a=a.replace("l","r"):a.includes("r")&&(a=a.replace("r","l"))),e.flipY&&(a.includes("t")?a=a.replace("t","b"):a.includes("b")&&(a=a.replace("b","t")));const c=this.getPointMap(e);if(!(a in c))return;if(this.onlyDrawPoint=a.includes("m"),this.onlyDrawPoint){if(e.getTotalAngle()%90!=0)return}const l=this.getContraryMap(e),h=c[a];let f=l[a];const g="center"==t.transform.original.originX&&"center"==t.transform.original.originY;if(g){const t=e.group?h.transform(i.util.invertTransform(e.group.calcTransformMatrix())):h;f=f.add(t).scalarDivide(2)}const d=t.e[this.canvas.uniScaleKey];let u=this.canvas.uniformScaling&&!d||!this.canvas.uniformScaling&&d;this.onlyDrawPoint&&(u=!1);const p=[];for(const t of s){const i=this.getCaCheMapValue(t);p.push(...i)}const v={target:e,point:h,diagonalPoint:f,corner:a,list:p,isScale:n,isUniform:u,isCenter:g},m=this.onlyDrawPoint&&(a.includes("t")||a.includes("b")),b=this.onlyDrawPoint&&(a.includes("l")||a.includes("r")),y=m?[]:r.call(this,v),O=b?[]:o.call(this,v);y.forEach(t=>{this.verticalLines.add(JSON.stringify(t))}),O.forEach(t=>{this.horizontalLines.add(JSON.stringify(t))})}moving(t){const i=t.target;i.setCoords(),this.onlyDrawPoint=!1,this.verticalLines.clear(),this.horizontalLines.clear();const e=this.getObjectsByTarget(i),n=[];for(const t of e)n.push(...this.getCaCheMapValue(t));const{vLines:s,hLines:r}=d.call(this,i,n);s.forEach(t=>{this.verticalLines.add(JSON.stringify(t))}),r.forEach(t=>{this.horizontalLines.add(JSON.stringify(t))})}beforeRender(){this.canvas.clearContext(this.canvas.contextTop)}afterRender(){this.onlyDrawPoint?h.call(this):(f.call(this),g.call(this))}dispose(){this.canvas.off("mouse:up",this.mouseUp),this.canvas.off("object:resizing",this.scalingOrResizing),this.canvas.off("object:scaling",this.scalingOrResizing),this.canvas.off("object:moving",this.moving),this.canvas.off("before:render",this.beforeRender),this.canvas.off("after:render",this.afterRender)}},t.gradientUpdaterWrapper=O,t.installGradientUpdater=()=>{i.Gradient.fromObject=O(i.Gradient.fromObject)},t.installOriginWrapperUpdater=(t,e)=>{i.BaseFabricObject._fromObject=y(i.BaseFabricObject._fromObject,t,e),i.FabricImage.fromObject=y(i.FabricImage.fromObject,t,e),i.Group.fromObject=y(i.Group.fromObject,t,e)},t.originUpdaterWrapper=y});
//# sourceMappingURL=fabric-extensions.min.js.map
