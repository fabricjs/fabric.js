{"version":3,"file":"fabric-extensions.min.js","sources":["../extensions/aligning_guidelines/util/basic.ts","../extensions/aligning_guidelines/util/collect-point.ts","../extensions/aligning_guidelines/util/draw.ts","../extensions/aligning_guidelines/util/collect-line.ts","../extensions/aligning_guidelines/util/get-objects-by-target.ts","../extensions/data_updaters/origins/index.ts","../extensions/data_updaters/gradient/index.ts","../extensions/westures_integration/index.ts","../extensions/cropping_controls/croppingHandlers.ts","../extensions/cropping_controls/renderCornerControl.ts","../extensions/cropping_controls/croppingControls.ts","../extensions/aligning_guidelines/index.ts","../extensions/cropping_controls/enterCropMode.ts"],"sourcesContent":["import type { FabricObject, Point } from 'fabric';\nimport type { PointMap } from '../typedefs';\n\nexport function getDistance(a: number, b: number) {\n  return Math.abs(a - b);\n}\n\nexport function getDistanceList(point: Point, list: Point[], type: 'x' | 'y') {\n  let dis = Infinity;\n  let arr: Point[] = [];\n  for (const item of list) {\n    const v = getDistance(point[type], item[type]);\n    if (dis > v) {\n      arr = [];\n      dis = v;\n    }\n    if (dis == v) {\n      arr.push(item);\n    }\n  }\n  return { dis, arr };\n}\n\nexport function getPointMap(target: FabricObject): PointMap {\n  const coords = target.getCoords();\n  return {\n    tl: coords[0],\n    tr: coords[1],\n    br: coords[2],\n    bl: coords[3],\n    mt: coords[0].add(coords[1]).scalarDivide(2),\n    mr: coords[1].add(coords[2]).scalarDivide(2),\n    mb: coords[2].add(coords[3]).scalarDivide(2),\n    ml: coords[3].add(coords[0]).scalarDivide(2),\n  };\n}\n\nexport function getContraryMap(target: FabricObject): PointMap {\n  const aCoords = target.aCoords ?? target.calcACoords();\n  return {\n    tl: aCoords.br,\n    tr: aCoords.bl,\n    br: aCoords.tl,\n    bl: aCoords.tr,\n    mt: aCoords.br.add(aCoords.bl).scalarDivide(2),\n    mr: aCoords.bl.add(aCoords.tl).scalarDivide(2),\n    mb: aCoords.tl.add(aCoords.tr).scalarDivide(2),\n    ml: aCoords.tr.add(aCoords.br).scalarDivide(2),\n  };\n}\n","import type { FabricObject, Point } from 'fabric';\nimport type { AligningGuidelines } from '..';\nimport type { LineProps } from '../typedefs';\nimport { getDistanceList } from './basic';\n\ntype CollectPointProps = {\n  target: FabricObject;\n  /** Operation points of the target element: top-left, bottom-left, top-right, bottom-right */\n  point: Point;\n  /** Position using diagonal points when resizing/scaling. */\n  diagonalPoint: Point;\n  /** Set of points to consider for alignment: [tl, tr, br, bl, center] */\n  list: Point[];\n  /** Change the zoom or change the size, determine by whether e.transform.action starts with the string \"scale\" */\n  isScale: boolean;\n  /** Whether to change uniformly is determined by canvas.uniformScaling and canvas.uniScaleKey. */\n  isUniform: boolean;\n  /** When holding the centerKey (default is altKey), the shape will scale based on the center point, with the reference point being the center. */\n  isCenter: boolean;\n  /** tl、tr、br、bl、mt、mr、mb、ml */\n  corner: string;\n};\n\nexport function collectVerticalPoint(\n  this: AligningGuidelines,\n  props: CollectPointProps,\n): LineProps[] {\n  const {\n    target,\n    isScale,\n    isUniform,\n    corner,\n    point,\n    diagonalPoint,\n    list,\n    isCenter,\n  } = props;\n  const { dis, arr } = getDistanceList(point, list, 'x');\n  const margin = this.margin / this.canvas.getZoom();\n  if (dis > margin) return [];\n  let v = arr[arr.length - 1].x - point.x;\n  // tl bl ml\n  // If modifying on the left side, the size decreases; conversely, it increases.\n  const dirX = corner.includes('l') ? -1 : 1;\n  v *= dirX;\n\n  const { width, height, scaleX, scaleY } = target;\n  // Because when modifying through the center point, isUniform is always false, so skew does not need to be considered.\n  const dStrokeWidth = target.strokeUniform ? 0 : target.strokeWidth;\n  const scaleWidth = scaleX * width + dStrokeWidth;\n  const sx = (v + scaleWidth) / scaleWidth;\n  // When v equals -scaleWidth, sx equals 0.\n  if (sx == 0) return [];\n  if (isScale) {\n    target.set('scaleX', scaleX * sx);\n    if (isUniform) target.set('scaleY', scaleY * sx);\n  } else {\n    target.set('width', width * sx);\n    if (isUniform) target.set('height', height * sx);\n  }\n  if (isCenter) {\n    target.setRelativeXY(diagonalPoint, 'center', 'center');\n  } else {\n    const originArr = this.contraryOriginMap;\n    target.setRelativeXY(diagonalPoint, ...originArr[corner]);\n  }\n  target.setCoords();\n  return arr.map((target) => ({ origin: point, target }));\n}\n\nexport function collectHorizontalPoint(\n  this: AligningGuidelines,\n  props: CollectPointProps,\n): LineProps[] {\n  const {\n    target,\n    isScale,\n    isUniform,\n    corner,\n    point,\n    diagonalPoint,\n    list,\n    isCenter,\n  } = props;\n  const { dis, arr } = getDistanceList(point, list, 'y');\n  const margin = this.margin / this.canvas.getZoom();\n  if (dis > margin) return [];\n  let v = arr[arr.length - 1].y - point.y;\n  // tl mt tr\n  // If modifying on the top side, the size decreases; conversely, it increases.\n  const dirY = corner.includes('t') ? -1 : 1;\n  v *= dirY;\n\n  const { width, height, scaleX, scaleY } = target;\n  // Because when modifying through the center point, isUniform is always false, so skew does not need to be considered.\n  const dStrokeWidth = target.strokeUniform ? 0 : target.strokeWidth;\n  const scaleHeight = scaleY * height + dStrokeWidth;\n  const sy = (v + scaleHeight) / scaleHeight;\n  // When v equals -scaleHeight, sy equals 0.\n  if (sy == 0) return [];\n  if (isScale) {\n    target.set('scaleY', scaleY * sy);\n    if (isUniform) target.set('scaleX', scaleX * sy);\n  } else {\n    target.set('height', height * sy);\n    if (isUniform) target.set('width', width * sy);\n  }\n  if (isCenter) {\n    target.setRelativeXY(diagonalPoint, 'center', 'center');\n  } else {\n    const originArr = this.contraryOriginMap;\n    target.setRelativeXY(diagonalPoint, ...originArr[corner]);\n  }\n  target.setCoords();\n  return arr.map((target) => ({ origin: point, target }));\n}\n","import { Point } from 'fabric';\nimport type { AligningGuidelines } from '..';\n\nexport function drawLine(\n  this: AligningGuidelines,\n  origin: Point,\n  target: Point,\n) {\n  const ctx = this.canvas.getTopContext();\n  const viewportTransform = this.canvas.viewportTransform;\n  const zoom = this.canvas.getZoom();\n  ctx.save();\n  ctx.transform(...viewportTransform);\n  ctx.lineWidth = this.width / zoom;\n  if (this.lineDash) ctx.setLineDash(this.lineDash);\n  ctx.strokeStyle = this.color;\n  ctx.beginPath();\n  ctx.moveTo(origin.x, origin.y);\n  ctx.lineTo(target.x, target.y);\n  ctx.stroke();\n  if (this.lineDash) ctx.setLineDash([]);\n\n  this.drawX(origin, -1);\n  this.drawX(target, 1);\n  ctx.restore();\n}\n\nexport function drawX(this: AligningGuidelines, point: Point, _: number) {\n  const ctx = this.canvas.getTopContext();\n  const zoom = this.canvas.getZoom();\n  const size = this.xSize / zoom;\n  ctx.save();\n  ctx.translate(point.x, point.y);\n  ctx.beginPath();\n  ctx.moveTo(-size, -size);\n  ctx.lineTo(size, size);\n  ctx.moveTo(size, -size);\n  ctx.lineTo(-size, size);\n  ctx.stroke();\n  ctx.restore();\n}\nfunction drawPoint(this: AligningGuidelines, arr: Point[]) {\n  const ctx = this.canvas.getTopContext();\n  const viewportTransform = this.canvas.viewportTransform;\n  const zoom = this.canvas.getZoom();\n  ctx.save();\n  ctx.transform(...viewportTransform);\n  ctx.lineWidth = this.width / zoom;\n  ctx.strokeStyle = this.color;\n  for (const item of arr) this.drawX(item, 0);\n  ctx.restore();\n}\n\nexport function drawPointList(this: AligningGuidelines) {\n  const list = [];\n  if (!this.closeVLine) {\n    for (const v of this.verticalLines) list.push(JSON.parse(v));\n  }\n  if (!this.closeHLine) {\n    for (const h of this.horizontalLines) list.push(JSON.parse(h));\n  }\n  const arr = list.map((item) => item.target);\n  drawPoint.call(this, arr);\n}\n\nexport function drawVerticalLine(this: AligningGuidelines) {\n  if (this.closeVLine) return;\n\n  for (const v of this.verticalLines) {\n    const { origin, target } = JSON.parse(v);\n    const o = new Point(target.x, origin.y);\n    this.drawLine(o, target);\n  }\n}\n\nexport function drawHorizontalLine(this: AligningGuidelines) {\n  if (this.closeHLine) return;\n\n  for (const v of this.horizontalLines) {\n    const { origin, target } = JSON.parse(v);\n    const o = new Point(origin.x, target.y);\n    this.drawLine(o, target);\n  }\n}\n","import type { FabricObject, Point, TOriginX, TOriginY } from 'fabric';\nimport type { AligningGuidelines } from '..';\nimport type { LineProps } from '../typedefs';\nimport { getDistanceList } from './basic';\n\nexport function collectLine(\n  this: AligningGuidelines,\n  target: FabricObject,\n  points: Point[],\n) {\n  const list = target.getCoords();\n  list.push(target.getCenterPoint());\n  const margin = this.margin / this.canvas.getZoom();\n  const opts = { target, list, points, margin };\n  const vLines = collectPoints({ ...opts, type: 'x' });\n  const hLines = collectPoints({ ...opts, type: 'y' });\n\n  return { vLines, hLines };\n}\n\ntype CollectItemLineProps = {\n  target: FabricObject;\n  list: Point[];\n  points: Point[];\n  margin: number;\n  type: 'x' | 'y';\n};\nconst originArr: [TOriginX, TOriginY][] = [\n  ['left', 'top'],\n  ['right', 'top'],\n  ['right', 'bottom'],\n  ['left', 'bottom'],\n  ['center', 'center'],\n];\nfunction collectPoints(props: CollectItemLineProps) {\n  const { target, list, points, margin, type } = props;\n  const res: LineProps[] = [];\n  const arr: ReturnType<typeof getDistanceList>[] = [];\n  let min = Infinity;\n  for (const item of list) {\n    const o = getDistanceList(item, points, type);\n    arr.push(o);\n    if (min > o.dis) min = o.dis;\n  }\n  if (min > margin) return res;\n  let b = false;\n  for (let i = 0; i < list.length; i++) {\n    if (arr[i].dis != min) continue;\n    for (const item of arr[i].arr) {\n      res.push({ origin: list[i], target: item });\n    }\n\n    if (b) continue;\n    b = true;\n    const d = arr[i].arr[0][type] - list[i][type];\n    // It will change the original data, and the next time we collect y, use the modified data.\n    list.forEach((item) => {\n      item[type] += d;\n    });\n    target.setXY(list[i], ...originArr[i]);\n    target.setCoords();\n  }\n\n  return res;\n}\n","import type { FabricObject } from 'fabric';\nimport { ActiveSelection, Group } from 'fabric';\n\nexport function getObjectsByTarget(target: FabricObject) {\n  const objects = new Set<FabricObject>();\n  const canvas = target.canvas;\n  if (!canvas) return objects;\n  const children =\n    target instanceof ActiveSelection ? target.getObjects() : [target];\n\n  canvas.forEachObject((o) => {\n    if (!o.isOnScreen()) return;\n    if (!o.visible) return;\n    if (o.constructor == Group) {\n      collectObjectsByGroup(objects, o);\n      return;\n    }\n    objects.add(o);\n  });\n\n  deleteObjectsByList(objects, children);\n  return objects;\n}\n\nfunction deleteObjectsByList(objects: Set<FabricObject>, list: FabricObject[]) {\n  for (const target of list) {\n    if (target.constructor == Group) {\n      deleteObjectsByList(objects, (target as Group).getObjects());\n    } else {\n      objects.delete(target);\n    }\n  }\n}\n\nfunction collectObjectsByGroup(objects: Set<FabricObject>, g: Group) {\n  const children = g.getObjects();\n  for (const child of children) {\n    if (!child.visible) continue;\n    if (child.constructor == Group) {\n      collectObjectsByGroup(objects, child);\n      continue;\n    }\n    objects.add(child);\n  }\n}\n","import {\n  Point,\n  FabricImage,\n  Group,\n  BaseFabricObject,\n  type FabricObject,\n  type TOriginX,\n  type TOriginY,\n} from 'fabric';\n\n/**\n * Updates the fromObject function of a class to return a version that can restore old data\n * with values of originX and originY that are different from 'center', 'center'\n * Used to upgrade from fabric 6 to fabric 7\n * @param originalFn the original fromObject function of an object,\n * @param defaultOriginX optional default value for non exported originX,\n * @param defaultOriginY optional default value for non exported originY,\n * @returns a wrapped fromObject function for the object\n */\nexport const originUpdaterWrapper = <T extends FabricObject = FabricObject>(\n  originalFn: (...args: any[]) => Promise<T>,\n  defaultOriginX: TOriginX = 'left',\n  defaultOriginY: TOriginY = 'top',\n): ((...args: any[]) => Promise<T>) =>\n  async function (this: T, serializedObject, ...args) {\n    // we default to left and top because those are defaults before deprecation\n    const { originX = defaultOriginX, originY = defaultOriginY } =\n      serializedObject;\n    // and we do not want to pass those properties on the object anymore\n    delete serializedObject.originX;\n    delete serializedObject.originY;\n    const originalObject = await originalFn.call(\n      this,\n      serializedObject,\n      ...args,\n    );\n    const actualPosition = new Point(originalObject.left, originalObject.top);\n    originalObject.setPositionByOrigin(actualPosition, originX, originY);\n    return originalObject;\n  };\n\n/**\n * Wraps and override the current fabricJS fromObject static functions\n * Used to upgrade from fabric 7 to fabric 8\n * If you used to export with includeDefaultValues = false, you have to specify\n * which were yours default origins values\n * @param originX optional default value for non exported originX,\n * @param originY optional default value for non exported originY,\n */\nexport const installOriginWrapperUpdater = (\n  originX?: TOriginX,\n  originY?: TOriginY,\n) => {\n  // @ts-expect-error the _fromObject parameter could be instantiated differently\n  BaseFabricObject._fromObject = originUpdaterWrapper(\n    BaseFabricObject._fromObject,\n    originX,\n    originY,\n  );\n  // FabricImage and Group do not use _fromObject\n  FabricImage.fromObject = originUpdaterWrapper<FabricImage>(\n    FabricImage.fromObject,\n    originX,\n    originY,\n  );\n  Group.fromObject = originUpdaterWrapper<Group>(\n    Group.fromObject,\n    originX,\n    originY,\n  );\n};\n","import type { GradientOptions, ColorStop } from 'fabric';\nimport { Color, Gradient } from 'fabric';\n\n/**\n * Updates the fromObject function of a Gradient to return a version that can restore old data\n * with opactiy in color Stops\n * Used to upgrade from fabric 6 to fabric 7\n * @param originalFn the original fromObject function of an object,\n * @returns a wrapped fromObject function for the object\n */\n\ntype OldColorStop = ColorStop & {\n  opacity?: number;\n};\n\nexport const gradientUpdaterWrapper = <S, T extends Gradient<S> = Gradient<S>>(\n  originalFn: (\n    options: GradientOptions<'linear'> | GradientOptions<'radial'>,\n  ) => Promise<T>,\n): ((\n  options: GradientOptions<'linear'> | GradientOptions<'radial'>,\n) => Promise<T>) =>\n  async function (this: T, serializedGradient) {\n    // we default to left and top because those are defaults before deprecation\n    const { colorStops } = serializedGradient;\n    // and we do not want to pass those properties on the object anymore\n    const newColorStops: ColorStop[] = (\n      colorStops as OldColorStop[]\n    )?.map<ColorStop>(({ color, opacity, offset }) => {\n      if (opacity === undefined || opacity === 1) {\n        return {\n          color,\n          offset,\n        };\n      }\n      const col = new Color(color).setAlpha(opacity).toRgba();\n      return {\n        color: col,\n        offset,\n      };\n    });\n    const gradient = await originalFn.call(this, {\n      ...serializedGradient,\n      colorStops: newColorStops,\n    });\n    return gradient;\n  };\n\n/**\n * Wraps and override the current fabricJS fromObject static functions\n * Used to upgrade from fabric 7 to fabric 8\n * If you used to export with includeDefaultValues = false, you have to specify\n * which were yours default origins values\n */\nexport const installGradientUpdater = () => {\n  // @ts-expect-error untypable\n  Gradient.fromObject = gradientUpdaterWrapper(Gradient.fromObject);\n};\n","import wes from 'westures';\nimport { type Canvas, type CanvasEvents, type XY, util } from 'fabric';\n\ntype PinchEventData = {\n  centroid: XY;\n  event: PointerEvent;\n  phase: string;\n  type: 'pinch';\n  scale: number;\n  target: HTMLElement;\n};\n\ntype RotateEventData = {\n  centroid: XY;\n  event: PointerEvent;\n  phase: string;\n  type: 'rotate';\n  rotation: number;\n  target: HTMLElement;\n};\n\ntype TapEventData = {\n  centroid: XY;\n  event: PointerEvent;\n  phase: string;\n  type: 'tap';\n  target: HTMLElement;\n};\n\n/**\n * Register this handler on canvas.on('pinch', pinchEventHandler);\n * To get an out of the box functionality for the pinch to zoom\n */\nexport function pinchEventHandler(\n  this: Canvas,\n  { scale, target, scenePoint }: CanvasEvents['pinch'],\n) {\n  if (target && this.getActiveObject() === target) {\n    // if we are pinching on the active object, let's scale it\n    target.scaleX *= scale;\n    target.scaleY *= scale;\n  } else {\n    this.zoomToPoint(scenePoint, this.getZoom() * scale);\n  }\n}\n\nexport function rotateEventHandler(\n  this: Canvas,\n  { rotation, target }: CanvasEvents['rotate'],\n) {\n  if (target && this.getActiveObject() === target) {\n    target.rotate(target.angle + util.radiansToDegrees(rotation));\n  }\n}\n\nexport const tripleTapGesture = (canvas: Canvas) => {\n  return new wes.Tap(\n    canvas.upperCanvasEl,\n    ({ event }: TapEventData) => {\n      canvas.fireEventFromPointerEvent(\n        event,\n        'mouse:tripleclick',\n        'mousetripleclick',\n        undefined,\n      );\n      event.preventDefault();\n    },\n    {\n      numTaps: 3,\n      maxRetain: 400,\n    },\n  );\n};\n\nexport const doubleTapGesture = (canvas: Canvas) => {\n  return new wes.Tap(\n    canvas.upperCanvasEl,\n    ({ event }: TapEventData) => {\n      canvas.fireEventFromPointerEvent(\n        event,\n        'mouse:dblclick',\n        'mousedblclick',\n        undefined,\n      );\n      event.preventDefault();\n    },\n    {\n      numTaps: 2,\n      maxRetain: 300,\n    },\n  );\n};\n\nexport const pinchGesture = (canvas: Canvas) => {\n  return new wes.Pinch(\n    canvas.upperCanvasEl,\n    ({ scale, event }: PinchEventData) => {\n      canvas.fireEventFromPointerEvent(event, 'pinch', 'pinch', { scale });\n    },\n  );\n};\n\nexport const rotateGesture = (canvas: Canvas) => {\n  return new wes.Rotate(\n    canvas.upperCanvasEl,\n    ({ rotation, event }: RotateEventData) => {\n      canvas.fireEventFromPointerEvent(event, 'rotate', 'rotate', { rotation });\n    },\n  );\n};\n\n/**\n * Add a serie of gestures recognition on the canvas\n */\nexport const addGestures = (canvas: Canvas) => {\n  const canvasRegion = new wes.Region(canvas.upperCanvasEl);\n  canvas.addOrRemove(\n    (\n      el: HTMLElement,\n      ...args: Parameters<HTMLElement['removeEventListener']>\n    ) => el.removeEventListener(...args),\n  );\n  canvasRegion.addGesture(rotateGesture(canvas));\n  canvasRegion.addGesture(pinchGesture(canvas));\n  canvasRegion.addGesture(tripleTapGesture(canvas));\n  canvasRegion.addGesture(doubleTapGesture(canvas));\n  // add back events, excluding the click one\n  canvas.addOrRemove(\n    (el: HTMLElement, ...args: Parameters<HTMLElement['addEventListener']>) =>\n      el.addEventListener(...args),\n    true,\n  );\n};\n","import type {\n  TModificationEvents,\n  Transform,\n  TransformActionHandler,\n  FabricImage,\n  ObjectEvents,\n} from 'fabric';\nimport { controlsUtils, Point, util } from 'fabric';\n\nconst { wrapWithFixedAnchor, wrapWithFireEvent } = controlsUtils;\n\n/**\n * Wrap controlsUtils.changeObjectWidth with image constrains\n */\nexport const changeImageWidth: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  const { target } = transform;\n  const { width } = target;\n  const image = target as FabricImage;\n  const modified = controlsUtils.changeObjectWidth(eventData, transform, x, y);\n  const availableWidth = image._element.width - image.cropX;\n  if (modified) {\n    if (image.width > availableWidth) {\n      image.width = availableWidth;\n    }\n    if (image.width < 1) {\n      image.width = 1;\n    }\n  }\n  return width !== image.width;\n};\n\nexport const changeCropWidth = wrapWithFireEvent(\n  'CROPPING' as TModificationEvents,\n  wrapWithFixedAnchor(changeImageWidth),\n);\n\n/**\n * Wrap controlsUtils.changeObjectHeight with image constrains\n */\nexport const changeImageHeight: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  const { target } = transform;\n  const { height } = target;\n  const image = target as FabricImage;\n  const modified = controlsUtils.changeObjectHeight(eventData, transform, x, y);\n  const availableHeight = image._element.height - image.cropY;\n  if (modified) {\n    if (image.height > availableHeight) {\n      image.height = availableHeight;\n    }\n    if (image.height < 1) {\n      image.height = 1;\n    }\n  }\n  return height !== image.height;\n};\n\nexport const changeCropHeight = wrapWithFireEvent(\n  'CROPPING' as TModificationEvents,\n  wrapWithFixedAnchor(changeImageHeight),\n);\n\nexport const changeImageCropX: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  const { target } = transform;\n  const image = target as FabricImage;\n  const { width, cropX } = image;\n  const modified = controlsUtils.changeObjectWidth(eventData, transform, x, y);\n  let newCropX = cropX + width - image.width;\n  image.width = width;\n  if (modified) {\n    if (newCropX < 0) {\n      newCropX = 0;\n    }\n    image.cropX = newCropX;\n    // calculate new width on the base of how much crop we have now\n    image.width += cropX - newCropX;\n  }\n  return newCropX !== cropX;\n};\n\nexport const changeImageCropY: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  const { target } = transform;\n  const image = target as FabricImage;\n  const { height, cropY } = image;\n  const modified = controlsUtils.changeObjectHeight(eventData, transform, x, y);\n  let newCropY = cropY + height - image.height;\n  image.height = height;\n  if (modified) {\n    if (newCropY < 0) {\n      newCropY = 0;\n    }\n    image.cropY = newCropY;\n    image.height += cropY - newCropY;\n  }\n  return newCropY !== cropY;\n};\n\nexport const changeCropX = wrapWithFireEvent(\n  'CROPPING' as TModificationEvents,\n  wrapWithFixedAnchor(changeImageCropX),\n);\n\nexport const changeCropY = wrapWithFireEvent(\n  'CROPPING' as TModificationEvents,\n  wrapWithFixedAnchor(changeImageCropY),\n);\n\n/**\n * A function to counter the move action and change cropX/cropY of an image\n * Keep the image steady, but moves it inside its own cropping rectangle\n */\nexport const cropPanMoveHandler = ({ transform }: ObjectEvents['moving']) => {\n  // this makes the image pan too fast.\n  const { target, original } = transform as Transform;\n  const fabricImage = target as FabricImage;\n  const p = new Point(\n    target.left - original.left,\n    target.top - original.top,\n  ).transform(\n    util.invertTransform(\n      util.createRotateMatrix({ angle: fabricImage.getTotalAngle() }),\n    ),\n  );\n  let cropX = original.cropX! - p.x / fabricImage.scaleX;\n  let cropY = original.cropY! - p.y / fabricImage.scaleY;\n  const { width, height, _element } = fabricImage;\n  if (cropX < 0) {\n    cropX = 0;\n  }\n  if (cropY < 0) {\n    cropY = 0;\n  }\n  if (cropX + width > _element.width) {\n    cropX = _element.width - width;\n  }\n  if (cropY + height > _element.height) {\n    cropY = _element.height - height;\n  }\n  fabricImage.cropX = cropX;\n  fabricImage.cropY = cropY;\n  fabricImage.left = original.left;\n  fabricImage.top = original.top;\n};\n","import {\n  type ControlRenderingStyleOverride,\n  type InteractiveFabricObject,\n  util,\n  type Control,\n} from 'fabric';\n\nconst { degreesToRadians } = util;\n\n/**\n * Render a control for the main corners of a cropping image\n * This function is written to respect object properties like transparentCorners, cornerSize\n * cornerColor, cornerStrokeColor\n * plus the addition of offsetY and offsetX.\n * @param {CanvasRenderingContext2D} ctx context to render on\n * @param {Number} left x coordinate where the control center should be\n * @param {Number} top y coordinate where the control center should be\n * @param {Object} styleOverride override for FabricObject controls style\n * @param {FabricObject} fabricObject the fabric object for which we are rendering controls\n */\nexport function renderCornerControl(\n  this: Control,\n  ctx: CanvasRenderingContext2D,\n  left: number,\n  top: number,\n  styleOverride: ControlRenderingStyleOverride,\n  fabricObject: InteractiveFabricObject,\n) {\n  ctx.save();\n  const { stroke, xSize, ySize, opName } = this.commonRenderProps(\n      ctx,\n      left,\n      top,\n      fabricObject,\n      styleOverride,\n    ),\n    xSizeBy2 = xSize / 2,\n    ySizeBy2 = ySize / 2;\n  //  angle is relative to canvas plane\n  ctx.rotate(degreesToRadians(this.angle));\n  ctx.beginPath();\n  ctx.moveTo(-ySizeBy2, 0);\n  ctx.lineTo(-ySizeBy2, xSizeBy2);\n  ctx.lineTo(ySizeBy2, xSizeBy2);\n  ctx.lineTo(ySizeBy2, ySizeBy2);\n  ctx.lineTo(xSizeBy2, ySizeBy2);\n  ctx.lineTo(xSizeBy2, -ySizeBy2);\n  ctx.lineTo(-ySizeBy2, -ySizeBy2);\n  ctx.closePath();\n  ctx[opName]();\n  stroke && ctx.stroke();\n  ctx.restore();\n}\n","import { Control, controlsUtils } from 'fabric';\nimport {\n  changeCropHeight,\n  changeCropWidth,\n  changeCropX,\n  changeCropY,\n} from './croppingHandlers';\nimport { renderCornerControl } from './renderCornerControl';\n\nconst { scaleCursorStyleHandler } = controlsUtils;\n\nconst cropActionName = () => 'crop';\n// use this function if you want to generate new controls for every instance\nexport const createImageCroppingControls = () => ({\n  ml: new Control({\n    x: -0.5,\n    y: 0,\n    sizeX: 4,\n    sizeY: 20,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: changeCropX,\n    getActionName: cropActionName,\n  }),\n\n  mr: new Control({\n    x: 0.5,\n    y: 0,\n    sizeX: 4,\n    sizeY: 20,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: changeCropWidth,\n    getActionName: cropActionName,\n  }),\n\n  mb: new Control({\n    x: 0,\n    y: 0.5,\n    sizeX: 20,\n    sizeY: 4,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: changeCropHeight,\n    getActionName: cropActionName,\n  }),\n\n  mt: new Control({\n    x: 0,\n    y: -0.5,\n    sizeX: 20,\n    sizeY: 4,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: changeCropY,\n    getActionName: cropActionName,\n  }),\n\n  tl: new Control({\n    angle: 0,\n    x: -0.5,\n    y: -0.5,\n    sizeX: 20,\n    sizeY: 4,\n    render: renderCornerControl,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: (...args) => {\n      const cropX = changeCropX(...args);\n      const cropY = changeCropY(...args);\n      return cropX || cropY;\n    },\n    getActionName: cropActionName,\n  }),\n\n  tr: new Control({\n    angle: 90,\n    x: 0.5,\n    y: -0.5,\n    sizeX: 20,\n    sizeY: 4,\n    render: renderCornerControl,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: (...args) => {\n      const width = changeCropWidth(...args);\n      const cropY = changeCropY(...args);\n      return width || cropY;\n    },\n    getActionName: cropActionName,\n  }),\n\n  bl: new Control({\n    angle: 270,\n    x: -0.5,\n    y: 0.5,\n    sizeX: 20,\n    sizeY: 4,\n    render: renderCornerControl,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: (...args) => {\n      const height = changeCropHeight(...args);\n      const cropX = changeCropX(...args);\n      return height || cropX;\n    },\n    getActionName: cropActionName,\n  }),\n\n  br: new Control({\n    angle: 180,\n    x: 0.5,\n    y: 0.5,\n    sizeX: 20,\n    sizeY: 4,\n    render: renderCornerControl,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: (...args) => {\n      const height = changeCropHeight(...args);\n      const width = changeCropWidth(...args);\n      return height || width;\n    },\n    getActionName: cropActionName,\n  }),\n});\n","import {\n  type BasicTransformEvent,\n  type Canvas,\n  type FabricObject,\n  type TPointerEvent,\n  type Point,\n  util,\n} from 'fabric';\nimport {\n  collectHorizontalPoint,\n  collectVerticalPoint,\n} from './util/collect-point';\nimport {\n  drawHorizontalLine,\n  drawLine,\n  drawPointList,\n  drawVerticalLine,\n  drawX,\n} from './util/draw';\nimport { collectLine } from './util/collect-line';\nimport type { AligningLineConfig, OriginMap } from './typedefs';\nimport { getObjectsByTarget } from './util/get-objects-by-target';\nimport { getContraryMap, getPointMap } from './util/basic';\n\ntype TransformEvent = BasicTransformEvent<TPointerEvent> & {\n  target: FabricObject;\n};\n\nexport class AligningGuidelines {\n  canvas: Canvas;\n  horizontalLines = new Set<string>();\n  verticalLines = new Set<string>();\n  cacheMap = new Map<string, Point[]>();\n  /**\n   * When we drag to resize using center points like mt, ml, mb, and mr,\n   * we do not need to draw line segments; we only need to draw the target points.\n   */\n  onlyDrawPoint = false;\n  /** Alignment method is required when customizing. */\n  contraryOriginMap: OriginMap = {\n    tl: ['right', 'bottom'],\n    tr: ['left', 'bottom'],\n    br: ['left', 'top'],\n    bl: ['right', 'top'],\n    mt: ['center', 'bottom'],\n    mr: ['left', 'center'],\n    mb: ['center', 'top'],\n    ml: ['right', 'center'],\n  };\n  xSize = 2.4;\n  lineDash: number[] | undefined;\n  /** At what distance from the shape does alignment begin? */\n  margin = 4;\n  /** Aligning line dimensions */\n  width = 1;\n  /** Aligning line color */\n  color = 'rgba(255,0,0,0.9)';\n  /** Close Vertical line, default false. */\n  closeVLine = false;\n  /** Close horizontal line, default false. */\n  closeHLine = false;\n\n  constructor(canvas: Canvas, options: Partial<AligningLineConfig> = {}) {\n    this.canvas = canvas;\n    Object.assign(this, options);\n\n    this.mouseUp = this.mouseUp.bind(this);\n    this.scalingOrResizing = this.scalingOrResizing.bind(this);\n    this.moving = this.moving.bind(this);\n    this.beforeRender = this.beforeRender.bind(this);\n    this.afterRender = this.afterRender.bind(this);\n\n    this.initBehavior();\n  }\n  initBehavior() {\n    this.canvas.on('mouse:up', this.mouseUp);\n    this.canvas.on('object:resizing', this.scalingOrResizing);\n    this.canvas.on('object:scaling', this.scalingOrResizing);\n    this.canvas.on('object:moving', this.moving);\n    this.canvas.on('before:render', this.beforeRender);\n    this.canvas.on('after:render', this.afterRender);\n  }\n  /** Returns shapes that can draw aligning lines, default returns all shapes on the canvas excluding groups. */\n  getObjectsByTarget(target: FabricObject) {\n    return getObjectsByTarget(target);\n  }\n  /** When the user customizes the controller, this property is set to enable or disable automatic alignment through point scaling/resizing. */\n  getPointMap(target: FabricObject) {\n    return getPointMap(target);\n  }\n  /** When the user customizes the controller, this property is used to enable or disable alignment positioning through points. */\n  getContraryMap(target: FabricObject) {\n    return getContraryMap(target);\n  }\n  /** Users can customize. */\n  getCaCheMapValue(object: FabricObject) {\n    const cacheKey = [\n      object.calcTransformMatrix().toString(),\n      object.width,\n      object.height,\n    ].join();\n    const cacheValue = this.cacheMap.get(cacheKey);\n    if (cacheValue) return cacheValue;\n    const value = object.getCoords();\n    value.push(object.getCenterPoint());\n    this.cacheMap.set(cacheKey, value);\n    return value;\n  }\n  drawLine(origin: Point, target: Point) {\n    drawLine.call(this, origin, target);\n  }\n  drawX(point: Point, dir: number) {\n    drawX.call(this, point, dir);\n  }\n  mouseUp() {\n    this.verticalLines.clear();\n    this.horizontalLines.clear();\n    this.cacheMap.clear();\n    this.canvas.requestRenderAll();\n  }\n\n  scalingOrResizing(e: TransformEvent) {\n    const target = e.target;\n    // We need to obtain the real-time coordinates of the current object, so we need to update them in real-time\n    target.setCoords();\n    // The value of action can be scaleX, scaleY, scale, resize, etc.\n    // If it does not start with \"scale,\" it is considered a modification of size.\n    const isScale = String(e.transform.action).startsWith('scale');\n    this.verticalLines.clear();\n    this.horizontalLines.clear();\n\n    const objects = this.getObjectsByTarget(target);\n    // When the shape is flipped, the tl obtained through getCoords is actually tr,\n    // and tl is actually tr. We need to make correction adjustments.\n    // tr <-> tl、 bl <-> br、  mb <-> mt、 ml <-> mr\n    let corner = e.transform.corner;\n    if (target.flipX) {\n      if (corner.includes('l')) corner = corner.replace('l', 'r');\n      else if (corner.includes('r')) corner = corner.replace('r', 'l');\n    }\n    if (target.flipY) {\n      if (corner.includes('t')) corner = corner.replace('t', 'b');\n      else if (corner.includes('b')) corner = corner.replace('b', 't');\n    }\n\n    // Obtain the coordinates of the current operation point through the value of corner.\n    // users can be allowed to customize and pass in custom corners.\n    const pointMap = this.getPointMap(target);\n    if (!(corner in pointMap)) return;\n    this.onlyDrawPoint = corner.includes('m');\n    if (this.onlyDrawPoint) {\n      const angle = target.getTotalAngle();\n      // When the shape is rotated, it is meaningless to draw points using the center point.\n      if (angle % 90 != 0) return;\n    }\n    // If manipulating tl, then when the shape changes size, it should be positioned by br,\n    // and the same applies to others.\n    // users can be allowed to customize and pass in custom corners.\n    const contraryMap = this.getContraryMap(target);\n    const point = pointMap[corner];\n    let diagonalPoint = contraryMap[corner];\n    // When holding the centerKey (default is altKey), the shape will scale based on the center point, with the reference point being the center.\n    const isCenter =\n      e.transform.original.originX == 'center' &&\n      e.transform.original.originY == 'center';\n    if (isCenter) {\n      const p = target.group\n        ? point.transform(\n            util.invertTransform(target.group.calcTransformMatrix()),\n          )\n        : point;\n      diagonalPoint = diagonalPoint.add(p).scalarDivide(2);\n    }\n    const uniformIsToggled = e.e[this.canvas.uniScaleKey!];\n    let isUniform =\n      (this.canvas.uniformScaling && !uniformIsToggled) ||\n      (!this.canvas.uniformScaling && uniformIsToggled);\n    // When controlling through the center point,\n    // if isUniform is true, it actually changes the skew, so it is meaningless.\n    if (this.onlyDrawPoint) isUniform = false;\n\n    const list: Point[] = [];\n    for (const object of objects) {\n      const d = this.getCaCheMapValue(object);\n      list.push(...d);\n    }\n\n    const props = {\n      target,\n      point,\n      diagonalPoint,\n      corner,\n      list,\n      isScale,\n      isUniform,\n      isCenter,\n    };\n\n    // Obtain horizontal and vertical reference lines.\n    const noNeedToCollectV =\n      this.onlyDrawPoint && (corner.includes('t') || corner.includes('b'));\n    const noNeedToCollectH =\n      this.onlyDrawPoint && (corner.includes('l') || corner.includes('r'));\n    const vList = noNeedToCollectV\n      ? []\n      : collectVerticalPoint.call(this, props);\n    const hList = noNeedToCollectH\n      ? []\n      : collectHorizontalPoint.call(this, props);\n    vList.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.verticalLines.add(JSON.stringify(o));\n    });\n    hList.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.horizontalLines.add(JSON.stringify(o));\n    });\n  }\n  moving(e: TransformEvent) {\n    const target = e.target;\n    // We need to obtain the real-time coordinates of the current object, so we need to update them in real-time\n    target.setCoords();\n    this.onlyDrawPoint = false;\n    this.verticalLines.clear();\n    this.horizontalLines.clear();\n\n    // Find the shapes associated with the current graphic to draw reference lines for it.\n    const objects = this.getObjectsByTarget(target);\n    const points: Point[] = [];\n    // Collect all the points to draw reference lines.\n    for (const object of objects) points.push(...this.getCaCheMapValue(object));\n\n    // Obtain horizontal and vertical reference lines.\n    const { vLines, hLines } = collectLine.call(this, target, points);\n    vLines.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.verticalLines.add(JSON.stringify(o));\n    });\n    hLines.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.horizontalLines.add(JSON.stringify(o));\n    });\n  }\n  beforeRender() {\n    this.canvas.clearContext(this.canvas.contextTop);\n  }\n  afterRender() {\n    if (this.onlyDrawPoint) {\n      drawPointList.call(this);\n    } else {\n      drawVerticalLine.call(this);\n      drawHorizontalLine.call(this);\n    }\n  }\n\n  dispose() {\n    this.canvas.off('mouse:up', this.mouseUp);\n    this.canvas.off('object:resizing', this.scalingOrResizing);\n    this.canvas.off('object:scaling', this.scalingOrResizing);\n    this.canvas.off('object:moving', this.moving);\n    this.canvas.off('before:render', this.beforeRender);\n    this.canvas.off('after:render', this.afterRender);\n  }\n}\n","import { type FabricImage, type TPointerEventInfo } from 'fabric';\nimport { createImageCroppingControls } from './croppingControls';\nimport { cropPanMoveHandler } from './croppingHandlers';\n/**\n * Coordinates the change to image to enter crop mode and returns\n * a function to exit crop mode\n */\nexport const enterCropMode = function enterCropMode(\n  this: (args: TPointerEventInfo) => void,\n  { target }: TPointerEventInfo,\n) {\n  const fabricImage = target as FabricImage;\n  const { controls } = fabricImage;\n  fabricImage.controls = createImageCroppingControls();\n  fabricImage.on('moving', cropPanMoveHandler);\n  fabricImage.setCoords();\n  const exitCropMode = () => {\n    fabricImage.off('moving', cropPanMoveHandler);\n    fabricImage.controls = controls;\n    fabricImage.setCoords();\n    fabricImage.once('mousedblclick', enterCropMode);\n    fabricImage.canvas?.requestRenderAll();\n  };\n  fabricImage.once('mousedblclick', exitCropMode);\n  fabricImage.canvas?.requestRenderAll();\n};\n"],"names":["getDistance","a","b","Math","abs","getDistanceList","point","list","type","dis","Infinity","arr","item","v","push","collectVerticalPoint","props","target","isScale","isUniform","corner","diagonalPoint","isCenter","this","margin","canvas","getZoom","length","x","includes","width","height","scaleX","scaleY","scaleWidth","strokeUniform","strokeWidth","sx","set","setRelativeXY","originArr","contraryOriginMap","setCoords","map","origin","collectHorizontalPoint","y","scaleHeight","sy","drawLine","ctx","getTopContext","viewportTransform","zoom","save","transform","lineWidth","lineDash","setLineDash","strokeStyle","color","beginPath","moveTo","lineTo","stroke","drawX","restore","_","size","xSize","translate","drawPoint","drawPointList","closeVLine","verticalLines","JSON","parse","closeHLine","h","horizontalLines","call","drawVerticalLine","o","Point","drawHorizontalLine","collectLine","points","getCoords","getCenterPoint","opts","vLines","collectPoints","hLines","res","min","i","d","forEach","setXY","getObjectsByTarget","objects","Set","children","ActiveSelection","getObjects","forEachObject","isOnScreen","visible","constructor","Group","add","collectObjectsByGroup","deleteObjectsByList","delete","g","child","originUpdaterWrapper","originalFn","defaultOriginX","arguments","undefined","defaultOriginY","async","serializedObject","originX","originY","_len","args","Array","_key","originalObject","actualPosition","left","top","setPositionByOrigin","gradientUpdaterWrapper","serializedGradient","colorStops","newColorStops","_ref","opacity","offset","Color","setAlpha","toRgba","wrapWithFixedAnchor","wrapWithFireEvent","controlsUtils","changeCropWidth","changeImageWidth","eventData","image","modified","changeObjectWidth","availableWidth","_element","cropX","changeCropHeight","changeImageHeight","changeObjectHeight","availableHeight","cropY","changeCropX","changeImageCropX","newCropX","changeCropY","changeImageCropY","newCropY","cropPanMoveHandler","original","fabricImage","p","util","invertTransform","createRotateMatrix","angle","getTotalAngle","degreesToRadians","renderCornerControl","styleOverride","fabricObject","ySize","opName","commonRenderProps","xSizeBy2","ySizeBy2","rotate","closePath","scaleCursorStyleHandler","cropActionName","createImageCroppingControls","ml","Control","sizeX","sizeY","cursorStyleHandler","actionHandler","getActionName","mr","mb","mt","tl","render","tr","bl","br","options","_defineProperty","Map","Object","assign","mouseUp","bind","scalingOrResizing","moving","beforeRender","afterRender","initBehavior","on","getPointMap","coords","scalarDivide","getContraryMap","_target$aCoords","aCoords","calcACoords","getCaCheMapValue","object","cacheKey","calcTransformMatrix","toString","join","cacheValue","cacheMap","get","value","dir","clear","requestRenderAll","e","String","action","startsWith","flipX","replace","flipY","pointMap","onlyDrawPoint","contraryMap","group","uniformIsToggled","uniScaleKey","uniformScaling","noNeedToCollectV","noNeedToCollectH","vList","hList","stringify","clearContext","contextTop","dispose","off","canvasRegion","wes","Region","upperCanvasEl","addOrRemove","el","removeEventListener","addGesture","Rotate","_ref6","rotation","event","fireEventFromPointerEvent","rotateGesture","Pinch","_ref5","scale","pinchGesture","Tap","_ref3","preventDefault","numTaps","maxRetain","tripleTapGesture","_ref4","doubleTapGesture","_len2","_key2","addEventListener","enterCropMode","_fabricImage$canvas2","controls","once","exitCropMode","_fabricImage$canvas","installGradientUpdater","Gradient","fromObject","installOriginWrapperUpdater","BaseFabricObject","_fromObject","FabricImage","scenePoint","getActiveObject","zoomToPoint","_ref2","radiansToDegrees"],"mappings":"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"}