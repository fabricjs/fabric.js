{"version":3,"file":"fabric-extensions.min.js","sources":["../extensions/aligning_guidelines/util/basic.ts","../extensions/aligning_guidelines/util/collect-point.ts","../extensions/aligning_guidelines/util/draw.ts","../extensions/aligning_guidelines/util/collect-line.ts","../extensions/aligning_guidelines/util/get-objects-by-target.ts","../extensions/data_updaters/origins/index.ts","../extensions/data_updaters/gradient/index.ts","../extensions/westures_integration/index.ts","../extensions/cropping_controls/croppingHandlers.ts","../extensions/cropping_controls/renderCornerControl.ts","../extensions/cropping_controls/croppingControls.ts","../extensions/aligning_guidelines/index.ts","../extensions/cropping_controls/enterCropMode.ts"],"sourcesContent":["import type { FabricObject, Point } from 'fabric';\nimport type { PointMap } from '../typedefs';\n\nexport function getDistance(a: number, b: number) {\n  return Math.abs(a - b);\n}\n\nexport function getDistanceList(point: Point, list: Point[], type: 'x' | 'y') {\n  let dis = Infinity;\n  let arr: Point[] = [];\n  for (const item of list) {\n    const v = getDistance(point[type], item[type]);\n    if (dis > v) {\n      arr = [];\n      dis = v;\n    }\n    if (dis == v) {\n      arr.push(item);\n    }\n  }\n  return { dis, arr };\n}\n\nexport function getPointMap(target: FabricObject): PointMap {\n  const coords = target.getCoords();\n  return {\n    tl: coords[0],\n    tr: coords[1],\n    br: coords[2],\n    bl: coords[3],\n    mt: coords[0].add(coords[1]).scalarDivide(2),\n    mr: coords[1].add(coords[2]).scalarDivide(2),\n    mb: coords[2].add(coords[3]).scalarDivide(2),\n    ml: coords[3].add(coords[0]).scalarDivide(2),\n  };\n}\n\nexport function getContraryMap(target: FabricObject): PointMap {\n  const aCoords = target.aCoords ?? target.calcACoords();\n  return {\n    tl: aCoords.br,\n    tr: aCoords.bl,\n    br: aCoords.tl,\n    bl: aCoords.tr,\n    mt: aCoords.br.add(aCoords.bl).scalarDivide(2),\n    mr: aCoords.bl.add(aCoords.tl).scalarDivide(2),\n    mb: aCoords.tl.add(aCoords.tr).scalarDivide(2),\n    ml: aCoords.tr.add(aCoords.br).scalarDivide(2),\n  };\n}\n","import type { FabricObject, Point } from 'fabric';\nimport type { AligningGuidelines } from '..';\nimport type { LineProps } from '../typedefs';\nimport { getDistanceList } from './basic';\n\ntype CollectPointProps = {\n  target: FabricObject;\n  /** Operation points of the target element: top-left, bottom-left, top-right, bottom-right */\n  point: Point;\n  /** Position using diagonal points when resizing/scaling. */\n  diagonalPoint: Point;\n  /** Set of points to consider for alignment: [tl, tr, br, bl, center] */\n  list: Point[];\n  /** Change the zoom or change the size, determine by whether e.transform.action starts with the string \"scale\" */\n  isScale: boolean;\n  /** Whether to change uniformly is determined by canvas.uniformScaling and canvas.uniScaleKey. */\n  isUniform: boolean;\n  /** When holding the centerKey (default is altKey), the shape will scale based on the center point, with the reference point being the center. */\n  isCenter: boolean;\n  /** tl、tr、br、bl、mt、mr、mb、ml */\n  corner: string;\n};\n\nexport function collectVerticalPoint(\n  this: AligningGuidelines,\n  props: CollectPointProps,\n): LineProps[] {\n  const {\n    target,\n    isScale,\n    isUniform,\n    corner,\n    point,\n    diagonalPoint,\n    list,\n    isCenter,\n  } = props;\n  const { dis, arr } = getDistanceList(point, list, 'x');\n  const margin = this.margin / this.canvas.getZoom();\n  if (dis > margin) return [];\n  let v = arr[arr.length - 1].x - point.x;\n  // tl bl ml\n  // If modifying on the left side, the size decreases; conversely, it increases.\n  const dirX = corner.includes('l') ? -1 : 1;\n  v *= dirX;\n\n  const { width, height, scaleX, scaleY } = target;\n  // Because when modifying through the center point, isUniform is always false, so skew does not need to be considered.\n  const dStrokeWidth = target.strokeUniform ? 0 : target.strokeWidth;\n  const scaleWidth = scaleX * width + dStrokeWidth;\n  const sx = (v + scaleWidth) / scaleWidth;\n  // When v equals -scaleWidth, sx equals 0.\n  if (sx == 0) return [];\n  if (isScale) {\n    target.set('scaleX', scaleX * sx);\n    if (isUniform) target.set('scaleY', scaleY * sx);\n  } else {\n    target.set('width', width * sx);\n    if (isUniform) target.set('height', height * sx);\n  }\n  if (isCenter) {\n    target.setRelativeXY(diagonalPoint, 'center', 'center');\n  } else {\n    const originArr = this.contraryOriginMap;\n    target.setRelativeXY(diagonalPoint, ...originArr[corner]);\n  }\n  target.setCoords();\n  return arr.map((target) => ({ origin: point, target }));\n}\n\nexport function collectHorizontalPoint(\n  this: AligningGuidelines,\n  props: CollectPointProps,\n): LineProps[] {\n  const {\n    target,\n    isScale,\n    isUniform,\n    corner,\n    point,\n    diagonalPoint,\n    list,\n    isCenter,\n  } = props;\n  const { dis, arr } = getDistanceList(point, list, 'y');\n  const margin = this.margin / this.canvas.getZoom();\n  if (dis > margin) return [];\n  let v = arr[arr.length - 1].y - point.y;\n  // tl mt tr\n  // If modifying on the top side, the size decreases; conversely, it increases.\n  const dirY = corner.includes('t') ? -1 : 1;\n  v *= dirY;\n\n  const { width, height, scaleX, scaleY } = target;\n  // Because when modifying through the center point, isUniform is always false, so skew does not need to be considered.\n  const dStrokeWidth = target.strokeUniform ? 0 : target.strokeWidth;\n  const scaleHeight = scaleY * height + dStrokeWidth;\n  const sy = (v + scaleHeight) / scaleHeight;\n  // When v equals -scaleHeight, sy equals 0.\n  if (sy == 0) return [];\n  if (isScale) {\n    target.set('scaleY', scaleY * sy);\n    if (isUniform) target.set('scaleX', scaleX * sy);\n  } else {\n    target.set('height', height * sy);\n    if (isUniform) target.set('width', width * sy);\n  }\n  if (isCenter) {\n    target.setRelativeXY(diagonalPoint, 'center', 'center');\n  } else {\n    const originArr = this.contraryOriginMap;\n    target.setRelativeXY(diagonalPoint, ...originArr[corner]);\n  }\n  target.setCoords();\n  return arr.map((target) => ({ origin: point, target }));\n}\n","import { Point } from 'fabric';\nimport type { AligningGuidelines } from '..';\n\nexport function drawLine(\n  this: AligningGuidelines,\n  origin: Point,\n  target: Point,\n) {\n  const ctx = this.canvas.getTopContext();\n  const viewportTransform = this.canvas.viewportTransform;\n  const zoom = this.canvas.getZoom();\n  ctx.save();\n  ctx.transform(...viewportTransform);\n  ctx.lineWidth = this.width / zoom;\n  if (this.lineDash) ctx.setLineDash(this.lineDash);\n  ctx.strokeStyle = this.color;\n  ctx.beginPath();\n  ctx.moveTo(origin.x, origin.y);\n  ctx.lineTo(target.x, target.y);\n  ctx.stroke();\n  if (this.lineDash) ctx.setLineDash([]);\n\n  this.drawX(origin, -1);\n  this.drawX(target, 1);\n  ctx.restore();\n}\n\nexport function drawX(this: AligningGuidelines, point: Point, _: number) {\n  const ctx = this.canvas.getTopContext();\n  const zoom = this.canvas.getZoom();\n  const size = this.xSize / zoom;\n  ctx.save();\n  ctx.translate(point.x, point.y);\n  ctx.beginPath();\n  ctx.moveTo(-size, -size);\n  ctx.lineTo(size, size);\n  ctx.moveTo(size, -size);\n  ctx.lineTo(-size, size);\n  ctx.stroke();\n  ctx.restore();\n}\nfunction drawPoint(this: AligningGuidelines, arr: Point[]) {\n  const ctx = this.canvas.getTopContext();\n  const viewportTransform = this.canvas.viewportTransform;\n  const zoom = this.canvas.getZoom();\n  ctx.save();\n  ctx.transform(...viewportTransform);\n  ctx.lineWidth = this.width / zoom;\n  ctx.strokeStyle = this.color;\n  for (const item of arr) this.drawX(item, 0);\n  ctx.restore();\n}\n\nexport function drawPointList(this: AligningGuidelines) {\n  const list = [];\n  if (!this.closeVLine) {\n    for (const v of this.verticalLines) list.push(JSON.parse(v));\n  }\n  if (!this.closeHLine) {\n    for (const h of this.horizontalLines) list.push(JSON.parse(h));\n  }\n  const arr = list.map((item) => item.target);\n  drawPoint.call(this, arr);\n}\n\nexport function drawVerticalLine(this: AligningGuidelines) {\n  if (this.closeVLine) return;\n\n  for (const v of this.verticalLines) {\n    const { origin, target } = JSON.parse(v);\n    const o = new Point(target.x, origin.y);\n    this.drawLine(o, target);\n  }\n}\n\nexport function drawHorizontalLine(this: AligningGuidelines) {\n  if (this.closeHLine) return;\n\n  for (const v of this.horizontalLines) {\n    const { origin, target } = JSON.parse(v);\n    const o = new Point(origin.x, target.y);\n    this.drawLine(o, target);\n  }\n}\n","import type { FabricObject, Point, TOriginX, TOriginY } from 'fabric';\nimport type { AligningGuidelines } from '..';\nimport type { LineProps } from '../typedefs';\nimport { getDistanceList } from './basic';\n\nexport function collectLine(\n  this: AligningGuidelines,\n  target: FabricObject,\n  points: Point[],\n) {\n  const list = target.getCoords();\n  list.push(target.getCenterPoint());\n  const margin = this.margin / this.canvas.getZoom();\n  const opts = { target, list, points, margin };\n  const vLines = collectPoints({ ...opts, type: 'x' });\n  const hLines = collectPoints({ ...opts, type: 'y' });\n\n  return { vLines, hLines };\n}\n\ntype CollectItemLineProps = {\n  target: FabricObject;\n  list: Point[];\n  points: Point[];\n  margin: number;\n  type: 'x' | 'y';\n};\nconst originArr: [TOriginX, TOriginY][] = [\n  ['left', 'top'],\n  ['right', 'top'],\n  ['right', 'bottom'],\n  ['left', 'bottom'],\n  ['center', 'center'],\n];\nfunction collectPoints(props: CollectItemLineProps) {\n  const { target, list, points, margin, type } = props;\n  const res: LineProps[] = [];\n  const arr: ReturnType<typeof getDistanceList>[] = [];\n  let min = Infinity;\n  for (const item of list) {\n    const o = getDistanceList(item, points, type);\n    arr.push(o);\n    if (min > o.dis) min = o.dis;\n  }\n  if (min > margin) return res;\n  let b = false;\n  for (let i = 0; i < list.length; i++) {\n    if (arr[i].dis != min) continue;\n    for (const item of arr[i].arr) {\n      res.push({ origin: list[i], target: item });\n    }\n\n    if (b) continue;\n    b = true;\n    const d = arr[i].arr[0][type] - list[i][type];\n    // It will change the original data, and the next time we collect y, use the modified data.\n    list.forEach((item) => {\n      item[type] += d;\n    });\n    target.setXY(list[i], ...originArr[i]);\n    target.setCoords();\n  }\n\n  return res;\n}\n","import type { FabricObject } from 'fabric';\nimport { ActiveSelection, Group } from 'fabric';\n\nexport function getObjectsByTarget(target: FabricObject) {\n  const objects = new Set<FabricObject>();\n  const canvas = target.canvas;\n  if (!canvas) return objects;\n  const children =\n    target instanceof ActiveSelection ? target.getObjects() : [target];\n\n  canvas.forEachObject((o) => {\n    if (!o.isOnScreen()) return;\n    if (!o.visible) return;\n    if (o.constructor == Group) {\n      collectObjectsByGroup(objects, o);\n      return;\n    }\n    objects.add(o);\n  });\n\n  deleteObjectsByList(objects, children);\n  return objects;\n}\n\nfunction deleteObjectsByList(objects: Set<FabricObject>, list: FabricObject[]) {\n  for (const target of list) {\n    if (target.constructor == Group) {\n      deleteObjectsByList(objects, (target as Group).getObjects());\n    } else {\n      objects.delete(target);\n    }\n  }\n}\n\nfunction collectObjectsByGroup(objects: Set<FabricObject>, g: Group) {\n  const children = g.getObjects();\n  for (const child of children) {\n    if (!child.visible) continue;\n    if (child.constructor == Group) {\n      collectObjectsByGroup(objects, child);\n      continue;\n    }\n    objects.add(child);\n  }\n}\n","import {\n  Point,\n  FabricImage,\n  Group,\n  BaseFabricObject,\n  type FabricObject,\n  type TOriginX,\n  type TOriginY,\n} from 'fabric';\n\n/**\n * Updates the fromObject function of a class to return a version that can restore old data\n * with values of originX and originY that are different from 'center', 'center'\n * Used to upgrade from fabric 6 to fabric 7\n * @param originalFn the original fromObject function of an object,\n * @param defaultOriginX optional default value for non exported originX,\n * @param defaultOriginY optional default value for non exported originY,\n * @returns a wrapped fromObject function for the object\n */\nexport const originUpdaterWrapper = <T extends FabricObject = FabricObject>(\n  originalFn: (...args: any[]) => Promise<T>,\n  defaultOriginX: TOriginX = 'left',\n  defaultOriginY: TOriginY = 'top',\n): ((...args: any[]) => Promise<T>) =>\n  async function (this: T, serializedObject, ...args) {\n    // we default to left and top because those are defaults before deprecation\n    const { originX = defaultOriginX, originY = defaultOriginY } =\n      serializedObject;\n    // and we do not want to pass those properties on the object anymore\n    delete serializedObject.originX;\n    delete serializedObject.originY;\n    const originalObject = await originalFn.call(\n      this,\n      serializedObject,\n      ...args,\n    );\n    const actualPosition = new Point(originalObject.left, originalObject.top);\n    originalObject.setPositionByOrigin(actualPosition, originX, originY);\n    return originalObject;\n  };\n\n/**\n * Wraps and override the current fabricJS fromObject static functions\n * Used to upgrade from fabric 7 to fabric 8\n * If you used to export with includeDefaultValues = false, you have to specify\n * which were yours default origins values\n * @param originX optional default value for non exported originX,\n * @param originY optional default value for non exported originY,\n */\nexport const installOriginWrapperUpdater = (\n  originX?: TOriginX,\n  originY?: TOriginY,\n) => {\n  // @ts-expect-error the _fromObject parameter could be instantiated differently\n  BaseFabricObject._fromObject = originUpdaterWrapper(\n    BaseFabricObject._fromObject,\n    originX,\n    originY,\n  );\n  // FabricImage and Group do not use _fromObject\n  FabricImage.fromObject = originUpdaterWrapper<FabricImage>(\n    FabricImage.fromObject,\n    originX,\n    originY,\n  );\n  Group.fromObject = originUpdaterWrapper<Group>(\n    Group.fromObject,\n    originX,\n    originY,\n  );\n};\n","import type { GradientOptions, ColorStop } from 'fabric';\nimport { Color, Gradient } from 'fabric';\n\n/**\n * Updates the fromObject function of a Gradient to return a version that can restore old data\n * with opactiy in color Stops\n * Used to upgrade from fabric 6 to fabric 7\n * @param originalFn the original fromObject function of an object,\n * @returns a wrapped fromObject function for the object\n */\n\ntype OldColorStop = ColorStop & {\n  opacity?: number;\n};\n\nexport const gradientUpdaterWrapper = <S, T extends Gradient<S> = Gradient<S>>(\n  originalFn: (\n    options: GradientOptions<'linear'> | GradientOptions<'radial'>,\n  ) => Promise<T>,\n): ((\n  options: GradientOptions<'linear'> | GradientOptions<'radial'>,\n) => Promise<T>) =>\n  async function (this: T, serializedGradient) {\n    // we default to left and top because those are defaults before deprecation\n    const { colorStops } = serializedGradient;\n    // and we do not want to pass those properties on the object anymore\n    const newColorStops: ColorStop[] = (\n      colorStops as OldColorStop[]\n    )?.map<ColorStop>(({ color, opacity, offset }) => {\n      if (opacity === undefined || opacity === 1) {\n        return {\n          color,\n          offset,\n        };\n      }\n      const col = new Color(color).setAlpha(opacity).toRgba();\n      return {\n        color: col,\n        offset,\n      };\n    });\n    const gradient = await originalFn.call(this, {\n      ...serializedGradient,\n      colorStops: newColorStops,\n    });\n    return gradient;\n  };\n\n/**\n * Wraps and override the current fabricJS fromObject static functions\n * Used to upgrade from fabric 7 to fabric 8\n * If you used to export with includeDefaultValues = false, you have to specify\n * which were yours default origins values\n */\nexport const installGradientUpdater = () => {\n  // @ts-expect-error untypable\n  Gradient.fromObject = gradientUpdaterWrapper(Gradient.fromObject);\n};\n","import wes from 'westures';\nimport { type Canvas, type CanvasEvents, type XY, util } from 'fabric';\n\ntype PinchEventData = {\n  centroid: XY;\n  event: PointerEvent;\n  phase: string;\n  type: 'pinch';\n  scale: number;\n  target: HTMLElement;\n};\n\ntype RotateEventData = {\n  centroid: XY;\n  event: PointerEvent;\n  phase: string;\n  type: 'rotate';\n  rotation: number;\n  target: HTMLElement;\n};\n\ntype TapEventData = {\n  centroid: XY;\n  event: PointerEvent;\n  phase: string;\n  type: 'tap';\n  target: HTMLElement;\n};\n\n/**\n * Register this handler on canvas.on('pinch', pinchEventHandler);\n * To get an out of the box functionality for the pinch to zoom\n */\nexport function pinchEventHandler(\n  this: Canvas,\n  { scale, target, scenePoint }: CanvasEvents['pinch'],\n) {\n  if (target && this.getActiveObject() === target) {\n    // if we are pinching on the active object, let's scale it\n    target.scaleX *= scale;\n    target.scaleY *= scale;\n  } else {\n    this.zoomToPoint(scenePoint, this.getZoom() * scale);\n  }\n}\n\nexport function rotateEventHandler(\n  this: Canvas,\n  { rotation, target }: CanvasEvents['rotate'],\n) {\n  if (target && this.getActiveObject() === target) {\n    target.rotate(target.angle + util.radiansToDegrees(rotation));\n  }\n}\n\nexport const tripleTapGesture = (canvas: Canvas) => {\n  return new wes.Tap(\n    canvas.upperCanvasEl,\n    ({ event }: TapEventData) => {\n      canvas.fireEventFromPointerEvent(\n        event,\n        'mouse:tripleclick',\n        'mousetripleclick',\n        undefined,\n      );\n      event.preventDefault();\n    },\n    {\n      numTaps: 3,\n      maxRetain: 400,\n    },\n  );\n};\n\nexport const doubleTapGesture = (canvas: Canvas) => {\n  return new wes.Tap(\n    canvas.upperCanvasEl,\n    ({ event }: TapEventData) => {\n      canvas.fireEventFromPointerEvent(\n        event,\n        'mouse:dblclick',\n        'mousedblclick',\n        undefined,\n      );\n      event.preventDefault();\n    },\n    {\n      numTaps: 2,\n      maxRetain: 300,\n    },\n  );\n};\n\nexport const pinchGesture = (canvas: Canvas) => {\n  return new wes.Pinch(\n    canvas.upperCanvasEl,\n    ({ scale, event }: PinchEventData) => {\n      canvas.fireEventFromPointerEvent(event, 'pinch', 'pinch', { scale });\n    },\n  );\n};\n\nexport const rotateGesture = (canvas: Canvas) => {\n  return new wes.Rotate(\n    canvas.upperCanvasEl,\n    ({ rotation, event }: RotateEventData) => {\n      canvas.fireEventFromPointerEvent(event, 'rotate', 'rotate', { rotation });\n    },\n  );\n};\n\n/**\n * Add a serie of gestures recognition on the canvas\n */\nexport const addGestures = (canvas: Canvas) => {\n  const canvasRegion = new wes.Region(canvas.upperCanvasEl);\n  canvas.addOrRemove(\n    (\n      el: HTMLElement,\n      ...args: Parameters<HTMLElement['removeEventListener']>\n    ) => el.removeEventListener(...args),\n  );\n  canvasRegion.addGesture(rotateGesture(canvas));\n  canvasRegion.addGesture(pinchGesture(canvas));\n  canvasRegion.addGesture(tripleTapGesture(canvas));\n  canvasRegion.addGesture(doubleTapGesture(canvas));\n  // add back events, excluding the click one\n  canvas.addOrRemove(\n    (el: HTMLElement, ...args: Parameters<HTMLElement['addEventListener']>) =>\n      el.addEventListener(...args),\n    true,\n  );\n};\n","import type {\n  TModificationEvents,\n  Transform,\n  TransformActionHandler,\n  FabricImage,\n  ObjectEvents,\n  Control,\n  TMat2D,\n} from 'fabric';\nimport { controlsUtils, Point, util } from 'fabric';\n\nconst { wrapWithFixedAnchor, wrapWithFireEvent } = controlsUtils;\n\n/**\n * Wrap controlsUtils.changeObjectWidth with image constrains\n */\nexport const changeImageWidth: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  const { target } = transform;\n  const { width } = target;\n  const image = target as FabricImage;\n  const modified = controlsUtils.changeObjectWidth(eventData, transform, x, y);\n  const availableWidth = image._element.width - image.cropX;\n  if (modified) {\n    if (image.width > availableWidth) {\n      image.width = availableWidth;\n    }\n    if (image.width < 1) {\n      image.width = 1;\n    }\n  }\n  return width !== image.width;\n};\n\nexport const changeCropWidth = wrapWithFireEvent(\n  'CROPPING' as TModificationEvents,\n  wrapWithFixedAnchor(changeImageWidth),\n);\n\n/**\n * Wrap controlsUtils.changeObjectHeight with image constrains\n */\nexport const changeImageHeight: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  const { target } = transform;\n  const { height } = target;\n  const image = target as FabricImage;\n  const modified = controlsUtils.changeObjectHeight(eventData, transform, x, y);\n  const availableHeight = image._element.height - image.cropY;\n  if (modified) {\n    if (image.height > availableHeight) {\n      image.height = availableHeight;\n    }\n    if (image.height < 1) {\n      image.height = 1;\n    }\n  }\n  return height !== image.height;\n};\n\nexport const changeCropHeight = wrapWithFireEvent(\n  'CROPPING' as TModificationEvents,\n  wrapWithFixedAnchor(changeImageHeight),\n);\n\nexport const changeImageCropX: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  const { target } = transform;\n  const image = target as FabricImage;\n  const { width, cropX } = image;\n  const modified = controlsUtils.changeObjectWidth(eventData, transform, x, y);\n  let newCropX = cropX + width - image.width;\n  image.width = width;\n  if (modified) {\n    if (newCropX < 0) {\n      newCropX = 0;\n    }\n    image.cropX = newCropX;\n    // calculate new width on the base of how much crop we have now\n    image.width += cropX - newCropX;\n  }\n  return newCropX !== cropX;\n};\n\nexport const changeImageCropY: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  const { target } = transform;\n  const image = target as FabricImage;\n  const { height, cropY } = image;\n  const modified = controlsUtils.changeObjectHeight(eventData, transform, x, y);\n  let newCropY = cropY + height - image.height;\n  image.height = height;\n  if (modified) {\n    if (newCropY < 0) {\n      newCropY = 0;\n    }\n    image.cropY = newCropY;\n    image.height += cropY - newCropY;\n  }\n  return newCropY !== cropY;\n};\n\nexport const changeCropX = wrapWithFireEvent(\n  'CROPPING' as TModificationEvents,\n  wrapWithFixedAnchor(changeImageCropX),\n);\n\nexport const changeCropY = wrapWithFireEvent(\n  'CROPPING' as TModificationEvents,\n  wrapWithFixedAnchor(changeImageCropY),\n);\n\n/**\n * A function to counter the move action and change cropX/cropY of an image\n * Keep the image steady, but moves it inside its own cropping rectangle\n */\nexport const cropPanMoveHandler = ({ transform }: ObjectEvents['moving']) => {\n  // this makes the image pan too fast.\n  const { target, original } = transform as Transform;\n  const fabricImage = target as FabricImage;\n  const p = new Point(\n    target.left - original.left,\n    target.top - original.top,\n  ).transform(\n    util.invertTransform(\n      util.createRotateMatrix({ angle: fabricImage.getTotalAngle() }),\n    ),\n  );\n  let cropX = original.cropX! - p.x / fabricImage.scaleX;\n  let cropY = original.cropY! - p.y / fabricImage.scaleY;\n  const { width, height, _element } = fabricImage;\n  if (cropX < 0) {\n    cropX = 0;\n  }\n  if (cropY < 0) {\n    cropY = 0;\n  }\n  if (cropX + width > _element.width) {\n    cropX = _element.width - width;\n  }\n  if (cropY + height > _element.height) {\n    cropY = _element.height - height;\n  }\n  fabricImage.cropX = cropX;\n  fabricImage.cropY = cropY;\n  fabricImage.left = original.left;\n  fabricImage.top = original.top;\n};\n\n/**\n * This position handler works only for this specific use case.\n * It does not support padding nor offset, and it reduces all possible positions\n * to the main 4 corners only.\n * Any position that is < 0 is the extreme left/top, the rest are right/bottom\n */\nexport function ghostScalePositionHandler(\n  this: Control,\n  dim: Point, // currentDimension\n  finalMatrix: TMat2D,\n  fabricObject: FabricImage,\n  // currentControl: Control,\n) {\n  const matrix = fabricObject.calcTransformMatrix();\n  const vpt = fabricObject.getViewportTransform();\n  const _finalMatrix = util.multiplyTransformMatrices(vpt, matrix);\n\n  let x = 0;\n  let y = 0;\n  if (this.x < 0) {\n    x = -fabricObject.width / 2 - fabricObject.cropX;\n  } else {\n    x =\n      fabricObject.getElement().width -\n      fabricObject.width / 2 -\n      fabricObject.cropX;\n  }\n\n  if (this.y < 0) {\n    y = -fabricObject.height / 2 - fabricObject.cropY;\n  } else {\n    y =\n      fabricObject.getElement().height -\n      fabricObject.height / 2 -\n      fabricObject.cropY;\n  }\n  return new Point(x, y).transform(_finalMatrix);\n}\n\nconst calcScale = (currentPoint: Point, height: number, width: number) =>\n  Math.min(Math.abs(currentPoint.x / width), Math.abs(currentPoint.y / height));\n\n/**\n * Action handler generator that handles scaling of an image in crop mode.\n * The goal is to keep the current bounding box steady.\n * So this action handler has its own calculations for a dynamic anchor point\n */\nexport const scaleEquallyCropGenerator =\n  (cx: number, cy: number): TransformActionHandler =>\n  (eventData, transform, x, y) => {\n    const { target } = transform as unknown as { target: FabricImage };\n    const { width: fullWidth, height: fullHeight } = target.getElement();\n    const remainderX = fullWidth - target.width - target.cropX;\n    const remainderY = fullHeight - target.height - target.cropY;\n    const anchorOriginX =\n      cx < 0 ? 1 + remainderX / target.width : -target.cropX / target.width;\n    const anchorOriginY =\n      cy < 0 ? 1 + remainderY / target.height : -target.cropY / target.height;\n    const constraint = target.translateToOriginPoint(\n      target.getCenterPoint(),\n      anchorOriginX,\n      anchorOriginY,\n    );\n    const newPoint = controlsUtils.getLocalPoint(\n      transform,\n      anchorOriginX,\n      anchorOriginY,\n      x,\n      y,\n    );\n    const scale = calcScale(newPoint, fullHeight, fullWidth);\n    const scaleChangeX = scale / target.scaleX;\n    const scaleChangeY = scale / target.scaleY;\n    const scaledRemainderX = remainderX / scaleChangeX;\n    const scaledRemainderY = remainderY / scaleChangeY;\n    const newWidth = target.width / scaleChangeX;\n    const newHeight = target.height / scaleChangeY;\n    const newCropX =\n      cx < 0\n        ? fullWidth - newWidth - scaledRemainderX\n        : target.cropX / scaleChangeX;\n    const newCropY =\n      cy < 0\n        ? fullHeight - newHeight - scaledRemainderY\n        : target.cropY / scaleChangeY;\n\n    if (\n      (cx < 0 ? scaledRemainderX : newCropX) + newWidth > fullWidth ||\n      (cy < 0 ? scaledRemainderY : newCropY) + newHeight > fullHeight\n    ) {\n      return false;\n    }\n\n    target.scaleX = scale;\n    target.scaleY = scale;\n    target.width = newWidth;\n    target.height = newHeight;\n    target.cropX = newCropX;\n    target.cropY = newCropY;\n    const newAnchorOriginX =\n      cx < 0 ? 1 + scaledRemainderX / newWidth : -newCropX / newWidth;\n    const newAnchorOriginY =\n      cy < 0 ? 1 + scaledRemainderY / newHeight : -newCropY / newHeight;\n    target.setPositionByOrigin(constraint, newAnchorOriginX, newAnchorOriginY);\n    return true;\n  };\n","import {\n  type ControlRenderingStyleOverride,\n  type InteractiveFabricObject,\n  util,\n  type Control,\n} from 'fabric';\n\nconst { degreesToRadians } = util;\n\n/**\n * Render a control for the main corners of a cropping image\n * This function is written to respect object properties like transparentCorners, cornerSize\n * cornerColor, cornerStrokeColor\n * plus the addition of offsetY and offsetX.\n * @param {CanvasRenderingContext2D} ctx context to render on\n * @param {Number} left x coordinate where the control center should be\n * @param {Number} top y coordinate where the control center should be\n * @param {Object} styleOverride override for FabricObject controls style\n * @param {FabricObject} fabricObject the fabric object for which we are rendering controls\n */\nexport function renderCornerControl(\n  this: Control,\n  ctx: CanvasRenderingContext2D,\n  left: number,\n  top: number,\n  styleOverride: ControlRenderingStyleOverride,\n  fabricObject: InteractiveFabricObject,\n) {\n  ctx.save();\n  const { stroke, xSize, ySize, opName } = this.commonRenderProps(\n      ctx,\n      left,\n      top,\n      fabricObject,\n      styleOverride,\n    ),\n    xSizeBy2 = xSize / 2,\n    ySizeBy2 = ySize / 2;\n  //  angle is relative to canvas plane\n  ctx.rotate(degreesToRadians(this.angle));\n  ctx.beginPath();\n  ctx.moveTo(-ySizeBy2, 0);\n  ctx.lineTo(-ySizeBy2, xSizeBy2);\n  ctx.lineTo(ySizeBy2, xSizeBy2);\n  ctx.lineTo(ySizeBy2, ySizeBy2);\n  ctx.lineTo(xSizeBy2, ySizeBy2);\n  ctx.lineTo(xSizeBy2, -ySizeBy2);\n  ctx.lineTo(-ySizeBy2, -ySizeBy2);\n  ctx.closePath();\n  ctx[opName]();\n  stroke && ctx.stroke();\n  ctx.restore();\n}\n","import { Control, controlsUtils } from 'fabric';\nimport {\n  changeCropHeight,\n  changeCropWidth,\n  changeCropX,\n  changeCropY,\n  ghostScalePositionHandler,\n  scaleEquallyCropGenerator,\n} from './croppingHandlers';\nimport { renderCornerControl } from './renderCornerControl';\n\nconst { scaleCursorStyleHandler } = controlsUtils;\n\nconst cropActionName = () => 'crop';\n// use this function if you want to generate new controls for every instance\nexport const createImageCroppingControls = () => ({\n  // scaling image\n  tls: new Control({\n    x: -0.5,\n    y: -0.5,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    positionHandler: ghostScalePositionHandler,\n    actionHandler: scaleEquallyCropGenerator(-0.5, -0.5),\n  }),\n  brs: new Control({\n    x: 0.5,\n    y: 0.5,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    positionHandler: ghostScalePositionHandler,\n    actionHandler: scaleEquallyCropGenerator(0.5, 0.5),\n  }),\n  trs: new Control({\n    x: 0.5,\n    y: -0.5,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    positionHandler: ghostScalePositionHandler,\n    actionHandler: scaleEquallyCropGenerator(0.5, -0.5),\n  }),\n  bls: new Control({\n    x: -0.5,\n    y: 0.5,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    positionHandler: ghostScalePositionHandler,\n    actionHandler: scaleEquallyCropGenerator(-0.5, 0.5),\n  }),\n  // cropping image\n  mlc: new Control({\n    x: -0.5,\n    y: 0,\n    sizeX: 4,\n    sizeY: 20,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: changeCropX,\n    getActionName: cropActionName,\n  }),\n\n  mrc: new Control({\n    x: 0.5,\n    y: 0,\n    sizeX: 4,\n    sizeY: 20,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: changeCropWidth,\n    getActionName: cropActionName,\n  }),\n\n  mbc: new Control({\n    x: 0,\n    y: 0.5,\n    sizeX: 20,\n    sizeY: 4,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: changeCropHeight,\n    getActionName: cropActionName,\n  }),\n\n  mtc: new Control({\n    x: 0,\n    y: -0.5,\n    sizeX: 20,\n    sizeY: 4,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: changeCropY,\n    getActionName: cropActionName,\n  }),\n\n  tlc: new Control({\n    angle: 0,\n    x: -0.5,\n    y: -0.5,\n    sizeX: 20,\n    sizeY: 4,\n    render: renderCornerControl,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: (...args) => {\n      const cropX = changeCropX(...args);\n      const cropY = changeCropY(...args);\n      return cropX || cropY;\n    },\n    getActionName: cropActionName,\n  }),\n\n  trc: new Control({\n    angle: 90,\n    x: 0.5,\n    y: -0.5,\n    sizeX: 20,\n    sizeY: 4,\n    render: renderCornerControl,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: (...args) => {\n      const width = changeCropWidth(...args);\n      const cropY = changeCropY(...args);\n      return width || cropY;\n    },\n    getActionName: cropActionName,\n  }),\n\n  blc: new Control({\n    angle: 270,\n    x: -0.5,\n    y: 0.5,\n    sizeX: 20,\n    sizeY: 4,\n    render: renderCornerControl,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: (...args) => {\n      const height = changeCropHeight(...args);\n      const cropX = changeCropX(...args);\n      return height || cropX;\n    },\n    getActionName: cropActionName,\n  }),\n\n  brc: new Control({\n    angle: 180,\n    x: 0.5,\n    y: 0.5,\n    sizeX: 20,\n    sizeY: 4,\n    render: renderCornerControl,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: (...args) => {\n      const height = changeCropHeight(...args);\n      const width = changeCropWidth(...args);\n      return height || width;\n    },\n    getActionName: cropActionName,\n  }),\n});\n","import {\n  type BasicTransformEvent,\n  type Canvas,\n  type FabricObject,\n  type TPointerEvent,\n  type Point,\n  util,\n} from 'fabric';\nimport {\n  collectHorizontalPoint,\n  collectVerticalPoint,\n} from './util/collect-point';\nimport {\n  drawHorizontalLine,\n  drawLine,\n  drawPointList,\n  drawVerticalLine,\n  drawX,\n} from './util/draw';\nimport { collectLine } from './util/collect-line';\nimport type { AligningLineConfig, OriginMap } from './typedefs';\nimport { getObjectsByTarget } from './util/get-objects-by-target';\nimport { getContraryMap, getPointMap } from './util/basic';\n\ntype TransformEvent = BasicTransformEvent<TPointerEvent> & {\n  target: FabricObject;\n};\n\nexport class AligningGuidelines {\n  canvas: Canvas;\n  horizontalLines = new Set<string>();\n  verticalLines = new Set<string>();\n  cacheMap = new Map<string, Point[]>();\n  /**\n   * When we drag to resize using center points like mt, ml, mb, and mr,\n   * we do not need to draw line segments; we only need to draw the target points.\n   */\n  onlyDrawPoint = false;\n  /** Alignment method is required when customizing. */\n  contraryOriginMap: OriginMap = {\n    tl: ['right', 'bottom'],\n    tr: ['left', 'bottom'],\n    br: ['left', 'top'],\n    bl: ['right', 'top'],\n    mt: ['center', 'bottom'],\n    mr: ['left', 'center'],\n    mb: ['center', 'top'],\n    ml: ['right', 'center'],\n  };\n  xSize = 2.4;\n  lineDash: number[] | undefined;\n  /** At what distance from the shape does alignment begin? */\n  margin = 4;\n  /** Aligning line dimensions */\n  width = 1;\n  /** Aligning line color */\n  color = 'rgba(255,0,0,0.9)';\n  /** Close Vertical line, default false. */\n  closeVLine = false;\n  /** Close horizontal line, default false. */\n  closeHLine = false;\n\n  constructor(canvas: Canvas, options: Partial<AligningLineConfig> = {}) {\n    this.canvas = canvas;\n    Object.assign(this, options);\n\n    this.mouseUp = this.mouseUp.bind(this);\n    this.scalingOrResizing = this.scalingOrResizing.bind(this);\n    this.moving = this.moving.bind(this);\n    this.beforeRender = this.beforeRender.bind(this);\n    this.afterRender = this.afterRender.bind(this);\n\n    this.initBehavior();\n  }\n  initBehavior() {\n    this.canvas.on('mouse:up', this.mouseUp);\n    this.canvas.on('object:resizing', this.scalingOrResizing);\n    this.canvas.on('object:scaling', this.scalingOrResizing);\n    this.canvas.on('object:moving', this.moving);\n    this.canvas.on('before:render', this.beforeRender);\n    this.canvas.on('after:render', this.afterRender);\n  }\n  /** Returns shapes that can draw aligning lines, default returns all shapes on the canvas excluding groups. */\n  getObjectsByTarget(target: FabricObject) {\n    return getObjectsByTarget(target);\n  }\n  /** When the user customizes the controller, this property is set to enable or disable automatic alignment through point scaling/resizing. */\n  getPointMap(target: FabricObject) {\n    return getPointMap(target);\n  }\n  /** When the user customizes the controller, this property is used to enable or disable alignment positioning through points. */\n  getContraryMap(target: FabricObject) {\n    return getContraryMap(target);\n  }\n  /** Users can customize. */\n  getCaCheMapValue(object: FabricObject) {\n    const cacheKey = [\n      object.calcTransformMatrix().toString(),\n      object.width,\n      object.height,\n    ].join();\n    const cacheValue = this.cacheMap.get(cacheKey);\n    if (cacheValue) return cacheValue;\n    const value = object.getCoords();\n    value.push(object.getCenterPoint());\n    this.cacheMap.set(cacheKey, value);\n    return value;\n  }\n  drawLine(origin: Point, target: Point) {\n    drawLine.call(this, origin, target);\n  }\n  drawX(point: Point, dir: number) {\n    drawX.call(this, point, dir);\n  }\n  mouseUp() {\n    this.verticalLines.clear();\n    this.horizontalLines.clear();\n    this.cacheMap.clear();\n    this.canvas.requestRenderAll();\n  }\n\n  scalingOrResizing(e: TransformEvent) {\n    const target = e.target;\n    // We need to obtain the real-time coordinates of the current object, so we need to update them in real-time\n    target.setCoords();\n    // The value of action can be scaleX, scaleY, scale, resize, etc.\n    // If it does not start with \"scale,\" it is considered a modification of size.\n    const isScale = String(e.transform.action).startsWith('scale');\n    this.verticalLines.clear();\n    this.horizontalLines.clear();\n\n    const objects = this.getObjectsByTarget(target);\n    // When the shape is flipped, the tl obtained through getCoords is actually tr,\n    // and tl is actually tr. We need to make correction adjustments.\n    // tr <-> tl、 bl <-> br、  mb <-> mt、 ml <-> mr\n    let corner = e.transform.corner;\n    if (target.flipX) {\n      if (corner.includes('l')) corner = corner.replace('l', 'r');\n      else if (corner.includes('r')) corner = corner.replace('r', 'l');\n    }\n    if (target.flipY) {\n      if (corner.includes('t')) corner = corner.replace('t', 'b');\n      else if (corner.includes('b')) corner = corner.replace('b', 't');\n    }\n\n    // Obtain the coordinates of the current operation point through the value of corner.\n    // users can be allowed to customize and pass in custom corners.\n    const pointMap = this.getPointMap(target);\n    if (!(corner in pointMap)) return;\n    this.onlyDrawPoint = corner.includes('m');\n    if (this.onlyDrawPoint) {\n      const angle = target.getTotalAngle();\n      // When the shape is rotated, it is meaningless to draw points using the center point.\n      if (angle % 90 != 0) return;\n    }\n    // If manipulating tl, then when the shape changes size, it should be positioned by br,\n    // and the same applies to others.\n    // users can be allowed to customize and pass in custom corners.\n    const contraryMap = this.getContraryMap(target);\n    const point = pointMap[corner];\n    let diagonalPoint = contraryMap[corner];\n    // When holding the centerKey (default is altKey), the shape will scale based on the center point, with the reference point being the center.\n    const isCenter =\n      e.transform.original.originX == 'center' &&\n      e.transform.original.originY == 'center';\n    if (isCenter) {\n      const p = target.group\n        ? point.transform(\n            util.invertTransform(target.group.calcTransformMatrix()),\n          )\n        : point;\n      diagonalPoint = diagonalPoint.add(p).scalarDivide(2);\n    }\n    const uniformIsToggled = e.e[this.canvas.uniScaleKey!];\n    let isUniform =\n      (this.canvas.uniformScaling && !uniformIsToggled) ||\n      (!this.canvas.uniformScaling && uniformIsToggled);\n    // When controlling through the center point,\n    // if isUniform is true, it actually changes the skew, so it is meaningless.\n    if (this.onlyDrawPoint) isUniform = false;\n\n    const list: Point[] = [];\n    for (const object of objects) {\n      const d = this.getCaCheMapValue(object);\n      list.push(...d);\n    }\n\n    const props = {\n      target,\n      point,\n      diagonalPoint,\n      corner,\n      list,\n      isScale,\n      isUniform,\n      isCenter,\n    };\n\n    // Obtain horizontal and vertical reference lines.\n    const noNeedToCollectV =\n      this.onlyDrawPoint && (corner.includes('t') || corner.includes('b'));\n    const noNeedToCollectH =\n      this.onlyDrawPoint && (corner.includes('l') || corner.includes('r'));\n    const vList = noNeedToCollectV\n      ? []\n      : collectVerticalPoint.call(this, props);\n    const hList = noNeedToCollectH\n      ? []\n      : collectHorizontalPoint.call(this, props);\n    vList.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.verticalLines.add(JSON.stringify(o));\n    });\n    hList.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.horizontalLines.add(JSON.stringify(o));\n    });\n  }\n  moving(e: TransformEvent) {\n    const target = e.target;\n    // We need to obtain the real-time coordinates of the current object, so we need to update them in real-time\n    target.setCoords();\n    this.onlyDrawPoint = false;\n    this.verticalLines.clear();\n    this.horizontalLines.clear();\n\n    // Find the shapes associated with the current graphic to draw reference lines for it.\n    const objects = this.getObjectsByTarget(target);\n    const points: Point[] = [];\n    // Collect all the points to draw reference lines.\n    for (const object of objects) points.push(...this.getCaCheMapValue(object));\n\n    // Obtain horizontal and vertical reference lines.\n    const { vLines, hLines } = collectLine.call(this, target, points);\n    vLines.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.verticalLines.add(JSON.stringify(o));\n    });\n    hLines.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.horizontalLines.add(JSON.stringify(o));\n    });\n  }\n  beforeRender() {\n    this.canvas.clearContext(this.canvas.contextTop);\n  }\n  afterRender() {\n    if (this.onlyDrawPoint) {\n      drawPointList.call(this);\n    } else {\n      drawVerticalLine.call(this);\n      drawHorizontalLine.call(this);\n    }\n  }\n\n  dispose() {\n    this.canvas.off('mouse:up', this.mouseUp);\n    this.canvas.off('object:resizing', this.scalingOrResizing);\n    this.canvas.off('object:scaling', this.scalingOrResizing);\n    this.canvas.off('object:moving', this.moving);\n    this.canvas.off('before:render', this.beforeRender);\n    this.canvas.off('after:render', this.afterRender);\n  }\n}\n","import { type FabricImage, type TPointerEventInfo } from 'fabric';\nimport { createImageCroppingControls } from './croppingControls';\nimport { cropPanMoveHandler } from './croppingHandlers';\n/**\n * Coordinates the change to image to enter crop mode and returns\n * a function to exit crop mode\n */\nexport const enterCropMode = function enterCropMode(\n  this: (args: TPointerEventInfo) => void,\n  { target }: TPointerEventInfo,\n) {\n  const fabricImage = target as FabricImage;\n  const { controls, padding } = fabricImage;\n  fabricImage.padding = 0;\n  fabricImage.controls = createImageCroppingControls();\n  fabricImage.on('moving', cropPanMoveHandler);\n  fabricImage.setCoords();\n  const exitCropMode = () => {\n    fabricImage.padding = padding;\n    fabricImage.off('moving', cropPanMoveHandler);\n    fabricImage.controls = controls;\n    fabricImage.setCoords();\n    fabricImage.once('mousedblclick', enterCropMode);\n    fabricImage.canvas?.requestRenderAll();\n  };\n  fabricImage.once('mousedblclick', exitCropMode);\n  fabricImage.canvas?.requestRenderAll();\n};\n"],"names":["getDistance","a","b","Math","abs","getDistanceList","point","list","type","dis","Infinity","arr","item","v","push","collectVerticalPoint","props","target","isScale","isUniform","corner","diagonalPoint","isCenter","this","margin","canvas","getZoom","length","x","includes","width","height","scaleX","scaleY","scaleWidth","strokeUniform","strokeWidth","sx","set","setRelativeXY","originArr","contraryOriginMap","setCoords","map","origin","collectHorizontalPoint","y","scaleHeight","sy","drawLine","ctx","getTopContext","viewportTransform","zoom","save","transform","lineWidth","lineDash","setLineDash","strokeStyle","color","beginPath","moveTo","lineTo","stroke","drawX","restore","_","size","xSize","translate","drawPoint","drawPointList","closeVLine","verticalLines","JSON","parse","closeHLine","h","horizontalLines","call","drawVerticalLine","o","Point","drawHorizontalLine","collectLine","points","getCoords","getCenterPoint","opts","vLines","collectPoints","hLines","res","min","i","d","forEach","setXY","getObjectsByTarget","objects","Set","children","ActiveSelection","getObjects","forEachObject","isOnScreen","visible","constructor","Group","add","collectObjectsByGroup","deleteObjectsByList","delete","g","child","originUpdaterWrapper","originalFn","defaultOriginX","arguments","undefined","defaultOriginY","async","serializedObject","originX","originY","_len","args","Array","_key","originalObject","actualPosition","left","top","setPositionByOrigin","gradientUpdaterWrapper","serializedGradient","colorStops","newColorStops","_ref","opacity","offset","Color","setAlpha","toRgba","wrapWithFixedAnchor","wrapWithFireEvent","controlsUtils","changeCropWidth","changeImageWidth","eventData","image","modified","changeObjectWidth","availableWidth","_element","cropX","changeCropHeight","changeImageHeight","changeObjectHeight","availableHeight","cropY","changeCropX","changeImageCropX","newCropX","changeCropY","changeImageCropY","newCropY","cropPanMoveHandler","original","fabricImage","p","util","invertTransform","createRotateMatrix","angle","getTotalAngle","ghostScalePositionHandler","dim","finalMatrix","fabricObject","matrix","calcTransformMatrix","vpt","getViewportTransform","_finalMatrix","multiplyTransformMatrices","getElement","scaleEquallyCropGenerator","cx","cy","fullWidth","fullHeight","remainderX","remainderY","anchorOriginX","anchorOriginY","constraint","translateToOriginPoint","newPoint","getLocalPoint","scale","currentPoint","calcScale","scaleChangeX","scaleChangeY","scaledRemainderX","scaledRemainderY","newWidth","newHeight","newAnchorOriginX","newAnchorOriginY","degreesToRadians","renderCornerControl","styleOverride","ySize","opName","commonRenderProps","xSizeBy2","ySizeBy2","rotate","closePath","scaleCursorStyleHandler","cropActionName","createImageCroppingControls","tls","Control","cursorStyleHandler","positionHandler","actionHandler","brs","trs","bls","mlc","sizeX","sizeY","getActionName","mrc","mbc","mtc","tlc","render","trc","blc","brc","options","_defineProperty","Map","tl","tr","br","bl","mt","mr","mb","ml","Object","assign","mouseUp","bind","scalingOrResizing","moving","beforeRender","afterRender","initBehavior","on","getPointMap","coords","scalarDivide","getContraryMap","_target$aCoords","aCoords","calcACoords","getCaCheMapValue","object","cacheKey","toString","join","cacheValue","cacheMap","get","value","dir","clear","requestRenderAll","e","String","action","startsWith","flipX","replace","flipY","pointMap","onlyDrawPoint","contraryMap","group","uniformIsToggled","uniScaleKey","uniformScaling","noNeedToCollectV","noNeedToCollectH","vList","hList","stringify","clearContext","contextTop","dispose","off","canvasRegion","wes","Region","upperCanvasEl","addOrRemove","el","removeEventListener","addGesture","Rotate","_ref6","rotation","event","fireEventFromPointerEvent","rotateGesture","Pinch","_ref5","pinchGesture","Tap","_ref3","preventDefault","numTaps","maxRetain","tripleTapGesture","_ref4","doubleTapGesture","_len2","_key2","addEventListener","enterCropMode","_fabricImage$canvas2","controls","padding","once","exitCropMode","_fabricImage$canvas","installGradientUpdater","Gradient","fromObject","installOriginWrapperUpdater","BaseFabricObject","_fromObject","FabricImage","scenePoint","getActiveObject","zoomToPoint","_ref2","radiansToDegrees"],"mappings":"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"}