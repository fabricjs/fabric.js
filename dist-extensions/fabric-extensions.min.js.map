{"version":3,"file":"fabric-extensions.min.js","sources":["../extensions/aligning_guidelines/util/basic.ts","../extensions/aligning_guidelines/util/collect-point.ts","../extensions/aligning_guidelines/util/draw.ts","../extensions/aligning_guidelines/util/collect-line.ts","../extensions/aligning_guidelines/util/get-objects-by-target.ts","../extensions/data_updaters/origins/index.ts","../extensions/data_updaters/gradient/index.ts","../extensions/aligning_guidelines/index.ts","../extensions/westures_integration/index.ts"],"sourcesContent":["import type { FabricObject, Point } from 'fabric';\nimport type { PointMap } from '../typedefs';\n\nexport function getDistance(a: number, b: number) {\n  return Math.abs(a - b);\n}\n\nexport function getDistanceList(point: Point, list: Point[], type: 'x' | 'y') {\n  let dis = Infinity;\n  let arr: Point[] = [];\n  for (const item of list) {\n    const v = getDistance(point[type], item[type]);\n    if (dis > v) {\n      arr = [];\n      dis = v;\n    }\n    if (dis == v) {\n      arr.push(item);\n    }\n  }\n  return { dis, arr };\n}\n\nexport function getPointMap(target: FabricObject): PointMap {\n  const coords = target.getCoords();\n  return {\n    tl: coords[0],\n    tr: coords[1],\n    br: coords[2],\n    bl: coords[3],\n    mt: coords[0].add(coords[1]).scalarDivide(2),\n    mr: coords[1].add(coords[2]).scalarDivide(2),\n    mb: coords[2].add(coords[3]).scalarDivide(2),\n    ml: coords[3].add(coords[0]).scalarDivide(2),\n  };\n}\n\nexport function getContraryMap(target: FabricObject): PointMap {\n  const aCoords = target.aCoords ?? target.calcACoords();\n  return {\n    tl: aCoords.br,\n    tr: aCoords.bl,\n    br: aCoords.tl,\n    bl: aCoords.tr,\n    mt: aCoords.br.add(aCoords.bl).scalarDivide(2),\n    mr: aCoords.bl.add(aCoords.tl).scalarDivide(2),\n    mb: aCoords.tl.add(aCoords.tr).scalarDivide(2),\n    ml: aCoords.tr.add(aCoords.br).scalarDivide(2),\n  };\n}\n","import type { FabricObject, Point } from 'fabric';\nimport type { AligningGuidelines } from '..';\nimport type { LineProps } from '../typedefs';\nimport { getDistanceList } from './basic';\n\ntype CollectPointProps = {\n  target: FabricObject;\n  /** Operation points of the target element: top-left, bottom-left, top-right, bottom-right */\n  point: Point;\n  /** Position using diagonal points when resizing/scaling. */\n  diagonalPoint: Point;\n  /** Set of points to consider for alignment: [tl, tr, br, bl, center] */\n  list: Point[];\n  /** Change the zoom or change the size, determine by whether e.transform.action starts with the string \"scale\" */\n  isScale: boolean;\n  /** Whether to change uniformly is determined by canvas.uniformScaling and canvas.uniScaleKey. */\n  isUniform: boolean;\n  /** When holding the centerKey (default is altKey), the shape will scale based on the center point, with the reference point being the center. */\n  isCenter: boolean;\n  /** tl、tr、br、bl、mt、mr、mb、ml */\n  corner: string;\n};\n\nexport function collectVerticalPoint(\n  this: AligningGuidelines,\n  props: CollectPointProps,\n): LineProps[] {\n  const {\n    target,\n    isScale,\n    isUniform,\n    corner,\n    point,\n    diagonalPoint,\n    list,\n    isCenter,\n  } = props;\n  const { dis, arr } = getDistanceList(point, list, 'x');\n  const margin = this.margin / this.canvas.getZoom();\n  if (dis > margin) return [];\n  let v = arr[arr.length - 1].x - point.x;\n  // tl bl ml\n  // If modifying on the left side, the size decreases; conversely, it increases.\n  const dirX = corner.includes('l') ? -1 : 1;\n  v *= dirX;\n\n  const { width, height, scaleX, scaleY } = target;\n  // Because when modifying through the center point, isUniform is always false, so skew does not need to be considered.\n  const dStrokeWidth = target.strokeUniform ? 0 : target.strokeWidth;\n  const scaleWidth = scaleX * width + dStrokeWidth;\n  const sx = (v + scaleWidth) / scaleWidth;\n  // When v equals -scaleWidth, sx equals 0.\n  if (sx == 0) return [];\n  if (isScale) {\n    target.set('scaleX', scaleX * sx);\n    if (isUniform) target.set('scaleY', scaleY * sx);\n  } else {\n    target.set('width', width * sx);\n    if (isUniform) target.set('height', height * sx);\n  }\n  if (isCenter) {\n    target.setRelativeXY(diagonalPoint, 'center', 'center');\n  } else {\n    const originArr = this.contraryOriginMap;\n    target.setRelativeXY(diagonalPoint, ...originArr[corner]);\n  }\n  target.setCoords();\n  return arr.map((target) => ({ origin: point, target }));\n}\n\nexport function collectHorizontalPoint(\n  this: AligningGuidelines,\n  props: CollectPointProps,\n): LineProps[] {\n  const {\n    target,\n    isScale,\n    isUniform,\n    corner,\n    point,\n    diagonalPoint,\n    list,\n    isCenter,\n  } = props;\n  const { dis, arr } = getDistanceList(point, list, 'y');\n  const margin = this.margin / this.canvas.getZoom();\n  if (dis > margin) return [];\n  let v = arr[arr.length - 1].y - point.y;\n  // tl mt tr\n  // If modifying on the top side, the size decreases; conversely, it increases.\n  const dirY = corner.includes('t') ? -1 : 1;\n  v *= dirY;\n\n  const { width, height, scaleX, scaleY } = target;\n  // Because when modifying through the center point, isUniform is always false, so skew does not need to be considered.\n  const dStrokeWidth = target.strokeUniform ? 0 : target.strokeWidth;\n  const scaleHeight = scaleY * height + dStrokeWidth;\n  const sy = (v + scaleHeight) / scaleHeight;\n  // When v equals -scaleHeight, sy equals 0.\n  if (sy == 0) return [];\n  if (isScale) {\n    target.set('scaleY', scaleY * sy);\n    if (isUniform) target.set('scaleX', scaleX * sy);\n  } else {\n    target.set('height', height * sy);\n    if (isUniform) target.set('width', width * sy);\n  }\n  if (isCenter) {\n    target.setRelativeXY(diagonalPoint, 'center', 'center');\n  } else {\n    const originArr = this.contraryOriginMap;\n    target.setRelativeXY(diagonalPoint, ...originArr[corner]);\n  }\n  target.setCoords();\n  return arr.map((target) => ({ origin: point, target }));\n}\n","import { Point } from 'fabric';\nimport type { AligningGuidelines } from '..';\n\nexport function drawLine(\n  this: AligningGuidelines,\n  origin: Point,\n  target: Point,\n) {\n  const ctx = this.canvas.getTopContext();\n  const viewportTransform = this.canvas.viewportTransform;\n  const zoom = this.canvas.getZoom();\n  ctx.save();\n  ctx.transform(...viewportTransform);\n  ctx.lineWidth = this.width / zoom;\n  if (this.lineDash) ctx.setLineDash(this.lineDash);\n  ctx.strokeStyle = this.color;\n  ctx.beginPath();\n  ctx.moveTo(origin.x, origin.y);\n  ctx.lineTo(target.x, target.y);\n  ctx.stroke();\n  if (this.lineDash) ctx.setLineDash([]);\n\n  this.drawX(origin, -1);\n  this.drawX(target, 1);\n  ctx.restore();\n}\n\nexport function drawX(this: AligningGuidelines, point: Point, _: number) {\n  const ctx = this.canvas.getTopContext();\n  const zoom = this.canvas.getZoom();\n  const size = this.xSize / zoom;\n  ctx.save();\n  ctx.translate(point.x, point.y);\n  ctx.beginPath();\n  ctx.moveTo(-size, -size);\n  ctx.lineTo(size, size);\n  ctx.moveTo(size, -size);\n  ctx.lineTo(-size, size);\n  ctx.stroke();\n  ctx.restore();\n}\nfunction drawPoint(this: AligningGuidelines, arr: Point[]) {\n  const ctx = this.canvas.getTopContext();\n  const viewportTransform = this.canvas.viewportTransform;\n  const zoom = this.canvas.getZoom();\n  ctx.save();\n  ctx.transform(...viewportTransform);\n  ctx.lineWidth = this.width / zoom;\n  ctx.strokeStyle = this.color;\n  for (const item of arr) this.drawX(item, 0);\n  ctx.restore();\n}\n\nexport function drawPointList(this: AligningGuidelines) {\n  const list = [];\n  if (!this.closeVLine) {\n    for (const v of this.verticalLines) list.push(JSON.parse(v));\n  }\n  if (!this.closeHLine) {\n    for (const h of this.horizontalLines) list.push(JSON.parse(h));\n  }\n  const arr = list.map((item) => item.target);\n  drawPoint.call(this, arr);\n}\n\nexport function drawVerticalLine(this: AligningGuidelines) {\n  if (this.closeVLine) return;\n\n  for (const v of this.verticalLines) {\n    const { origin, target } = JSON.parse(v);\n    const o = new Point(target.x, origin.y);\n    this.drawLine(o, target);\n  }\n}\n\nexport function drawHorizontalLine(this: AligningGuidelines) {\n  if (this.closeHLine) return;\n\n  for (const v of this.horizontalLines) {\n    const { origin, target } = JSON.parse(v);\n    const o = new Point(origin.x, target.y);\n    this.drawLine(o, target);\n  }\n}\n","import type { FabricObject, Point, TOriginX, TOriginY } from 'fabric';\nimport type { AligningGuidelines } from '..';\nimport type { LineProps } from '../typedefs';\nimport { getDistanceList } from './basic';\n\nexport function collectLine(\n  this: AligningGuidelines,\n  target: FabricObject,\n  points: Point[],\n) {\n  const list = target.getCoords();\n  list.push(target.getCenterPoint());\n  const margin = this.margin / this.canvas.getZoom();\n  const opts = { target, list, points, margin };\n  const vLines = collectPoints({ ...opts, type: 'x' });\n  const hLines = collectPoints({ ...opts, type: 'y' });\n\n  return { vLines, hLines };\n}\n\ntype CollectItemLineProps = {\n  target: FabricObject;\n  list: Point[];\n  points: Point[];\n  margin: number;\n  type: 'x' | 'y';\n};\nconst originArr: [TOriginX, TOriginY][] = [\n  ['left', 'top'],\n  ['right', 'top'],\n  ['right', 'bottom'],\n  ['left', 'bottom'],\n  ['center', 'center'],\n];\nfunction collectPoints(props: CollectItemLineProps) {\n  const { target, list, points, margin, type } = props;\n  const res: LineProps[] = [];\n  const arr: ReturnType<typeof getDistanceList>[] = [];\n  let min = Infinity;\n  for (const item of list) {\n    const o = getDistanceList(item, points, type);\n    arr.push(o);\n    if (min > o.dis) min = o.dis;\n  }\n  if (min > margin) return res;\n  let b = false;\n  for (let i = 0; i < list.length; i++) {\n    if (arr[i].dis != min) continue;\n    for (const item of arr[i].arr) {\n      res.push({ origin: list[i], target: item });\n    }\n\n    if (b) continue;\n    b = true;\n    const d = arr[i].arr[0][type] - list[i][type];\n    // It will change the original data, and the next time we collect y, use the modified data.\n    list.forEach((item) => {\n      item[type] += d;\n    });\n    target.setXY(list[i], ...originArr[i]);\n    target.setCoords();\n  }\n\n  return res;\n}\n","import type { FabricObject } from 'fabric';\nimport { ActiveSelection, Group } from 'fabric';\n\nexport function getObjectsByTarget(target: FabricObject) {\n  const objects = new Set<FabricObject>();\n  const canvas = target.canvas;\n  if (!canvas) return objects;\n  const children =\n    target instanceof ActiveSelection ? target.getObjects() : [target];\n\n  canvas.forEachObject((o) => {\n    if (!o.isOnScreen()) return;\n    if (!o.visible) return;\n    if (o.constructor == Group) {\n      collectObjectsByGroup(objects, o);\n      return;\n    }\n    objects.add(o);\n  });\n\n  deleteObjectsByList(objects, children);\n  return objects;\n}\n\nfunction deleteObjectsByList(objects: Set<FabricObject>, list: FabricObject[]) {\n  for (const target of list) {\n    if (target.constructor == Group) {\n      deleteObjectsByList(objects, (target as Group).getObjects());\n    } else {\n      objects.delete(target);\n    }\n  }\n}\n\nfunction collectObjectsByGroup(objects: Set<FabricObject>, g: Group) {\n  const children = g.getObjects();\n  for (const child of children) {\n    if (!child.visible) continue;\n    if (child.constructor == Group) {\n      collectObjectsByGroup(objects, child);\n      continue;\n    }\n    objects.add(child);\n  }\n}\n","import {\n  Point,\n  FabricImage,\n  Group,\n  BaseFabricObject,\n  type FabricObject,\n  type TOriginX,\n  type TOriginY,\n} from 'fabric';\n\n/**\n * Updates the fromObject function of a class to return a version that can restore old data\n * with values of originX and originY that are different from 'center', 'center'\n * Used to upgrade from fabric 6 to fabric 7\n * @param originalFn the original fromObject function of an object,\n * @param defaultOriginX optional default value for non exported originX,\n * @param defaultOriginY optional default value for non exported originY,\n * @returns a wrapped fromObject function for the object\n */\nexport const originUpdaterWrapper = <T extends FabricObject = FabricObject>(\n  originalFn: (...args: any[]) => Promise<T>,\n  defaultOriginX: TOriginX = 'left',\n  defaultOriginY: TOriginY = 'top',\n): ((...args: any[]) => Promise<T>) =>\n  async function (this: T, serializedObject, ...args) {\n    // we default to left and top because those are defaults before deprecation\n    const { originX = defaultOriginX, originY = defaultOriginY } =\n      serializedObject;\n    // and we do not want to pass those properties on the object anymore\n    delete serializedObject.originX;\n    delete serializedObject.originY;\n    const originalObject = await originalFn.call(\n      this,\n      serializedObject,\n      ...args,\n    );\n    const actualPosition = new Point(originalObject.left, originalObject.top);\n    originalObject.setPositionByOrigin(actualPosition, originX, originY);\n    return originalObject;\n  };\n\n/**\n * Wraps and override the current fabricJS fromObject static functions\n * Used to upgrade from fabric 7 to fabric 8\n * If you used to export with includeDefaultValues = false, you have to specify\n * which were yours default origins values\n * @param originX optional default value for non exported originX,\n * @param originY optional default value for non exported originY,\n */\nexport const installOriginWrapperUpdater = (\n  originX?: TOriginX,\n  originY?: TOriginY,\n) => {\n  // @ts-expect-error the _fromObject parameter could be instantiated differently\n  BaseFabricObject._fromObject = originUpdaterWrapper(\n    BaseFabricObject._fromObject,\n    originX,\n    originY,\n  );\n  // FabricImage and Group do not use _fromObject\n  FabricImage.fromObject = originUpdaterWrapper<FabricImage>(\n    FabricImage.fromObject,\n    originX,\n    originY,\n  );\n  Group.fromObject = originUpdaterWrapper<Group>(\n    Group.fromObject,\n    originX,\n    originY,\n  );\n};\n","import type { GradientOptions, ColorStop } from 'fabric';\nimport { Color, Gradient } from 'fabric';\n\n/**\n * Updates the fromObject function of a Gradient to return a version that can restore old data\n * with opactiy in color Stops\n * Used to upgrade from fabric 6 to fabric 7\n * @param originalFn the original fromObject function of an object,\n * @returns a wrapped fromObject function for the object\n */\n\ntype OldColorStop = ColorStop & {\n  opacity?: number;\n};\n\nexport const gradientUpdaterWrapper = <S, T extends Gradient<S> = Gradient<S>>(\n  originalFn: (\n    options: GradientOptions<'linear'> | GradientOptions<'radial'>,\n  ) => Promise<T>,\n): ((\n  options: GradientOptions<'linear'> | GradientOptions<'radial'>,\n) => Promise<T>) =>\n  async function (this: T, serializedGradient) {\n    // we default to left and top because those are defaults before deprecation\n    const { colorStops } = serializedGradient;\n    // and we do not want to pass those properties on the object anymore\n    const newColorStops: ColorStop[] = (\n      colorStops as OldColorStop[]\n    )?.map<ColorStop>(({ color, opacity, offset }) => {\n      if (opacity === undefined || opacity === 1) {\n        return {\n          color,\n          offset,\n        };\n      }\n      const col = new Color(color).setAlpha(opacity).toRgba();\n      return {\n        color: col,\n        offset,\n      };\n    });\n    const gradient = await originalFn.call(this, {\n      ...serializedGradient,\n      colorStops: newColorStops,\n    });\n    return gradient;\n  };\n\n/**\n * Wraps and override the current fabricJS fromObject static functions\n * Used to upgrade from fabric 7 to fabric 8\n * If you used to export with includeDefaultValues = false, you have to specify\n * which were yours default origins values\n */\nexport const installGradientUpdater = () => {\n  // @ts-expect-error untypable\n  Gradient.fromObject = gradientUpdaterWrapper(Gradient.fromObject);\n};\n","import {\n  type BasicTransformEvent,\n  type Canvas,\n  type FabricObject,\n  type TPointerEvent,\n  type Point,\n  util,\n} from 'fabric';\nimport {\n  collectHorizontalPoint,\n  collectVerticalPoint,\n} from './util/collect-point';\nimport {\n  drawHorizontalLine,\n  drawLine,\n  drawPointList,\n  drawVerticalLine,\n  drawX,\n} from './util/draw';\nimport { collectLine } from './util/collect-line';\nimport type { AligningLineConfig, OriginMap } from './typedefs';\nimport { getObjectsByTarget } from './util/get-objects-by-target';\nimport { getContraryMap, getPointMap } from './util/basic';\n\ntype TransformEvent = BasicTransformEvent<TPointerEvent> & {\n  target: FabricObject;\n};\n\nexport class AligningGuidelines {\n  canvas: Canvas;\n  horizontalLines = new Set<string>();\n  verticalLines = new Set<string>();\n  cacheMap = new Map<string, Point[]>();\n  /**\n   * When we drag to resize using center points like mt, ml, mb, and mr,\n   * we do not need to draw line segments; we only need to draw the target points.\n   */\n  onlyDrawPoint = false;\n  /** Alignment method is required when customizing. */\n  contraryOriginMap: OriginMap = {\n    tl: ['right', 'bottom'],\n    tr: ['left', 'bottom'],\n    br: ['left', 'top'],\n    bl: ['right', 'top'],\n    mt: ['center', 'bottom'],\n    mr: ['left', 'center'],\n    mb: ['center', 'top'],\n    ml: ['right', 'center'],\n  };\n  xSize = 2.4;\n  lineDash: number[] | undefined;\n  /** At what distance from the shape does alignment begin? */\n  margin = 4;\n  /** Aligning line dimensions */\n  width = 1;\n  /** Aligning line color */\n  color = 'rgba(255,0,0,0.9)';\n  /** Close Vertical line, default false. */\n  closeVLine = false;\n  /** Close horizontal line, default false. */\n  closeHLine = false;\n\n  constructor(canvas: Canvas, options: Partial<AligningLineConfig> = {}) {\n    this.canvas = canvas;\n    Object.assign(this, options);\n\n    this.mouseUp = this.mouseUp.bind(this);\n    this.scalingOrResizing = this.scalingOrResizing.bind(this);\n    this.moving = this.moving.bind(this);\n    this.beforeRender = this.beforeRender.bind(this);\n    this.afterRender = this.afterRender.bind(this);\n\n    this.initBehavior();\n  }\n  initBehavior() {\n    this.canvas.on('mouse:up', this.mouseUp);\n    this.canvas.on('object:resizing', this.scalingOrResizing);\n    this.canvas.on('object:scaling', this.scalingOrResizing);\n    this.canvas.on('object:moving', this.moving);\n    this.canvas.on('before:render', this.beforeRender);\n    this.canvas.on('after:render', this.afterRender);\n  }\n  /** Returns shapes that can draw aligning lines, default returns all shapes on the canvas excluding groups. */\n  getObjectsByTarget(target: FabricObject) {\n    return getObjectsByTarget(target);\n  }\n  /** When the user customizes the controller, this property is set to enable or disable automatic alignment through point scaling/resizing. */\n  getPointMap(target: FabricObject) {\n    return getPointMap(target);\n  }\n  /** When the user customizes the controller, this property is used to enable or disable alignment positioning through points. */\n  getContraryMap(target: FabricObject) {\n    return getContraryMap(target);\n  }\n  /** Users can customize. */\n  getCaCheMapValue(object: FabricObject) {\n    const cacheKey = [\n      object.calcTransformMatrix().toString(),\n      object.width,\n      object.height,\n    ].join();\n    const cacheValue = this.cacheMap.get(cacheKey);\n    if (cacheValue) return cacheValue;\n    const value = object.getCoords();\n    value.push(object.getCenterPoint());\n    this.cacheMap.set(cacheKey, value);\n    return value;\n  }\n  drawLine(origin: Point, target: Point) {\n    drawLine.call(this, origin, target);\n  }\n  drawX(point: Point, dir: number) {\n    drawX.call(this, point, dir);\n  }\n  mouseUp() {\n    this.verticalLines.clear();\n    this.horizontalLines.clear();\n    this.cacheMap.clear();\n    this.canvas.requestRenderAll();\n  }\n\n  scalingOrResizing(e: TransformEvent) {\n    const target = e.target;\n    // We need to obtain the real-time coordinates of the current object, so we need to update them in real-time\n    target.setCoords();\n    // The value of action can be scaleX, scaleY, scale, resize, etc.\n    // If it does not start with \"scale,\" it is considered a modification of size.\n    const isScale = String(e.transform.action).startsWith('scale');\n    this.verticalLines.clear();\n    this.horizontalLines.clear();\n\n    const objects = this.getObjectsByTarget(target);\n    // When the shape is flipped, the tl obtained through getCoords is actually tr,\n    // and tl is actually tr. We need to make correction adjustments.\n    // tr <-> tl、 bl <-> br、  mb <-> mt、 ml <-> mr\n    let corner = e.transform.corner;\n    if (target.flipX) {\n      if (corner.includes('l')) corner = corner.replace('l', 'r');\n      else if (corner.includes('r')) corner = corner.replace('r', 'l');\n    }\n    if (target.flipY) {\n      if (corner.includes('t')) corner = corner.replace('t', 'b');\n      else if (corner.includes('b')) corner = corner.replace('b', 't');\n    }\n\n    // Obtain the coordinates of the current operation point through the value of corner.\n    // users can be allowed to customize and pass in custom corners.\n    const pointMap = this.getPointMap(target);\n    if (!(corner in pointMap)) return;\n    this.onlyDrawPoint = corner.includes('m');\n    if (this.onlyDrawPoint) {\n      const angle = target.getTotalAngle();\n      // When the shape is rotated, it is meaningless to draw points using the center point.\n      if (angle % 90 != 0) return;\n    }\n    // If manipulating tl, then when the shape changes size, it should be positioned by br,\n    // and the same applies to others.\n    // users can be allowed to customize and pass in custom corners.\n    const contraryMap = this.getContraryMap(target);\n    const point = pointMap[corner];\n    let diagonalPoint = contraryMap[corner];\n    // When holding the centerKey (default is altKey), the shape will scale based on the center point, with the reference point being the center.\n    const isCenter =\n      e.transform.original.originX == 'center' &&\n      e.transform.original.originY == 'center';\n    if (isCenter) {\n      const p = target.group\n        ? point.transform(\n            util.invertTransform(target.group.calcTransformMatrix()),\n          )\n        : point;\n      diagonalPoint = diagonalPoint.add(p).scalarDivide(2);\n    }\n    const uniformIsToggled = e.e[this.canvas.uniScaleKey!];\n    let isUniform =\n      (this.canvas.uniformScaling && !uniformIsToggled) ||\n      (!this.canvas.uniformScaling && uniformIsToggled);\n    // When controlling through the center point,\n    // if isUniform is true, it actually changes the skew, so it is meaningless.\n    if (this.onlyDrawPoint) isUniform = false;\n\n    const list: Point[] = [];\n    for (const object of objects) {\n      const d = this.getCaCheMapValue(object);\n      list.push(...d);\n    }\n\n    const props = {\n      target,\n      point,\n      diagonalPoint,\n      corner,\n      list,\n      isScale,\n      isUniform,\n      isCenter,\n    };\n\n    // Obtain horizontal and vertical reference lines.\n    const noNeedToCollectV =\n      this.onlyDrawPoint && (corner.includes('t') || corner.includes('b'));\n    const noNeedToCollectH =\n      this.onlyDrawPoint && (corner.includes('l') || corner.includes('r'));\n    const vList = noNeedToCollectV\n      ? []\n      : collectVerticalPoint.call(this, props);\n    const hList = noNeedToCollectH\n      ? []\n      : collectHorizontalPoint.call(this, props);\n    vList.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.verticalLines.add(JSON.stringify(o));\n    });\n    hList.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.horizontalLines.add(JSON.stringify(o));\n    });\n  }\n  moving(e: TransformEvent) {\n    const target = e.target;\n    // We need to obtain the real-time coordinates of the current object, so we need to update them in real-time\n    target.setCoords();\n    this.onlyDrawPoint = false;\n    this.verticalLines.clear();\n    this.horizontalLines.clear();\n\n    // Find the shapes associated with the current graphic to draw reference lines for it.\n    const objects = this.getObjectsByTarget(target);\n    const points: Point[] = [];\n    // Collect all the points to draw reference lines.\n    for (const object of objects) points.push(...this.getCaCheMapValue(object));\n\n    // Obtain horizontal and vertical reference lines.\n    const { vLines, hLines } = collectLine.call(this, target, points);\n    vLines.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.verticalLines.add(JSON.stringify(o));\n    });\n    hLines.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.horizontalLines.add(JSON.stringify(o));\n    });\n  }\n  beforeRender() {\n    this.canvas.clearContext(this.canvas.contextTop);\n  }\n  afterRender() {\n    if (this.onlyDrawPoint) {\n      drawPointList.call(this);\n    } else {\n      drawVerticalLine.call(this);\n      drawHorizontalLine.call(this);\n    }\n  }\n\n  dispose() {\n    this.canvas.off('mouse:up', this.mouseUp);\n    this.canvas.off('object:resizing', this.scalingOrResizing);\n    this.canvas.off('object:scaling', this.scalingOrResizing);\n    this.canvas.off('object:moving', this.moving);\n    this.canvas.off('before:render', this.beforeRender);\n    this.canvas.off('after:render', this.afterRender);\n  }\n}\n","import wes from 'westures';\nimport { type Canvas, type CanvasEvents, type XY, util } from 'fabric';\n\ntype PinchEventData = {\n  centroid: XY;\n  event: PointerEvent;\n  phase: string;\n  type: 'pinch';\n  scale: number;\n  target: HTMLElement;\n};\n\ntype RotateEventData = {\n  centroid: XY;\n  event: PointerEvent;\n  phase: string;\n  type: 'rotate';\n  rotation: number;\n  target: HTMLElement;\n};\n\ntype TapEventData = {\n  centroid: XY;\n  event: PointerEvent;\n  phase: string;\n  type: 'tap';\n  target: HTMLElement;\n};\n\n/**\n * Register this handler on canvas.on('pinch', pinchEventHandler);\n * To get an out of the box functionality for the pinch to zoom\n */\nexport function pinchEventHandler(\n  this: Canvas,\n  { scale, target, scenePoint }: CanvasEvents['pinch'],\n) {\n  if (target && this.getActiveObject() === target) {\n    // if we are pinching on the active object, let's scale it\n    target.scaleX *= scale;\n    target.scaleY *= scale;\n  } else {\n    this.zoomToPoint(scenePoint, this.getZoom() * scale);\n  }\n}\n\nexport function rotateEventHandler(\n  this: Canvas,\n  { rotation, target }: CanvasEvents['rotate'],\n) {\n  if (target && this.getActiveObject() === target) {\n    target.rotate(target.angle + util.radiansToDegrees(rotation));\n  }\n}\n\nexport const tripleTapGesture = (canvas: Canvas) => {\n  return new wes.Tap(\n    canvas.upperCanvasEl,\n    ({ event }: TapEventData) => {\n      canvas.fireEventFromPointerEvent(\n        event,\n        'mouse:tripleclick',\n        'mousetripleclick',\n        undefined,\n      );\n      event.preventDefault();\n    },\n    {\n      numTaps: 3,\n      maxRetain: 400,\n    },\n  );\n};\n\nexport const doubleTapGesture = (canvas: Canvas) => {\n  return new wes.Tap(\n    canvas.upperCanvasEl,\n    ({ event }: TapEventData) => {\n      canvas.fireEventFromPointerEvent(\n        event,\n        'mouse:dblclick',\n        'mousedblclick',\n        undefined,\n      );\n      event.preventDefault();\n    },\n    {\n      numTaps: 2,\n      maxRetain: 300,\n    },\n  );\n};\n\nexport const pinchGesture = (canvas: Canvas) => {\n  return new wes.Pinch(\n    canvas.upperCanvasEl,\n    ({ scale, event }: PinchEventData) => {\n      canvas.fireEventFromPointerEvent(event, 'pinch', 'pinch', { scale });\n    },\n  );\n};\n\nexport const rotateGesture = (canvas: Canvas) => {\n  return new wes.Rotate(\n    canvas.upperCanvasEl,\n    ({ rotation, event }: RotateEventData) => {\n      canvas.fireEventFromPointerEvent(event, 'rotate', 'rotate', { rotation });\n    },\n  );\n};\n\n/**\n * Add a serie of gestures recognition on the canvas\n */\nexport const addGestures = (canvas: Canvas) => {\n  const canvasRegion = new wes.Region(canvas.upperCanvasEl);\n  canvas.addOrRemove(\n    (\n      el: HTMLElement,\n      ...args: Parameters<HTMLElement['removeEventListener']>\n    ) => el.removeEventListener(...args),\n  );\n  canvasRegion.addGesture(rotateGesture(canvas));\n  canvasRegion.addGesture(pinchGesture(canvas));\n  canvasRegion.addGesture(tripleTapGesture(canvas));\n  canvasRegion.addGesture(doubleTapGesture(canvas));\n  // add back events, excluding the click one\n  canvas.addOrRemove(\n    (el: HTMLElement, ...args: Parameters<HTMLElement['addEventListener']>) =>\n      el.addEventListener(...args),\n    true,\n  );\n};\n"],"names":["getDistance","a","b","Math","abs","getDistanceList","point","list","type","dis","Infinity","arr","item","v","push","collectVerticalPoint","props","target","isScale","isUniform","corner","diagonalPoint","isCenter","this","margin","canvas","getZoom","length","x","includes","width","height","scaleX","scaleY","scaleWidth","strokeUniform","strokeWidth","sx","set","setRelativeXY","originArr","contraryOriginMap","setCoords","map","origin","collectHorizontalPoint","y","scaleHeight","sy","drawLine","ctx","getTopContext","viewportTransform","zoom","save","transform","lineWidth","lineDash","setLineDash","strokeStyle","color","beginPath","moveTo","lineTo","stroke","drawX","restore","_","size","xSize","translate","drawPoint","drawPointList","closeVLine","verticalLines","JSON","parse","closeHLine","h","horizontalLines","call","drawVerticalLine","o","Point","drawHorizontalLine","collectLine","points","getCoords","getCenterPoint","opts","vLines","collectPoints","hLines","res","min","i","d","forEach","setXY","getObjectsByTarget","objects","Set","children","ActiveSelection","getObjects","forEachObject","isOnScreen","visible","constructor","Group","add","collectObjectsByGroup","deleteObjectsByList","delete","g","child","originUpdaterWrapper","originalFn","defaultOriginX","arguments","undefined","defaultOriginY","async","serializedObject","originX","originY","_len","args","Array","_key","originalObject","actualPosition","left","top","setPositionByOrigin","gradientUpdaterWrapper","serializedGradient","colorStops","newColorStops","_ref","opacity","offset","Color","setAlpha","toRgba","options","_defineProperty","Map","tl","tr","br","bl","mt","mr","mb","ml","Object","assign","mouseUp","bind","scalingOrResizing","moving","beforeRender","afterRender","initBehavior","on","getPointMap","coords","scalarDivide","getContraryMap","_target$aCoords","aCoords","calcACoords","getCaCheMapValue","object","cacheKey","calcTransformMatrix","toString","join","cacheValue","cacheMap","get","value","dir","clear","requestRenderAll","e","String","action","startsWith","flipX","replace","flipY","pointMap","onlyDrawPoint","getTotalAngle","contraryMap","original","p","group","util","invertTransform","uniformIsToggled","uniScaleKey","uniformScaling","noNeedToCollectV","noNeedToCollectH","vList","hList","stringify","clearContext","contextTop","dispose","off","canvasRegion","wes","Region","upperCanvasEl","addOrRemove","el","removeEventListener","addGesture","Rotate","_ref6","rotation","event","fireEventFromPointerEvent","rotateGesture","Pinch","_ref5","scale","pinchGesture","Tap","_ref3","preventDefault","numTaps","maxRetain","tripleTapGesture","_ref4","doubleTapGesture","_len2","_key2","addEventListener","installGradientUpdater","Gradient","fromObject","installOriginWrapperUpdater","BaseFabricObject","_fromObject","FabricImage","scenePoint","getActiveObject","zoomToPoint","_ref2","rotate","angle","radiansToDegrees"],"mappings":"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"}