{"version":3,"file":"fabric-extensions.min.js","sources":["../extensions/aligning_guidelines/constant.ts","../extensions/aligning_guidelines/util/basic.ts","../extensions/aligning_guidelines/util/collect-line.ts","../extensions/aligning_guidelines/util/collect-point.ts","../extensions/aligning_guidelines/util/draw.ts","../extensions/aligning_guidelines/util/get-objects-by-target.ts","../extensions/data_updaters/origins/index.ts","../extensions/aligning_guidelines/index.ts"],"sourcesContent":["import type { AligningLineConfig } from './typedefs';\n\nexport const aligningLineConfig: AligningLineConfig = {\n  /** At what distance from the shape does alignment begin? */\n  margin: 4,\n  /** Aligning line dimensions */\n  width: 1,\n  /** Aligning line color */\n  color: 'rgb(255,0,0,0.9)',\n};\n","import type { FabricObject, Point } from 'fabric';\n\nexport function getDistance(a: number, b: number) {\n  return Math.abs(a - b);\n}\n\nexport function setPositionDir(\n  target: FabricObject,\n  pos: Point,\n  dir: 'x' | 'y',\n) {\n  const center = target.translateToCenterPoint(pos, 'center', 'center');\n  const position = target.translateToOriginPoint(\n    center,\n    target.originX,\n    target.originY,\n  );\n  if (dir == 'x') target.setX(position.x);\n  else target.setY(position.y);\n}\n","import type { FabricObject, TBBox } from 'fabric';\nimport { Point } from 'fabric';\nimport type { HorizontalLine, VerticalLine } from '../typedefs';\nimport { aligningLineConfig } from '../constant';\nimport { getDistance, setPositionDir } from './basic';\n\ntype CollectLineProps = {\n  activeObject: FabricObject;\n  activeObjectRect: TBBox;\n  objectRect: TBBox;\n};\n\nexport function collectLine(props: CollectLineProps) {\n  const aligningLineMargin = aligningLineConfig.margin;\n  const { activeObject, activeObjectRect, objectRect } = props;\n  const list = makeLineByRect(objectRect);\n  const aList = makeLineByRect(activeObjectRect);\n  const margin = aligningLineMargin / (activeObject.canvas?.getZoom() ?? 1);\n  const opts = { target: activeObject, list, aList, margin };\n  const vLines = collectVerticalLine(opts);\n  const hLines = collectHorizontalLine(opts);\n\n  return { vLines, hLines };\n}\n\ntype CollectItemLineProps = {\n  target: FabricObject;\n  list: LineProps[];\n  aList: LineProps[];\n  margin: number;\n};\nfunction collectVerticalLine(props: CollectItemLineProps) {\n  const { target, list, aList, margin } = props;\n\n  const arr = aList.map((x) => getDistanceLine(x, list, 'x'));\n  const min = Math.min(...arr.map((x) => x.dis));\n  if (min > margin) return [];\n  const lines: VerticalLine[] = [];\n  const width = aList[0].x2 - aList[0].x;\n  const height = aList[0].y2 - aList[0].y;\n  let b = false;\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    if (min == item.dis) {\n      const line = list[item.index];\n      const aLine = aList[item.index];\n      const x = line.x;\n      const y = aLine.y;\n\n      const y1 = Math.min(line.y, line.y2, y, aLine.y2);\n      const y2 = Math.max(line.y, line.y2, y, aLine.y2);\n      // 参考线可画多条\n      lines.push({ x, y1, y2 });\n      if (b) continue;\n      b = true;\n      // 对齐只进行一次\n      setPos({\n        target,\n        x,\n        y,\n        centerX: i - 1,\n        centerY: item.index - 1,\n        width,\n        height,\n        dir: 'x',\n      });\n      const dis = min * item.dir;\n      aList.forEach((x) => (x.x -= dis));\n    }\n  }\n  return lines;\n}\n\nfunction collectHorizontalLine(props: CollectItemLineProps) {\n  const { target, list, aList, margin } = props;\n\n  const arr = aList.map((x) => getDistanceLine(x, list, 'y'));\n  const min = Math.min(...arr.map((x) => x.dis));\n  if (min > margin) return [];\n  const lines: HorizontalLine[] = [];\n  const width = aList[0].x2 - aList[0].x;\n  const height = aList[0].y2 - aList[0].y;\n  let b = false;\n  for (let i = 0; i < arr.length; i++) {\n    const item = arr[i];\n    if (min == item.dis) {\n      const line = list[item.index];\n      const aLine = aList[item.index];\n      const y = line.y;\n      const x = aLine.x;\n\n      const x1 = Math.min(line.x, line.x2, x, aLine.x2);\n      const x2 = Math.max(line.x, line.x2, x, aLine.x2);\n      // 参考线可画多条\n      lines.push({ y, x1, x2 });\n      if (b) continue;\n      b = true;\n      // 对齐只进行一次\n      setPos({\n        target,\n        x,\n        y,\n        centerX: item.index - 1,\n        centerY: i - 1,\n        width,\n        height,\n        dir: 'y',\n      });\n      const dis = min * item.dir;\n      aList.forEach((x) => (x.y -= dis));\n    }\n  }\n  return lines;\n}\n\ntype LineProps = {\n  x: number;\n  y: number;\n  x2: number;\n  y2: number;\n};\nfunction getDistanceLine(\n  target: LineProps,\n  list: LineProps[],\n  type: 'x' | 'y',\n) {\n  let dis = Infinity;\n  let index = -1;\n  /** 1正值 -1负值 */\n  let dir = 1;\n  for (let i = 0; i < list.length; i++) {\n    const v = getDistance(target[type], list[i][type]);\n    if (dis > v) {\n      index = i;\n      dis = v;\n      dir = target[type] > list[i][type] ? 1 : -1;\n    }\n  }\n  return { dis, index, dir };\n}\n\nfunction makeLineByRect(rect: TBBox) {\n  const { left, top, width, height } = rect;\n  const a = { x: left, y: top, x2: left + width, y2: top + height };\n  const x = left + width / 2;\n  const y = top + height / 2;\n  const b = { x, y, x2: x, y2: y };\n  const c = { x: left + width, x2: left, y: top + height, y2: top };\n\n  return [a, b, c];\n}\n\ntype SnapToPixelProps = {\n  target: FabricObject;\n  x: number;\n  y: number;\n  /** -1 0 1 */\n  centerX: number;\n  /** -1 0 1 */\n  centerY: number;\n  width: number;\n  height: number;\n  dir: 'x' | 'y';\n};\nfunction setPos(props: SnapToPixelProps) {\n  const { target, centerX, centerY, width, height, dir } = props;\n  let { x, y } = props;\n  x -= (centerX * width) / 2;\n  y -= (centerY * height) / 2;\n  setPositionDir(target, new Point(x, y), dir);\n  target.setCoords();\n}\n","import type { FabricObject, Point, TOriginX, TOriginY } from 'fabric';\nimport { aligningLineConfig } from '../constant';\nimport { getDistance } from './basic';\n\ntype CollectPointProps = {\n  activeObject: FabricObject;\n  point: Point;\n  list: Point[];\n  isScale: boolean;\n  index: number;\n};\nconst originXArr: TOriginX[] = ['left', 'center', 'right'];\nconst originYArr: TOriginY[] = ['top', 'center', 'bottom'];\n\nexport function collectVerticalPoint(props: CollectPointProps) {\n  const aligningLineMargin = aligningLineConfig.margin;\n  const { activeObject, isScale, index, point, list } = props;\n  const { dis, arr } = getDistanceList(point, list, 'x');\n  const margin = aligningLineMargin / (activeObject.canvas?.getZoom() ?? 1);\n  if (dis > margin) return [];\n  let v = arr[arr.length - 1].x - point.x;\n  const dir = index == 0 || index == 3 ? -1 : 1;\n  v *= dir;\n\n  const { width, scaleX, left } = activeObject;\n  const dim = activeObject._getTransformedDimensions();\n  const sx = (v + dim.x) / dim.x;\n  if (isScale) activeObject.set('scaleX', scaleX * sx);\n  else activeObject.set('width', width * sx);\n  const dArr = [0, (v / 2) * dir, v * dir];\n  if (dir < 0) dArr.reverse();\n  const d = dArr[originXArr.indexOf(activeObject.originX)];\n  activeObject.set('left', left + d);\n  activeObject.setCoords();\n  return arr.map((item) => ({\n    x: item.x,\n    y1: item.y,\n    y2: point.y,\n  }));\n}\n\nexport function collectHorizontalPoint(props: CollectPointProps) {\n  const aligningLineMargin = aligningLineConfig.margin;\n  const { activeObject, isScale, index, point, list } = props;\n  const { dis, arr } = getDistanceList(point, list, 'y');\n  const margin = aligningLineMargin / (activeObject.canvas?.getZoom() ?? 1);\n  if (dis > margin) return [];\n  let v = arr[arr.length - 1].y - point.y;\n  const dir = index < 2 ? -1 : 1;\n  v *= dir;\n\n  const { height, scaleY, top } = activeObject;\n  const dim = activeObject._getTransformedDimensions();\n  const sy = (v + dim.y) / dim.y;\n  if (isScale) activeObject.set('scaleY', scaleY * sy);\n  else activeObject.set('height', height * sy);\n  const dArr = [0, (v / 2) * dir, v * dir];\n  if (dir < 0) dArr.reverse();\n  const d = dArr[originYArr.indexOf(activeObject.originY)];\n  activeObject.set('top', top + d);\n  activeObject.setCoords();\n  return arr.map((item) => ({\n    y: item.y,\n    x1: item.x,\n    x2: point.x,\n  }));\n}\n\nfunction getDistanceList(point: Point, list: Point[], type: 'x' | 'y') {\n  let dis = Infinity;\n  let arr: Point[] = [];\n  for (const item of list) {\n    const v = getDistance(point[type], item[type]);\n    if (dis > v) {\n      arr = [];\n      dis = v;\n    }\n    if (dis == v) {\n      arr.push(item);\n    }\n  }\n  return { dis, arr };\n}\n","import type { Canvas } from 'fabric';\nimport { Point } from 'fabric';\nimport type { HorizontalLine, VerticalLine } from '../typedefs';\nimport { aligningLineConfig } from '../constant';\n\nfunction drawLine(canvas: Canvas, origin: Point, target: Point) {\n  const { width, color } = aligningLineConfig;\n  const ctx = canvas.getSelectionContext();\n  const viewportTransform = canvas.viewportTransform;\n  const zoom = canvas.getZoom();\n  ctx.save();\n  ctx.transform(...viewportTransform);\n  ctx.lineWidth = width / zoom;\n  ctx.strokeStyle = color;\n  ctx.beginPath();\n  ctx.moveTo(origin.x, origin.y);\n  ctx.lineTo(target.x, target.y);\n  ctx.stroke();\n  drawX(ctx, zoom, origin);\n  drawX(ctx, zoom, target);\n  ctx.restore();\n}\n\nconst xSize = 2.4;\nfunction drawX(ctx: CanvasRenderingContext2D, zoom: number, point: Point) {\n  const size = xSize / zoom;\n  ctx.save();\n  ctx.translate(point.x, point.y);\n  ctx.beginPath();\n  ctx.moveTo(-size, -size);\n  ctx.lineTo(size, size);\n  ctx.moveTo(size, -size);\n  ctx.lineTo(-size, size);\n  ctx.stroke();\n  ctx.restore();\n}\nfunction drawPoint(canvas: Canvas, arr: Point[]) {\n  const { width, color } = aligningLineConfig;\n  const ctx = canvas.getSelectionContext();\n  const viewportTransform = canvas.viewportTransform;\n  const zoom = canvas.getZoom();\n  ctx.save();\n  ctx.transform(...viewportTransform);\n  ctx.lineWidth = width / zoom;\n  ctx.strokeStyle = color;\n  for (const item of arr) drawX(ctx, zoom, item);\n  ctx.restore();\n}\nexport function drawPointList(\n  canvas: Canvas,\n  list: Array<VerticalLine | HorizontalLine>,\n) {\n  const arr = list.map((item) => {\n    const isVertical = 'y2' in item;\n    const x = isVertical ? item.x : item.x1;\n    const y = isVertical ? item.y1 : item.y;\n    return new Point(x, y);\n  });\n  drawPoint(canvas, arr);\n}\n\nexport function drawVerticalLine(canvas: Canvas, coords: VerticalLine) {\n  const x = coords.x;\n  const origin = new Point(x, coords.y1);\n  const target = new Point(x, coords.y2);\n  drawLine(canvas, origin, target);\n}\n\nexport function drawHorizontalLine(canvas: Canvas, coords: HorizontalLine) {\n  const y = coords.y;\n  const origin = new Point(coords.x1, y);\n  const target = new Point(coords.x2, y);\n  drawLine(canvas, origin, target);\n}\n","import type { FabricObject } from 'fabric';\nimport { ActiveSelection, Group } from 'fabric';\n\n/**\n * Finds all visible, on-screen objects on the canvas that could be potential\n * snapping targets for the given `target` object. Excludes the `target` object\n * itself (and its children if it's a selection/group). Can optionally filter\n * out objects based on a custom predicate.\n *\n * @param target The object being moved or resized, for which potential snapping\n *     targets are needed.\n * @param shouldExclude Optional function to filter potential target objects.\n *     If the function returns `true` for an object, it will be excluded as a\n *     potential snapping target.\n * @return A Set of FabricObjects that are potential snapping targets.\n */\nexport function getObjectsByTarget(\n  target: FabricObject,\n  shouldExclude?: (obj: FabricObject) => boolean,\n) {\n  const objects = new Set<FabricObject>();\n  const canvas = target.canvas;\n  if (!canvas) return objects;\n  const draggedObjects =\n    target instanceof ActiveSelection ? target.getObjects() : [target];\n\n  canvas.forEachObject((o) => {\n    if (!o.isOnScreen()) return;\n    if (!o.visible) return;\n\n    // Use instanceof for more reliable group checking (e.g. subclasses of\n    // Group).\n    if (o instanceof Group) {\n      // Process group children using the `shouldExclude` predicate. The group\n      //'o' itself is NOT added as a target here.\n      collectObjectsByGroup(objects, o, shouldExclude);\n      // Continue to next canvas object.\n      return;\n    }\n\n    // Add non-group objects only if they are NOT excluded by the predicate.\n    if (!(shouldExclude && shouldExclude(o))) {\n      objects.add(o);\n    }\n  });\n\n  // Remove the dragged object and its descendants from potential targets.\n  deleteObjectsByList(objects, draggedObjects);\n  return objects;\n}\n\n/**\n * Recursively removes objects from a Set based on a provided list.\n * If an item in the list is a Group, its children are also recursively removed.\n *\n * @param objects The Set of objects to modify.\n * @param list The list of objects (or groups) to remove from the Set.\n */\nfunction deleteObjectsByList(objects: Set<FabricObject>, list: FabricObject[]) {\n  for (const target of list) {\n    // Always remove the target itself from the potential snapping candidates.\n    objects.delete(target);\n\n    if (target instanceof Group) {\n      deleteObjectsByList(objects, (target as Group).getObjects());\n    } else {\n      objects.delete(target);\n    }\n  }\n}\n\n/**\n * Recursively collects all visible, non-group child objects from within a given\n * Group and adds them to the provided Set. Can optionally filter out objects\n * based on a custom predicate.\n *\n * @param objects The Set to add collected objects to.\n * @param g The Group object to traverse.\n * @param shouldExclude Optional function to filter potential target objects.\n *     If the function returns `true` for an object, it (and its children if\n *     it's a group) will be skipped when collecting objects.\n */\nfunction collectObjectsByGroup(\n  objects: Set<FabricObject>,\n  g: Group,\n  shouldExclude?: (obj: FabricObject) => boolean,\n) {\n  const children = g.getObjects();\n  for (const child of children) {\n    if (!child.visible) continue;\n    // Check exclusion for the child.\n    if (shouldExclude && shouldExclude(child)) {\n      continue;\n    }\n\n    if (child.constructor == Group) {\n      collectObjectsByGroup(objects, child, shouldExclude);\n      continue;\n    }\n    objects.add(child);\n  }\n}\n","import {\n  Point,\n  FabricImage,\n  Group,\n  BaseFabricObject,\n  type FabricObject,\n  type TOriginX,\n  type TOriginY,\n} from 'fabric';\n\n/**\n * Updates the fromObject function of a class to return a version that can restore old data\n * with values of originX and originY that are different from 'center', 'center'\n * Used to upgrade from fabric 6 to fabric 7\n * @param originalFn the original fromObject function of an object,\n * @param defaultOriginX optional default value for non exported originX,\n * @param defaultOriginY optional default value for non exported originY,\n * @returns a wrapped fromObject function for the object\n */\nexport const originUpdaterWrapper = <T extends FabricObject = FabricObject>(\n  originalFn: (...args: any[]) => Promise<T>,\n  defaultOriginX: TOriginX = 'left',\n  defaultOriginY: TOriginY = 'top',\n): ((...args: any[]) => Promise<T>) =>\n  async function (this: T, serializedObject, ...args) {\n    // we default to left and top because those are defaults before deprecation\n    const { originX = defaultOriginX, originY = defaultOriginY } =\n      serializedObject;\n    // and we do not want to pass those properties on the object anymore\n    delete serializedObject.originX;\n    delete serializedObject.originY;\n    const originalObject = await originalFn.call(\n      this,\n      serializedObject,\n      ...args,\n    );\n    const actualPosition = new Point(originalObject.left, originalObject.top);\n    originalObject.setPositionByOrigin(actualPosition, originX, originY);\n    return originalObject;\n  };\n\n/**\n * Wraps and override the current fabricJS fromObject static functions\n * Used to upgrade from fabric 6 to fabric 7\n * @param defaultOriginX optional default value for non exported originX,\n * @param defaultOriginY optional default value for non exported originY,\n * @returns a wrapped fromObject function for the object\n */\nexport const installOriginWrapperUpdater = (\n  originX?: TOriginX,\n  originY?: TOriginY,\n) => {\n  // @ts-expect-error the _fromObject parameter could be instantiated differently\n  BaseFabricObject._fromObject = originUpdaterWrapper<FabricObject>(\n    BaseFabricObject._fromObject,\n    originX,\n    originY,\n  );\n  // FabricImage and Group do not use _fromObject\n  FabricImage.fromObject = originUpdaterWrapper<FabricImage>(\n    FabricImage.fromObject,\n    originX,\n    originY,\n  );\n  Group.fromObject = originUpdaterWrapper<Group>(\n    Group.fromObject,\n    originX,\n    originY,\n  );\n};\n","import type {\n  BasicTransformEvent,\n  Canvas,\n  FabricObject,\n  TBBox,\n  TPointerEvent,\n} from 'fabric';\nimport { Point, util } from 'fabric';\n\nimport { aligningLineConfig } from './constant';\nimport type {\n  AligningLineConfig,\n  HorizontalLine,\n  VerticalLine,\n} from './typedefs';\nimport { collectLine } from './util/collect-line';\nimport {\n  collectHorizontalPoint,\n  collectVerticalPoint,\n} from './util/collect-point';\nimport {\n  drawHorizontalLine,\n  drawPointList,\n  drawVerticalLine,\n} from './util/draw';\nimport { getObjectsByTarget } from './util/get-objects-by-target';\n\ntype TransformEvent = BasicTransformEvent<TPointerEvent> & {\n  target: FabricObject;\n};\n\nexport type { AligningLineConfig } from './typedefs';\n\nexport function initAligningGuidelines(\n  canvas: Canvas,\n  options: Partial<AligningLineConfig> = {},\n  shouldExclude?: (obj: FabricObject) => boolean,\n) {\n  Object.assign(aligningLineConfig, options);\n\n  const horizontalLines = new Set<string>();\n  const verticalLines = new Set<string>();\n  let onlyDrawPoint = false;\n  const cacheMap = new Map<string, [TBBox, Point[]]>();\n\n  const getCaCheMapValue = (object: FabricObject) => {\n    const cacheKey = [\n      object.calcTransformMatrix().toString(),\n      object.width,\n      object.height,\n    ].join();\n    const cacheValue = cacheMap.get(cacheKey);\n    if (cacheValue) return cacheValue;\n    const coords = object.getCoords();\n    const rect = util.makeBoundingBoxFromPoints(coords);\n    const value: [TBBox, Point[]] = [rect, coords];\n    cacheMap.set(cacheKey, value);\n    return value;\n  };\n\n  function moving(e: TransformEvent) {\n    const activeObject = e.target;\n    activeObject.setCoords();\n    onlyDrawPoint = false;\n    verticalLines.clear();\n    horizontalLines.clear();\n\n    const objects = getObjectsByTarget(activeObject, shouldExclude);\n    const activeObjectRect = activeObject.getBoundingRect();\n\n    for (const object of objects) {\n      const objectRect = getCaCheMapValue(object)[0];\n      const { vLines, hLines } = collectLine({\n        activeObject,\n        activeObjectRect,\n        objectRect,\n      });\n      vLines.forEach((o) => {\n        verticalLines.add(JSON.stringify(o));\n      });\n      hLines.forEach((o) => {\n        horizontalLines.add(JSON.stringify(o));\n      });\n    }\n  }\n\n  function scalingOrResizing(e: TransformEvent) {\n    // br bl tr tl mb ml mt mr\n    const activeObject = e.target;\n    activeObject.setCoords();\n    const isScale = String(e.transform.action).startsWith('scale');\n    verticalLines.clear();\n    horizontalLines.clear();\n\n    const objects = getObjectsByTarget(activeObject, shouldExclude);\n    let corner = e.transform.corner;\n    if (activeObject.flipX) corner = corner.replace('l', 'r').replace('r', 'l');\n    if (activeObject.flipY) corner = corner.replace('t', 'b').replace('b', 't');\n    let index = ['tl', 'tr', 'br', 'bl', 'mt', 'mr', 'mb', 'ml'].indexOf(\n      corner,\n    );\n    if (index == -1) return;\n    onlyDrawPoint = index > 3;\n    if (onlyDrawPoint) {\n      const angle = activeObject.getTotalAngle();\n      if (angle % 90 != 0) return;\n      index -= 4;\n    }\n    let point = activeObject.getCoords()[index];\n    for (const object of objects) {\n      const [rect, coords] = getCaCheMapValue(object);\n      const center = new Point(\n        rect.left + rect.width / 2,\n        rect.top + rect.height / 2,\n      );\n      const list = [...coords, center];\n      const props = { activeObject, point, list, isScale, index };\n      const vLines = collectVerticalPoint(props);\n      const hLines = collectHorizontalPoint(props);\n      vLines.forEach((o) => {\n        verticalLines.add(JSON.stringify(o));\n      });\n      hLines.forEach((o) => {\n        horizontalLines.add(JSON.stringify(o));\n      });\n      if (vLines.length || hLines.length)\n        point = activeObject.getCoords()[index];\n    }\n  }\n\n  function beforeRender() {\n    canvas.clearContext(canvas.contextTop);\n  }\n  function afterRender() {\n    if (onlyDrawPoint) {\n      const list: Array<VerticalLine | HorizontalLine> = [];\n      for (const v of verticalLines)\n        list.push(JSON.parse(v) as VerticalLine | HorizontalLine);\n      for (const h of horizontalLines)\n        list.push(JSON.parse(h) as VerticalLine | HorizontalLine);\n      drawPointList(canvas, list);\n    } else {\n      for (const v of verticalLines)\n        drawVerticalLine(canvas, JSON.parse(v) as VerticalLine);\n      for (const h of horizontalLines)\n        drawHorizontalLine(canvas, JSON.parse(h) as HorizontalLine);\n    }\n  }\n  function mouseUp() {\n    verticalLines.clear();\n    horizontalLines.clear();\n    cacheMap.clear();\n    canvas.requestRenderAll();\n  }\n\n  canvas.on('object:resizing', scalingOrResizing);\n  canvas.on('object:scaling', scalingOrResizing);\n  canvas.on('object:moving', moving);\n  canvas.on('before:render', beforeRender);\n  canvas.on('after:render', afterRender);\n  canvas.on('mouse:up', mouseUp);\n\n  return () => {\n    canvas.off('object:resizing', scalingOrResizing);\n    canvas.off('object:scaling', scalingOrResizing);\n    canvas.off('object:moving', moving);\n    canvas.off('before:render', beforeRender);\n    canvas.off('after:render', afterRender);\n    canvas.off('mouse:up', mouseUp);\n  };\n}\n"],"names":["aligningLineConfig","margin","width","color","getDistance","a","b","Math","abs","collectLine","props","_activeObject$canvas$","_activeObject$canvas","aligningLineMargin","activeObject","activeObjectRect","objectRect","opts","target","list","makeLineByRect","aList","canvas","getZoom","vLines","arr","map","x","getDistanceLine","min","dis","lines","x2","height","y2","y","i","length","item","line","index","aLine","y1","max","push","setPos","centerX","centerY","dir","forEach","collectVerticalLine","hLines","x1","collectHorizontalLine","type","Infinity","v","rect","left","top","pos","center","translateToCenterPoint","position","translateToOriginPoint","originX","originY","setX","setY","setPositionDir","Point","setCoords","originXArr","originYArr","collectVerticalPoint","isScale","point","getDistanceList","scaleX","dim","_getTransformedDimensions","sx","set","dArr","reverse","d","indexOf","collectHorizontalPoint","_activeObject$canvas$2","_activeObject$canvas2","scaleY","sy","drawLine","origin","ctx","getSelectionContext","viewportTransform","zoom","save","transform","lineWidth","strokeStyle","beginPath","moveTo","lineTo","stroke","drawX","restore","xSize","size","translate","drawPointList","drawPoint","isVertical","drawVerticalLine","coords","drawHorizontalLine","getObjectsByTarget","shouldExclude","objects","Set","draggedObjects","ActiveSelection","getObjects","forEachObject","o","isOnScreen","visible","Group","collectObjectsByGroup","add","deleteObjectsByList","delete","g","children","child","constructor","originUpdaterWrapper","originalFn","defaultOriginX","arguments","undefined","defaultOriginY","async","serializedObject","_len","args","Array","_key","originalObject","call","this","actualPosition","setPositionByOrigin","options","Object","assign","horizontalLines","verticalLines","onlyDrawPoint","cacheMap","Map","getCaCheMapValue","object","cacheKey","calcTransformMatrix","toString","join","cacheValue","get","getCoords","value","util","makeBoundingBoxFromPoints","moving","e","clear","getBoundingRect","JSON","stringify","scalingOrResizing","String","action","startsWith","corner","flipX","replace","flipY","getTotalAngle","beforeRender","clearContext","contextTop","afterRender","parse","h","mouseUp","requestRenderAll","on","off","installOriginWrapperUpdater","BaseFabricObject","_fromObject","FabricImage","fromObject"],"mappings":"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"}