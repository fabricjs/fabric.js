{"version":3,"file":"fabric-extensions.min.js","sources":["../extensions/aligning_guidelines/util/basic.ts","../extensions/aligning_guidelines/util/collect-point.ts","../extensions/aligning_guidelines/util/draw.ts","../extensions/aligning_guidelines/util/collect-line.ts","../extensions/aligning_guidelines/util/get-objects-by-target.ts","../extensions/data_updaters/origins/index.ts","../extensions/data_updaters/gradient/index.ts","../extensions/westures_integration/index.ts","../extensions/cropping_controls/croppingHandlers.ts","../extensions/cropping_controls/croppingControls.ts","../extensions/aligning_guidelines/index.ts"],"sourcesContent":["import type { FabricObject, Point } from 'fabric';\nimport type { PointMap } from '../typedefs';\n\nexport function getDistance(a: number, b: number) {\n  return Math.abs(a - b);\n}\n\nexport function getDistanceList(point: Point, list: Point[], type: 'x' | 'y') {\n  let dis = Infinity;\n  let arr: Point[] = [];\n  for (const item of list) {\n    const v = getDistance(point[type], item[type]);\n    if (dis > v) {\n      arr = [];\n      dis = v;\n    }\n    if (dis == v) {\n      arr.push(item);\n    }\n  }\n  return { dis, arr };\n}\n\nexport function getPointMap(target: FabricObject): PointMap {\n  const coords = target.getCoords();\n  return {\n    tl: coords[0],\n    tr: coords[1],\n    br: coords[2],\n    bl: coords[3],\n    mt: coords[0].add(coords[1]).scalarDivide(2),\n    mr: coords[1].add(coords[2]).scalarDivide(2),\n    mb: coords[2].add(coords[3]).scalarDivide(2),\n    ml: coords[3].add(coords[0]).scalarDivide(2),\n  };\n}\n\nexport function getContraryMap(target: FabricObject): PointMap {\n  const aCoords = target.aCoords ?? target.calcACoords();\n  return {\n    tl: aCoords.br,\n    tr: aCoords.bl,\n    br: aCoords.tl,\n    bl: aCoords.tr,\n    mt: aCoords.br.add(aCoords.bl).scalarDivide(2),\n    mr: aCoords.bl.add(aCoords.tl).scalarDivide(2),\n    mb: aCoords.tl.add(aCoords.tr).scalarDivide(2),\n    ml: aCoords.tr.add(aCoords.br).scalarDivide(2),\n  };\n}\n","import type { FabricObject, Point } from 'fabric';\nimport type { AligningGuidelines } from '..';\nimport type { LineProps } from '../typedefs';\nimport { getDistanceList } from './basic';\n\ntype CollectPointProps = {\n  target: FabricObject;\n  /** Operation points of the target element: top-left, bottom-left, top-right, bottom-right */\n  point: Point;\n  /** Position using diagonal points when resizing/scaling. */\n  diagonalPoint: Point;\n  /** Set of points to consider for alignment: [tl, tr, br, bl, center] */\n  list: Point[];\n  /** Change the zoom or change the size, determine by whether e.transform.action starts with the string \"scale\" */\n  isScale: boolean;\n  /** Whether to change uniformly is determined by canvas.uniformScaling and canvas.uniScaleKey. */\n  isUniform: boolean;\n  /** When holding the centerKey (default is altKey), the shape will scale based on the center point, with the reference point being the center. */\n  isCenter: boolean;\n  /** tl、tr、br、bl、mt、mr、mb、ml */\n  corner: string;\n};\n\nexport function collectVerticalPoint(\n  this: AligningGuidelines,\n  props: CollectPointProps,\n): LineProps[] {\n  const {\n    target,\n    isScale,\n    isUniform,\n    corner,\n    point,\n    diagonalPoint,\n    list,\n    isCenter,\n  } = props;\n  const { dis, arr } = getDistanceList(point, list, 'x');\n  const margin = this.margin / this.canvas.getZoom();\n  if (dis > margin) return [];\n  let v = arr[arr.length - 1].x - point.x;\n  // tl bl ml\n  // If modifying on the left side, the size decreases; conversely, it increases.\n  const dirX = corner.includes('l') ? -1 : 1;\n  v *= dirX;\n\n  const { width, height, scaleX, scaleY } = target;\n  // Because when modifying through the center point, isUniform is always false, so skew does not need to be considered.\n  const dStrokeWidth = target.strokeUniform ? 0 : target.strokeWidth;\n  const scaleWidth = scaleX * width + dStrokeWidth;\n  const sx = (v + scaleWidth) / scaleWidth;\n  // When v equals -scaleWidth, sx equals 0.\n  if (sx == 0) return [];\n  if (isScale) {\n    target.set('scaleX', scaleX * sx);\n    if (isUniform) target.set('scaleY', scaleY * sx);\n  } else {\n    target.set('width', width * sx);\n    if (isUniform) target.set('height', height * sx);\n  }\n  if (isCenter) {\n    target.setRelativeXY(diagonalPoint, 'center', 'center');\n  } else {\n    const originArr = this.contraryOriginMap;\n    target.setRelativeXY(diagonalPoint, ...originArr[corner]);\n  }\n  target.setCoords();\n  return arr.map((target) => ({ origin: point, target }));\n}\n\nexport function collectHorizontalPoint(\n  this: AligningGuidelines,\n  props: CollectPointProps,\n): LineProps[] {\n  const {\n    target,\n    isScale,\n    isUniform,\n    corner,\n    point,\n    diagonalPoint,\n    list,\n    isCenter,\n  } = props;\n  const { dis, arr } = getDistanceList(point, list, 'y');\n  const margin = this.margin / this.canvas.getZoom();\n  if (dis > margin) return [];\n  let v = arr[arr.length - 1].y - point.y;\n  // tl mt tr\n  // If modifying on the top side, the size decreases; conversely, it increases.\n  const dirY = corner.includes('t') ? -1 : 1;\n  v *= dirY;\n\n  const { width, height, scaleX, scaleY } = target;\n  // Because when modifying through the center point, isUniform is always false, so skew does not need to be considered.\n  const dStrokeWidth = target.strokeUniform ? 0 : target.strokeWidth;\n  const scaleHeight = scaleY * height + dStrokeWidth;\n  const sy = (v + scaleHeight) / scaleHeight;\n  // When v equals -scaleHeight, sy equals 0.\n  if (sy == 0) return [];\n  if (isScale) {\n    target.set('scaleY', scaleY * sy);\n    if (isUniform) target.set('scaleX', scaleX * sy);\n  } else {\n    target.set('height', height * sy);\n    if (isUniform) target.set('width', width * sy);\n  }\n  if (isCenter) {\n    target.setRelativeXY(diagonalPoint, 'center', 'center');\n  } else {\n    const originArr = this.contraryOriginMap;\n    target.setRelativeXY(diagonalPoint, ...originArr[corner]);\n  }\n  target.setCoords();\n  return arr.map((target) => ({ origin: point, target }));\n}\n","import { Point } from 'fabric';\nimport type { AligningGuidelines } from '..';\n\nexport function drawLine(\n  this: AligningGuidelines,\n  origin: Point,\n  target: Point,\n) {\n  const ctx = this.canvas.getTopContext();\n  const viewportTransform = this.canvas.viewportTransform;\n  const zoom = this.canvas.getZoom();\n  ctx.save();\n  ctx.transform(...viewportTransform);\n  ctx.lineWidth = this.width / zoom;\n  if (this.lineDash) ctx.setLineDash(this.lineDash);\n  ctx.strokeStyle = this.color;\n  ctx.beginPath();\n  ctx.moveTo(origin.x, origin.y);\n  ctx.lineTo(target.x, target.y);\n  ctx.stroke();\n  if (this.lineDash) ctx.setLineDash([]);\n\n  this.drawX(origin, -1);\n  this.drawX(target, 1);\n  ctx.restore();\n}\n\nexport function drawX(this: AligningGuidelines, point: Point, _: number) {\n  const ctx = this.canvas.getTopContext();\n  const zoom = this.canvas.getZoom();\n  const size = this.xSize / zoom;\n  ctx.save();\n  ctx.translate(point.x, point.y);\n  ctx.beginPath();\n  ctx.moveTo(-size, -size);\n  ctx.lineTo(size, size);\n  ctx.moveTo(size, -size);\n  ctx.lineTo(-size, size);\n  ctx.stroke();\n  ctx.restore();\n}\nfunction drawPoint(this: AligningGuidelines, arr: Point[]) {\n  const ctx = this.canvas.getTopContext();\n  const viewportTransform = this.canvas.viewportTransform;\n  const zoom = this.canvas.getZoom();\n  ctx.save();\n  ctx.transform(...viewportTransform);\n  ctx.lineWidth = this.width / zoom;\n  ctx.strokeStyle = this.color;\n  for (const item of arr) this.drawX(item, 0);\n  ctx.restore();\n}\n\nexport function drawPointList(this: AligningGuidelines) {\n  const list = [];\n  if (!this.closeVLine) {\n    for (const v of this.verticalLines) list.push(JSON.parse(v));\n  }\n  if (!this.closeHLine) {\n    for (const h of this.horizontalLines) list.push(JSON.parse(h));\n  }\n  const arr = list.map((item) => item.target);\n  drawPoint.call(this, arr);\n}\n\nexport function drawVerticalLine(this: AligningGuidelines) {\n  if (this.closeVLine) return;\n\n  for (const v of this.verticalLines) {\n    const { origin, target } = JSON.parse(v);\n    const o = new Point(target.x, origin.y);\n    this.drawLine(o, target);\n  }\n}\n\nexport function drawHorizontalLine(this: AligningGuidelines) {\n  if (this.closeHLine) return;\n\n  for (const v of this.horizontalLines) {\n    const { origin, target } = JSON.parse(v);\n    const o = new Point(origin.x, target.y);\n    this.drawLine(o, target);\n  }\n}\n","import type { FabricObject, Point, TOriginX, TOriginY } from 'fabric';\nimport type { AligningGuidelines } from '..';\nimport type { LineProps } from '../typedefs';\nimport { getDistanceList } from './basic';\n\nexport function collectLine(\n  this: AligningGuidelines,\n  target: FabricObject,\n  points: Point[],\n) {\n  const list = target.getCoords();\n  list.push(target.getCenterPoint());\n  const margin = this.margin / this.canvas.getZoom();\n  const opts = { target, list, points, margin };\n  const vLines = collectPoints({ ...opts, type: 'x' });\n  const hLines = collectPoints({ ...opts, type: 'y' });\n\n  return { vLines, hLines };\n}\n\ntype CollectItemLineProps = {\n  target: FabricObject;\n  list: Point[];\n  points: Point[];\n  margin: number;\n  type: 'x' | 'y';\n};\nconst originArr: [TOriginX, TOriginY][] = [\n  ['left', 'top'],\n  ['right', 'top'],\n  ['right', 'bottom'],\n  ['left', 'bottom'],\n  ['center', 'center'],\n];\nfunction collectPoints(props: CollectItemLineProps) {\n  const { target, list, points, margin, type } = props;\n  const res: LineProps[] = [];\n  const arr: ReturnType<typeof getDistanceList>[] = [];\n  let min = Infinity;\n  for (const item of list) {\n    const o = getDistanceList(item, points, type);\n    arr.push(o);\n    if (min > o.dis) min = o.dis;\n  }\n  if (min > margin) return res;\n  let b = false;\n  for (let i = 0; i < list.length; i++) {\n    if (arr[i].dis != min) continue;\n    for (const item of arr[i].arr) {\n      res.push({ origin: list[i], target: item });\n    }\n\n    if (b) continue;\n    b = true;\n    const d = arr[i].arr[0][type] - list[i][type];\n    // It will change the original data, and the next time we collect y, use the modified data.\n    list.forEach((item) => {\n      item[type] += d;\n    });\n    target.setXY(list[i], ...originArr[i]);\n    target.setCoords();\n  }\n\n  return res;\n}\n","import type { FabricObject } from 'fabric';\nimport { ActiveSelection, Group } from 'fabric';\n\nexport function getObjectsByTarget(target: FabricObject) {\n  const objects = new Set<FabricObject>();\n  const canvas = target.canvas;\n  if (!canvas) return objects;\n  const children =\n    target instanceof ActiveSelection ? target.getObjects() : [target];\n\n  canvas.forEachObject((o) => {\n    if (!o.isOnScreen()) return;\n    if (!o.visible) return;\n    if (o.constructor == Group) {\n      collectObjectsByGroup(objects, o);\n      return;\n    }\n    objects.add(o);\n  });\n\n  deleteObjectsByList(objects, children);\n  return objects;\n}\n\nfunction deleteObjectsByList(objects: Set<FabricObject>, list: FabricObject[]) {\n  for (const target of list) {\n    if (target.constructor == Group) {\n      deleteObjectsByList(objects, (target as Group).getObjects());\n    } else {\n      objects.delete(target);\n    }\n  }\n}\n\nfunction collectObjectsByGroup(objects: Set<FabricObject>, g: Group) {\n  const children = g.getObjects();\n  for (const child of children) {\n    if (!child.visible) continue;\n    if (child.constructor == Group) {\n      collectObjectsByGroup(objects, child);\n      continue;\n    }\n    objects.add(child);\n  }\n}\n","import {\n  Point,\n  FabricImage,\n  Group,\n  BaseFabricObject,\n  type FabricObject,\n  type TOriginX,\n  type TOriginY,\n} from 'fabric';\n\n/**\n * Updates the fromObject function of a class to return a version that can restore old data\n * with values of originX and originY that are different from 'center', 'center'\n * Used to upgrade from fabric 6 to fabric 7\n * @param originalFn the original fromObject function of an object,\n * @param defaultOriginX optional default value for non exported originX,\n * @param defaultOriginY optional default value for non exported originY,\n * @returns a wrapped fromObject function for the object\n */\nexport const originUpdaterWrapper = <T extends FabricObject = FabricObject>(\n  originalFn: (...args: any[]) => Promise<T>,\n  defaultOriginX: TOriginX = 'left',\n  defaultOriginY: TOriginY = 'top',\n): ((...args: any[]) => Promise<T>) =>\n  async function (this: T, serializedObject, ...args) {\n    // we default to left and top because those are defaults before deprecation\n    const { originX = defaultOriginX, originY = defaultOriginY } =\n      serializedObject;\n    // and we do not want to pass those properties on the object anymore\n    delete serializedObject.originX;\n    delete serializedObject.originY;\n    const originalObject = await originalFn.call(\n      this,\n      serializedObject,\n      ...args,\n    );\n    const actualPosition = new Point(originalObject.left, originalObject.top);\n    originalObject.setPositionByOrigin(actualPosition, originX, originY);\n    return originalObject;\n  };\n\n/**\n * Wraps and override the current fabricJS fromObject static functions\n * Used to upgrade from fabric 7 to fabric 8\n * If you used to export with includeDefaultValues = false, you have to specify\n * which were yours default origins values\n * @param originX optional default value for non exported originX,\n * @param originY optional default value for non exported originY,\n */\nexport const installOriginWrapperUpdater = (\n  originX?: TOriginX,\n  originY?: TOriginY,\n) => {\n  // @ts-expect-error the _fromObject parameter could be instantiated differently\n  BaseFabricObject._fromObject = originUpdaterWrapper(\n    BaseFabricObject._fromObject,\n    originX,\n    originY,\n  );\n  // FabricImage and Group do not use _fromObject\n  FabricImage.fromObject = originUpdaterWrapper<FabricImage>(\n    FabricImage.fromObject,\n    originX,\n    originY,\n  );\n  Group.fromObject = originUpdaterWrapper<Group>(\n    Group.fromObject,\n    originX,\n    originY,\n  );\n};\n","import type { GradientOptions, ColorStop } from 'fabric';\nimport { Color, Gradient } from 'fabric';\n\n/**\n * Updates the fromObject function of a Gradient to return a version that can restore old data\n * with opactiy in color Stops\n * Used to upgrade from fabric 6 to fabric 7\n * @param originalFn the original fromObject function of an object,\n * @returns a wrapped fromObject function for the object\n */\n\ntype OldColorStop = ColorStop & {\n  opacity?: number;\n};\n\nexport const gradientUpdaterWrapper = <S, T extends Gradient<S> = Gradient<S>>(\n  originalFn: (\n    options: GradientOptions<'linear'> | GradientOptions<'radial'>,\n  ) => Promise<T>,\n): ((\n  options: GradientOptions<'linear'> | GradientOptions<'radial'>,\n) => Promise<T>) =>\n  async function (this: T, serializedGradient) {\n    // we default to left and top because those are defaults before deprecation\n    const { colorStops } = serializedGradient;\n    // and we do not want to pass those properties on the object anymore\n    const newColorStops: ColorStop[] = (\n      colorStops as OldColorStop[]\n    )?.map<ColorStop>(({ color, opacity, offset }) => {\n      if (opacity === undefined || opacity === 1) {\n        return {\n          color,\n          offset,\n        };\n      }\n      const col = new Color(color).setAlpha(opacity).toRgba();\n      return {\n        color: col,\n        offset,\n      };\n    });\n    const gradient = await originalFn.call(this, {\n      ...serializedGradient,\n      colorStops: newColorStops,\n    });\n    return gradient;\n  };\n\n/**\n * Wraps and override the current fabricJS fromObject static functions\n * Used to upgrade from fabric 7 to fabric 8\n * If you used to export with includeDefaultValues = false, you have to specify\n * which were yours default origins values\n */\nexport const installGradientUpdater = () => {\n  // @ts-expect-error untypable\n  Gradient.fromObject = gradientUpdaterWrapper(Gradient.fromObject);\n};\n","import wes from 'westures';\nimport { type Canvas, type CanvasEvents, type XY, util } from 'fabric';\n\ntype PinchEventData = {\n  centroid: XY;\n  event: PointerEvent;\n  phase: string;\n  type: 'pinch';\n  scale: number;\n  target: HTMLElement;\n};\n\ntype RotateEventData = {\n  centroid: XY;\n  event: PointerEvent;\n  phase: string;\n  type: 'rotate';\n  rotation: number;\n  target: HTMLElement;\n};\n\ntype TapEventData = {\n  centroid: XY;\n  event: PointerEvent;\n  phase: string;\n  type: 'tap';\n  target: HTMLElement;\n};\n\n/**\n * Register this handler on canvas.on('pinch', pinchEventHandler);\n * To get an out of the box functionality for the pinch to zoom\n */\nexport function pinchEventHandler(\n  this: Canvas,\n  { scale, target, scenePoint }: CanvasEvents['pinch'],\n) {\n  if (target && this.getActiveObject() === target) {\n    // if we are pinching on the active object, let's scale it\n    target.scaleX *= scale;\n    target.scaleY *= scale;\n  } else {\n    this.zoomToPoint(scenePoint, this.getZoom() * scale);\n  }\n}\n\nexport function rotateEventHandler(\n  this: Canvas,\n  { rotation, target }: CanvasEvents['rotate'],\n) {\n  if (target && this.getActiveObject() === target) {\n    target.rotate(target.angle + util.radiansToDegrees(rotation));\n  }\n}\n\nexport const tripleTapGesture = (canvas: Canvas) => {\n  return new wes.Tap(\n    canvas.upperCanvasEl,\n    ({ event }: TapEventData) => {\n      canvas.fireEventFromPointerEvent(\n        event,\n        'mouse:tripleclick',\n        'mousetripleclick',\n        undefined,\n      );\n      event.preventDefault();\n    },\n    {\n      numTaps: 3,\n      maxRetain: 400,\n    },\n  );\n};\n\nexport const doubleTapGesture = (canvas: Canvas) => {\n  return new wes.Tap(\n    canvas.upperCanvasEl,\n    ({ event }: TapEventData) => {\n      canvas.fireEventFromPointerEvent(\n        event,\n        'mouse:dblclick',\n        'mousedblclick',\n        undefined,\n      );\n      event.preventDefault();\n    },\n    {\n      numTaps: 2,\n      maxRetain: 300,\n    },\n  );\n};\n\nexport const pinchGesture = (canvas: Canvas) => {\n  return new wes.Pinch(\n    canvas.upperCanvasEl,\n    ({ scale, event }: PinchEventData) => {\n      canvas.fireEventFromPointerEvent(event, 'pinch', 'pinch', { scale });\n    },\n  );\n};\n\nexport const rotateGesture = (canvas: Canvas) => {\n  return new wes.Rotate(\n    canvas.upperCanvasEl,\n    ({ rotation, event }: RotateEventData) => {\n      canvas.fireEventFromPointerEvent(event, 'rotate', 'rotate', { rotation });\n    },\n  );\n};\n\n/**\n * Add a serie of gestures recognition on the canvas\n */\nexport const addGestures = (canvas: Canvas) => {\n  const canvasRegion = new wes.Region(canvas.upperCanvasEl);\n  canvas.addOrRemove(\n    (\n      el: HTMLElement,\n      ...args: Parameters<HTMLElement['removeEventListener']>\n    ) => el.removeEventListener(...args),\n  );\n  canvasRegion.addGesture(rotateGesture(canvas));\n  canvasRegion.addGesture(pinchGesture(canvas));\n  canvasRegion.addGesture(tripleTapGesture(canvas));\n  canvasRegion.addGesture(doubleTapGesture(canvas));\n  // add back events, excluding the click one\n  canvas.addOrRemove(\n    (el: HTMLElement, ...args: Parameters<HTMLElement['addEventListener']>) =>\n      el.addEventListener(...args),\n    true,\n  );\n};\n","import type { TModificationEvents } from 'fabric';\nimport { controlsUtils, type TransformActionHandler, type FabricImage } from 'fabric';\n\nconst { wrapWithFixedAnchor, wrapWithFireEvent } = controlsUtils;\n\n/**\n * Wrap controlsUtils.changeObjectWidth with image constrains\n */\nexport const changeImageWidth: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  const { target } = transform;\n  const { width } = target;\n  const image = target as FabricImage;\n  const modified = controlsUtils.changeObjectWidth(eventData, transform, x, y);\n  const availableWidth = image._element.width - image.cropX\n  if (modified) {\n    if (image.width > availableWidth) {\n      image.width =  availableWidth;\n    }\n    if (image.width < 0) {\n      image.width =  1;\n    }\n  }\n  return width != image.width;\n}\n\nexport const changeCropWidth = wrapWithFireEvent(\n  'CROPPING' as TModificationEvents,\n  wrapWithFixedAnchor(changeImageWidth),\n);\n\n/**\n * Wrap controlsUtils.changeObjectHeight with image constrains\n */\nexport const changeImageHeight: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  const { target } = transform;\n  const { height } = target;\n  const image = target as FabricImage;\n  const modified = controlsUtils.changeObjectHeight(eventData, transform, x, y);\n  const availableHeight = image._element.height - image.cropY\n  if (modified) {\n    if (image.height > availableHeight) {\n      image.height = availableHeight;\n    }\n    if (image.height < 0) {\n      image.height = 1;\n    }\n  }\n  return height != image.height;\n}\n\nexport const changeCropHeight = wrapWithFireEvent(\n  'CROPPING' as TModificationEvents,\n  wrapWithFixedAnchor(changeImageHeight),\n);\n\nexport const changeImageCropX: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  const { target } = transform;\n  const image = target as FabricImage;\n  const { width, cropX } = image;\n  const modified = controlsUtils.changeObjectWidth(eventData, transform, x, y);\n  let newCropX = cropX + width - image.width;\n  image.width = width;\n  if (modified) {\n    if (newCropX < 0) {\n      newCropX = 0;\n    }\n    if (newCropX + image.width > image._element.width) {\n      newCropX = image._element.width - image.width;\n    }\n    image.cropX = newCropX;\n    // calculate new width on the base of how much crop we have now\n    image.width += cropX - newCropX;\n  }\n  return newCropX != cropX;\n}\n\nexport const changeImageCropY: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  const { target } = transform;\n  const image = target as FabricImage;\n  const { height, cropY } = image;\n  const modified = controlsUtils.changeObjectHeight(eventData, transform, x, y);\n  let newCropY = cropY + height - image.height;\n  image.height = height;\n  if (modified) {\n    if (newCropY < 0) {\n      newCropY = 0;\n    }\n    if (newCropY + image.height > image._element.height) {\n      newCropY = image._element.height - image.height;\n    }\n    image.cropY = newCropY;\n    image.height += cropY - newCropY;\n  }\n  return newCropY != cropY;\n}\n\nexport const changeCropX = wrapWithFireEvent(\n  'CROPPING' as TModificationEvents,\n  wrapWithFixedAnchor(changeImageCropX),\n);\n\nexport const changeCropY = wrapWithFireEvent(\n  'CROPPING' as TModificationEvents,\n  wrapWithFixedAnchor(changeImageCropY),\n);\n\nexport const dragTransformHandler: TransformActionHandler = (\n  eventData,\n  transform,\n  x,\n  y,\n) => {\n  const { target, offsetX, offsetY } = transform;\n  let cropX = x - offsetX,\n      cropY = y - offsetY;\n    \n    const moved = target.cropX !== cropX || target.cropY !== cropY;\n    target.set({ cropX, cropY });\n    return moved;\n}","import { Control, controlsUtils } from \"fabric\";\nimport { changeCropHeight, changeCropWidth, changeCropX, changeCropY } from \"./croppingHandlers\";\n\nconst { scaleCursorStyleHandler } = controlsUtils;\n\nconst cropActionName = () => 'crop';\n// use this function if you want to generate new controls for every instance\nexport const createImageCroppingControls = () => ({\n  ml: new Control({\n    x: -0.5,\n    y: 0,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: changeCropX,\n    getActionName: cropActionName,\n  }),\n\n  mr: new Control({\n    x: 0.5,\n    y: 0,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: changeCropWidth,\n    getActionName: cropActionName,\n  }),\n\n  mb: new Control({\n    x: 0,\n    y: 0.5,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: changeCropHeight,\n    getActionName: cropActionName,\n  }),\n\n  mt: new Control({\n    x: 0,\n    y: -0.5,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: changeCropY,\n    getActionName: cropActionName,\n  }),\n\n  tl: new Control({\n    x: -0.5,\n    y: -0.5,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: (...args) => {\n      const cropX = changeCropX(...args);\n      const cropY = changeCropY(...args);\n      return cropX || cropY;\n    },\n    getActionName: cropActionName,\n  }),\n\n  tr: new Control({\n    x: 0.5,\n    y: -0.5,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: (...args) => {\n      const width = changeCropWidth(...args);\n      const cropY = changeCropY(...args);\n      return width || cropY;\n    },\n    getActionName: cropActionName,\n  }),\n\n  bl: new Control({\n    x: -0.5,\n    y: 0.5,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: (...args) => {\n      const height = changeCropHeight(...args);\n      const cropX = changeCropX(...args);\n      return height || cropX;\n    },\n    getActionName: cropActionName,\n  }),\n\n  br: new Control({\n    x: 0.5,\n    y: 0.5,\n    cursorStyleHandler: scaleCursorStyleHandler,\n    actionHandler: (...args) => {\n      const height = changeCropHeight(...args);\n      const width = changeCropWidth(...args);\n      return height || width;\n    },\n    getActionName: cropActionName,\n  }),\n\n  // dragHandler: dragTransformHandler,\n});","import {\n  type BasicTransformEvent,\n  type Canvas,\n  type FabricObject,\n  type TPointerEvent,\n  type Point,\n  util,\n} from 'fabric';\nimport {\n  collectHorizontalPoint,\n  collectVerticalPoint,\n} from './util/collect-point';\nimport {\n  drawHorizontalLine,\n  drawLine,\n  drawPointList,\n  drawVerticalLine,\n  drawX,\n} from './util/draw';\nimport { collectLine } from './util/collect-line';\nimport type { AligningLineConfig, OriginMap } from './typedefs';\nimport { getObjectsByTarget } from './util/get-objects-by-target';\nimport { getContraryMap, getPointMap } from './util/basic';\n\ntype TransformEvent = BasicTransformEvent<TPointerEvent> & {\n  target: FabricObject;\n};\n\nexport class AligningGuidelines {\n  canvas: Canvas;\n  horizontalLines = new Set<string>();\n  verticalLines = new Set<string>();\n  cacheMap = new Map<string, Point[]>();\n  /**\n   * When we drag to resize using center points like mt, ml, mb, and mr,\n   * we do not need to draw line segments; we only need to draw the target points.\n   */\n  onlyDrawPoint = false;\n  /** Alignment method is required when customizing. */\n  contraryOriginMap: OriginMap = {\n    tl: ['right', 'bottom'],\n    tr: ['left', 'bottom'],\n    br: ['left', 'top'],\n    bl: ['right', 'top'],\n    mt: ['center', 'bottom'],\n    mr: ['left', 'center'],\n    mb: ['center', 'top'],\n    ml: ['right', 'center'],\n  };\n  xSize = 2.4;\n  lineDash: number[] | undefined;\n  /** At what distance from the shape does alignment begin? */\n  margin = 4;\n  /** Aligning line dimensions */\n  width = 1;\n  /** Aligning line color */\n  color = 'rgba(255,0,0,0.9)';\n  /** Close Vertical line, default false. */\n  closeVLine = false;\n  /** Close horizontal line, default false. */\n  closeHLine = false;\n\n  constructor(canvas: Canvas, options: Partial<AligningLineConfig> = {}) {\n    this.canvas = canvas;\n    Object.assign(this, options);\n\n    this.mouseUp = this.mouseUp.bind(this);\n    this.scalingOrResizing = this.scalingOrResizing.bind(this);\n    this.moving = this.moving.bind(this);\n    this.beforeRender = this.beforeRender.bind(this);\n    this.afterRender = this.afterRender.bind(this);\n\n    this.initBehavior();\n  }\n  initBehavior() {\n    this.canvas.on('mouse:up', this.mouseUp);\n    this.canvas.on('object:resizing', this.scalingOrResizing);\n    this.canvas.on('object:scaling', this.scalingOrResizing);\n    this.canvas.on('object:moving', this.moving);\n    this.canvas.on('before:render', this.beforeRender);\n    this.canvas.on('after:render', this.afterRender);\n  }\n  /** Returns shapes that can draw aligning lines, default returns all shapes on the canvas excluding groups. */\n  getObjectsByTarget(target: FabricObject) {\n    return getObjectsByTarget(target);\n  }\n  /** When the user customizes the controller, this property is set to enable or disable automatic alignment through point scaling/resizing. */\n  getPointMap(target: FabricObject) {\n    return getPointMap(target);\n  }\n  /** When the user customizes the controller, this property is used to enable or disable alignment positioning through points. */\n  getContraryMap(target: FabricObject) {\n    return getContraryMap(target);\n  }\n  /** Users can customize. */\n  getCaCheMapValue(object: FabricObject) {\n    const cacheKey = [\n      object.calcTransformMatrix().toString(),\n      object.width,\n      object.height,\n    ].join();\n    const cacheValue = this.cacheMap.get(cacheKey);\n    if (cacheValue) return cacheValue;\n    const value = object.getCoords();\n    value.push(object.getCenterPoint());\n    this.cacheMap.set(cacheKey, value);\n    return value;\n  }\n  drawLine(origin: Point, target: Point) {\n    drawLine.call(this, origin, target);\n  }\n  drawX(point: Point, dir: number) {\n    drawX.call(this, point, dir);\n  }\n  mouseUp() {\n    this.verticalLines.clear();\n    this.horizontalLines.clear();\n    this.cacheMap.clear();\n    this.canvas.requestRenderAll();\n  }\n\n  scalingOrResizing(e: TransformEvent) {\n    const target = e.target;\n    // We need to obtain the real-time coordinates of the current object, so we need to update them in real-time\n    target.setCoords();\n    // The value of action can be scaleX, scaleY, scale, resize, etc.\n    // If it does not start with \"scale,\" it is considered a modification of size.\n    const isScale = String(e.transform.action).startsWith('scale');\n    this.verticalLines.clear();\n    this.horizontalLines.clear();\n\n    const objects = this.getObjectsByTarget(target);\n    // When the shape is flipped, the tl obtained through getCoords is actually tr,\n    // and tl is actually tr. We need to make correction adjustments.\n    // tr <-> tl、 bl <-> br、  mb <-> mt、 ml <-> mr\n    let corner = e.transform.corner;\n    if (target.flipX) {\n      if (corner.includes('l')) corner = corner.replace('l', 'r');\n      else if (corner.includes('r')) corner = corner.replace('r', 'l');\n    }\n    if (target.flipY) {\n      if (corner.includes('t')) corner = corner.replace('t', 'b');\n      else if (corner.includes('b')) corner = corner.replace('b', 't');\n    }\n\n    // Obtain the coordinates of the current operation point through the value of corner.\n    // users can be allowed to customize and pass in custom corners.\n    const pointMap = this.getPointMap(target);\n    if (!(corner in pointMap)) return;\n    this.onlyDrawPoint = corner.includes('m');\n    if (this.onlyDrawPoint) {\n      const angle = target.getTotalAngle();\n      // When the shape is rotated, it is meaningless to draw points using the center point.\n      if (angle % 90 != 0) return;\n    }\n    // If manipulating tl, then when the shape changes size, it should be positioned by br,\n    // and the same applies to others.\n    // users can be allowed to customize and pass in custom corners.\n    const contraryMap = this.getContraryMap(target);\n    const point = pointMap[corner];\n    let diagonalPoint = contraryMap[corner];\n    // When holding the centerKey (default is altKey), the shape will scale based on the center point, with the reference point being the center.\n    const isCenter =\n      e.transform.original.originX == 'center' &&\n      e.transform.original.originY == 'center';\n    if (isCenter) {\n      const p = target.group\n        ? point.transform(\n            util.invertTransform(target.group.calcTransformMatrix()),\n          )\n        : point;\n      diagonalPoint = diagonalPoint.add(p).scalarDivide(2);\n    }\n    const uniformIsToggled = e.e[this.canvas.uniScaleKey!];\n    let isUniform =\n      (this.canvas.uniformScaling && !uniformIsToggled) ||\n      (!this.canvas.uniformScaling && uniformIsToggled);\n    // When controlling through the center point,\n    // if isUniform is true, it actually changes the skew, so it is meaningless.\n    if (this.onlyDrawPoint) isUniform = false;\n\n    const list: Point[] = [];\n    for (const object of objects) {\n      const d = this.getCaCheMapValue(object);\n      list.push(...d);\n    }\n\n    const props = {\n      target,\n      point,\n      diagonalPoint,\n      corner,\n      list,\n      isScale,\n      isUniform,\n      isCenter,\n    };\n\n    // Obtain horizontal and vertical reference lines.\n    const noNeedToCollectV =\n      this.onlyDrawPoint && (corner.includes('t') || corner.includes('b'));\n    const noNeedToCollectH =\n      this.onlyDrawPoint && (corner.includes('l') || corner.includes('r'));\n    const vList = noNeedToCollectV\n      ? []\n      : collectVerticalPoint.call(this, props);\n    const hList = noNeedToCollectH\n      ? []\n      : collectHorizontalPoint.call(this, props);\n    vList.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.verticalLines.add(JSON.stringify(o));\n    });\n    hList.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.horizontalLines.add(JSON.stringify(o));\n    });\n  }\n  moving(e: TransformEvent) {\n    const target = e.target;\n    // We need to obtain the real-time coordinates of the current object, so we need to update them in real-time\n    target.setCoords();\n    this.onlyDrawPoint = false;\n    this.verticalLines.clear();\n    this.horizontalLines.clear();\n\n    // Find the shapes associated with the current graphic to draw reference lines for it.\n    const objects = this.getObjectsByTarget(target);\n    const points: Point[] = [];\n    // Collect all the points to draw reference lines.\n    for (const object of objects) points.push(...this.getCaCheMapValue(object));\n\n    // Obtain horizontal and vertical reference lines.\n    const { vLines, hLines } = collectLine.call(this, target, points);\n    vLines.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.verticalLines.add(JSON.stringify(o));\n    });\n    hLines.forEach((o) => {\n      // Objects cannot be deduplicated; convert them to strings for deduplication.\n      this.horizontalLines.add(JSON.stringify(o));\n    });\n  }\n  beforeRender() {\n    this.canvas.clearContext(this.canvas.contextTop);\n  }\n  afterRender() {\n    if (this.onlyDrawPoint) {\n      drawPointList.call(this);\n    } else {\n      drawVerticalLine.call(this);\n      drawHorizontalLine.call(this);\n    }\n  }\n\n  dispose() {\n    this.canvas.off('mouse:up', this.mouseUp);\n    this.canvas.off('object:resizing', this.scalingOrResizing);\n    this.canvas.off('object:scaling', this.scalingOrResizing);\n    this.canvas.off('object:moving', this.moving);\n    this.canvas.off('before:render', this.beforeRender);\n    this.canvas.off('after:render', this.afterRender);\n  }\n}\n"],"names":["getDistance","a","b","Math","abs","getDistanceList","point","list","type","dis","Infinity","arr","item","v","push","collectVerticalPoint","props","target","isScale","isUniform","corner","diagonalPoint","isCenter","this","margin","canvas","getZoom","length","x","includes","width","height","scaleX","scaleY","scaleWidth","strokeUniform","strokeWidth","sx","set","setRelativeXY","originArr","contraryOriginMap","setCoords","map","origin","collectHorizontalPoint","y","scaleHeight","sy","drawLine","ctx","getTopContext","viewportTransform","zoom","save","transform","lineWidth","lineDash","setLineDash","strokeStyle","color","beginPath","moveTo","lineTo","stroke","drawX","restore","_","size","xSize","translate","drawPoint","drawPointList","closeVLine","verticalLines","JSON","parse","closeHLine","h","horizontalLines","call","drawVerticalLine","o","Point","drawHorizontalLine","collectLine","points","getCoords","getCenterPoint","opts","vLines","collectPoints","hLines","res","min","i","d","forEach","setXY","getObjectsByTarget","objects","Set","children","ActiveSelection","getObjects","forEachObject","isOnScreen","visible","constructor","Group","add","collectObjectsByGroup","deleteObjectsByList","delete","g","child","originUpdaterWrapper","originalFn","defaultOriginX","arguments","undefined","defaultOriginY","async","serializedObject","originX","originY","_len","args","Array","_key","originalObject","actualPosition","left","top","setPositionByOrigin","gradientUpdaterWrapper","serializedGradient","colorStops","newColorStops","_ref","opacity","offset","Color","setAlpha","toRgba","wrapWithFixedAnchor","wrapWithFireEvent","controlsUtils","changeCropWidth","changeImageWidth","eventData","image","modified","changeObjectWidth","availableWidth","_element","cropX","changeCropHeight","changeImageHeight","changeObjectHeight","availableHeight","cropY","changeCropX","changeImageCropX","newCropX","changeCropY","changeImageCropY","newCropY","scaleCursorStyleHandler","cropActionName","options","_defineProperty","Map","tl","tr","br","bl","mt","mr","mb","ml","Object","assign","mouseUp","bind","scalingOrResizing","moving","beforeRender","afterRender","initBehavior","on","getPointMap","coords","scalarDivide","getContraryMap","_target$aCoords","aCoords","calcACoords","getCaCheMapValue","object","cacheKey","calcTransformMatrix","toString","join","cacheValue","cacheMap","get","value","dir","clear","requestRenderAll","e","String","action","startsWith","flipX","replace","flipY","pointMap","onlyDrawPoint","getTotalAngle","contraryMap","original","p","group","util","invertTransform","uniformIsToggled","uniScaleKey","uniformScaling","noNeedToCollectV","noNeedToCollectH","vList","hList","stringify","clearContext","contextTop","dispose","off","canvasRegion","wes","Region","upperCanvasEl","addOrRemove","el","removeEventListener","addGesture","Rotate","_ref6","rotation","event","fireEventFromPointerEvent","rotateGesture","Pinch","_ref5","scale","pinchGesture","Tap","_ref3","preventDefault","numTaps","maxRetain","tripleTapGesture","_ref4","doubleTapGesture","_len2","_key2","addEventListener","createImageCroppingControls","Control","cursorStyleHandler","actionHandler","getActionName","installGradientUpdater","Gradient","fromObject","installOriginWrapperUpdater","BaseFabricObject","_fromObject","FabricImage","scenePoint","getActiveObject","zoomToPoint","_ref2","rotate","angle","radiansToDegrees"],"mappings":"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"}