{"version":3,"file":"parseCoords.min.mjs","sources":["../../../../src/gradient/parser/parseCoords.ts"],"sourcesContent":["import { isPercent } from '../../parser/percent';\nimport type { TSize } from '../../typedefs';\nimport type { GradientCoords, GradientType, GradientUnits } from '../typedefs';\nimport { parseGradientUnits, parseType } from './misc';\n\nfunction convertPercentUnitsToValues<\n  T extends GradientType,\n  K extends keyof GradientCoords<T>,\n>(\n  valuesToConvert: Record<K, string | number>,\n  { width, height, gradientUnits }: TSize & { gradientUnits: GradientUnits },\n) {\n  let finalValue;\n  return (Object.keys(valuesToConvert) as K[]).reduce(\n    (acc, prop) => {\n      const propValue = valuesToConvert[prop];\n      if (propValue === 'Infinity') {\n        finalValue = 1;\n      } else if (propValue === '-Infinity') {\n        finalValue = 0;\n      } else {\n        finalValue =\n          typeof propValue === 'string' ? parseFloat(propValue) : propValue;\n        if (typeof propValue === 'string' && isPercent(propValue)) {\n          finalValue *= 0.01;\n          if (gradientUnits === 'pixels') {\n            // then we need to fix those percentages here in svg parsing\n            if (prop === 'x1' || prop === 'x2' || prop === 'r2') {\n              finalValue *= width;\n            }\n            if (prop === 'y1' || prop === 'y2') {\n              finalValue *= height;\n            }\n          }\n        }\n      }\n      acc[prop] = finalValue;\n      return acc;\n    },\n    {} as Record<K, number>,\n  );\n}\n\nfunction getValue(el: SVGGradientElement, key: string) {\n  return el.getAttribute(key);\n}\n\nexport function parseLinearCoords(el: SVGGradientElement) {\n  return {\n    x1: getValue(el, 'x1') || 0,\n    y1: getValue(el, 'y1') || 0,\n    x2: getValue(el, 'x2') || '100%',\n    y2: getValue(el, 'y2') || 0,\n  };\n}\n\nexport function parseRadialCoords(el: SVGGradientElement) {\n  return {\n    x1: getValue(el, 'fx') || getValue(el, 'cx') || '50%',\n    y1: getValue(el, 'fy') || getValue(el, 'cy') || '50%',\n    r1: 0,\n    x2: getValue(el, 'cx') || '50%',\n    y2: getValue(el, 'cy') || '50%',\n    r2: getValue(el, 'r') || '50%',\n  };\n}\n\nexport function parseCoords(el: SVGGradientElement, size: TSize) {\n  return convertPercentUnitsToValues(\n    parseType(el) === 'linear' ? parseLinearCoords(el) : parseRadialCoords(el),\n    {\n      ...size,\n      gradientUnits: parseGradientUnits(el),\n    },\n  );\n}\n"],"names":["getValue","el","key","getAttribute","parseLinearCoords","x1","y1","x2","y2","parseRadialCoords","r1","r2","parseCoords","size","valuesToConvert","_ref","finalValue","width","height","gradientUnits","Object","keys","reduce","acc","prop","propValue","parseFloat","isPercent","convertPercentUnitsToValues","parseType","_objectSpread","parseGradientUnits"],"mappings":"gNA2CA,SAASA,EAASC,EAAwBC,GACxC,OAAOD,EAAGE,aAAaD,EACzB,CAEO,SAASE,EAAkBH,GAChC,MAAO,CACLI,GAAIL,EAASC,EAAI,OAAS,EAC1BK,GAAIN,EAASC,EAAI,OAAS,EAC1BM,GAAIP,EAASC,EAAI,OAAS,OAC1BO,GAAIR,EAASC,EAAI,OAAS,EAE9B,CAEO,SAASQ,EAAkBR,GAChC,MAAO,CACLI,GAAIL,EAASC,EAAI,OAASD,EAASC,EAAI,OAAS,MAChDK,GAAIN,EAASC,EAAI,OAASD,EAASC,EAAI,OAAS,MAChDS,GAAI,EACJH,GAAIP,EAASC,EAAI,OAAS,MAC1BO,GAAIR,EAASC,EAAI,OAAS,MAC1BU,GAAIX,EAASC,EAAI,MAAQ,MAE7B,CAEO,SAASW,EAAYX,EAAwBY,GAClD,OA/DF,SAIEC,EAA2CC,GAE3C,IACIC,GAFJC,MAAEA,EAAKC,OAAEA,EAAMC,cAAEA,GAAyDJ,EAG1E,OAAQK,OAAOC,KAAKP,GAAyBQ,QAC3C,CAACC,EAAKC,KACJ,MAAMC,EAAYX,EAAgBU,GAsBlC,MArBkB,aAAdC,EACFT,EAAa,EACU,cAAdS,EACTT,EAAa,GAEbA,EACuB,iBAAdS,EAAyBC,WAAWD,GAAaA,EACjC,iBAAdA,GAA0BE,EAAUF,KAC7CT,GAAc,IACQ,WAAlBG,IAEW,OAATK,GAA0B,OAATA,GAA0B,OAATA,IACpCR,GAAcC,GAEH,OAATO,GAA0B,OAATA,IACnBR,GAAcE,MAKtBK,EAAIC,GAAQR,EACLO,CAAG,GAEZ,CACF,EACF,CA2BSK,CACa,WAAlBC,EAAU5B,GAAmBG,EAAkBH,GAAMQ,EAAkBR,GAAG6B,EAAAA,EAAA,CAAA,EAErEjB,GAAI,GAAA,CACPM,cAAeY,EAAmB9B,KAGxC"}