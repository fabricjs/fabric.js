{"version":3,"file":"Gradient.min.mjs","sources":["../../../src/gradient/Gradient.ts"],"sourcesContent":["import { Color } from '../color/Color';\nimport { iMatrix } from '../constants';\nimport { parseTransformAttribute } from '../parser/parseTransformAttribute';\nimport type { FabricObject } from '../shapes/Object/FabricObject';\nimport type { TMat2D } from '../typedefs';\nimport { uid } from '../util/internals/uid';\nimport { pick } from '../util/misc/pick';\nimport { matrixToSVG } from '../util/misc/svgParsing';\nimport { linearDefaultCoords, radialDefaultCoords } from './constants';\nimport { parseColorStops } from './parser/parseColorStops';\nimport { parseCoords } from './parser/parseCoords';\nimport { parseType, parseGradientUnits } from './parser/misc';\nimport type {\n  ColorStop,\n  GradientCoords,\n  GradientOptions,\n  GradientType,\n  GradientUnits,\n  SVGOptions,\n} from './typedefs';\nimport { classRegistry } from '../ClassRegistry';\nimport { isPath } from '../util/typeAssertions';\n\n/**\n * Gradient class\n * @class Gradient\n * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}\n */\nexport class Gradient<\n  S,\n  T extends GradientType = S extends GradientType ? S : 'linear',\n> {\n  /**\n   * Horizontal offset for aligning gradients coming from SVG when outside pathgroups\n   * @type Number\n   * @default 0\n   */\n  declare offsetX: number;\n\n  /**\n   * Vertical offset for aligning gradients coming from SVG when outside pathgroups\n   * @type Number\n   * @default 0\n   */\n  declare offsetY: number;\n\n  /**\n   * A transform matrix to apply to the gradient before painting.\n   * Imported from svg gradients, is not applied with the current transform in the center.\n   * Before this transform is applied, the origin point is at the top left corner of the object\n   * plus the addition of offsetY and offsetX.\n   * @type Number[]\n   * @default null\n   */\n  declare gradientTransform?: TMat2D;\n\n  /**\n   * coordinates units for coords.\n   * If `pixels`, the number of coords are in the same unit of width / height.\n   * If set as `percentage` the coords are still a number, but 1 means 100% of width\n   * for the X and 100% of the height for the y. It can be bigger than 1 and negative.\n   * allowed values pixels or percentage.\n   * @type GradientUnits\n   * @default 'pixels'\n   */\n  declare gradientUnits: GradientUnits;\n\n  /**\n   * Gradient type linear or radial\n   * @type GradientType\n   * @default 'linear'\n   */\n  declare type: T;\n\n  /**\n   * Defines how the gradient is located in space and spread\n   * @type GradientCoords\n   */\n  declare coords: GradientCoords<T>;\n\n  /**\n   * Defines how many colors a gradient has and how they are located on the axis\n   * defined by coords\n   * @type GradientCoords\n   */\n  declare colorStops: ColorStop[];\n\n  /**\n   * If true, this object will not be exported during the serialization of a canvas\n   * @type boolean\n   */\n  declare excludeFromExport?: boolean;\n\n  /**\n   * ID used for SVG export functionalities\n   * @type number | string\n   */\n  declare readonly id: string | number;\n\n  static type = 'Gradient';\n\n  constructor(options: GradientOptions<T>) {\n    const {\n      type = 'linear' as T,\n      gradientUnits = 'pixels',\n      coords = {},\n      colorStops = [],\n      offsetX = 0,\n      offsetY = 0,\n      gradientTransform,\n      id,\n    } = options || {};\n    Object.assign(this, {\n      type,\n      gradientUnits,\n      coords: {\n        ...(type === 'radial' ? radialDefaultCoords : linearDefaultCoords),\n        ...coords,\n      },\n      colorStops,\n      offsetX,\n      offsetY,\n      gradientTransform,\n      id: id ? `${id}_${uid()}` : uid(),\n    });\n  }\n\n  /**\n   * Adds another colorStop\n   * @param {Record<string, string>} colorStop Object with offset and color\n   * @return {Gradient} thisArg\n   */\n  addColorStop(colorStops: Record<string, string>) {\n    for (const position in colorStops) {\n      const color = new Color(colorStops[position]);\n      this.colorStops.push({\n        offset: parseFloat(position),\n        color: color.toRgb(),\n        opacity: color.getAlpha(),\n      });\n    }\n    return this;\n  }\n\n  /**\n   * Returns object representation of a gradient\n   * @param {string[]} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @return {object}\n   */\n  toObject(propertiesToInclude?: (keyof this | string)[]) {\n    return {\n      ...pick(this, propertiesToInclude as (keyof this)[]),\n      type: this.type,\n      coords: { ...this.coords },\n      colorStops: this.colorStops.map((colorStop) => ({ ...colorStop })),\n      offsetX: this.offsetX,\n      offsetY: this.offsetY,\n      gradientUnits: this.gradientUnits,\n      gradientTransform: this.gradientTransform\n        ? [...this.gradientTransform]\n        : undefined,\n    };\n  }\n\n  /* _TO_SVG_START_ */\n  /**\n   * Returns SVG representation of an gradient\n   * @param {FabricObject} object Object to create a gradient for\n   * @return {String} SVG representation of an gradient (linear/radial)\n   */\n  toSVG(\n    object: FabricObject,\n    {\n      additionalTransform: preTransform,\n    }: { additionalTransform?: string } = {},\n  ) {\n    const markup = [],\n      transform = (\n        this.gradientTransform\n          ? this.gradientTransform.concat()\n          : iMatrix.concat()\n      ) as TMat2D,\n      gradientUnits =\n        this.gradientUnits === 'pixels'\n          ? 'userSpaceOnUse'\n          : 'objectBoundingBox';\n    // colorStops must be sorted ascending, and guarded against deep mutations\n    const colorStops = this.colorStops\n      .map((colorStop) => ({ ...colorStop }))\n      .sort((a, b) => {\n        return a.offset - b.offset;\n      });\n\n    let offsetX = -this.offsetX,\n      offsetY = -this.offsetY;\n    if (gradientUnits === 'objectBoundingBox') {\n      offsetX /= object.width;\n      offsetY /= object.height;\n    } else {\n      offsetX += object.width / 2;\n      offsetY += object.height / 2;\n    }\n    // todo what about polygon/polyline?\n    if (isPath(object) && this.gradientUnits !== 'percentage') {\n      offsetX -= object.pathOffset.x;\n      offsetY -= object.pathOffset.y;\n    }\n    transform[4] -= offsetX;\n    transform[5] -= offsetY;\n\n    const commonAttributes = [\n      `id=\"SVGID_${this.id}\"`,\n      `gradientUnits=\"${gradientUnits}\"`,\n      `gradientTransform=\"${\n        preTransform ? preTransform + ' ' : ''\n      }${matrixToSVG(transform)}\"`,\n      '',\n    ].join(' ');\n\n    if (this.type === 'linear') {\n      const { x1, y1, x2, y2 } = this.coords;\n      markup.push(\n        '<linearGradient ',\n        commonAttributes,\n        ' x1=\"',\n        x1,\n        '\" y1=\"',\n        y1,\n        '\" x2=\"',\n        x2,\n        '\" y2=\"',\n        y2,\n        '\">\\n',\n      );\n    } else if (this.type === 'radial') {\n      const { x1, y1, x2, y2, r1, r2 } = this\n        .coords as GradientCoords<'radial'>;\n      const needsSwap = r1 > r2;\n      // svg radial gradient has just 1 radius. the biggest.\n      markup.push(\n        '<radialGradient ',\n        commonAttributes,\n        ' cx=\"',\n        needsSwap ? x1 : x2,\n        '\" cy=\"',\n        needsSwap ? y1 : y2,\n        '\" r=\"',\n        needsSwap ? r1 : r2,\n        '\" fx=\"',\n        needsSwap ? x2 : x1,\n        '\" fy=\"',\n        needsSwap ? y2 : y1,\n        '\">\\n',\n      );\n      if (needsSwap) {\n        // svg goes from internal to external radius. if radius are inverted, swap color stops.\n        colorStops.reverse(); //  mutates array\n        colorStops.forEach((colorStop) => {\n          colorStop.offset = 1 - colorStop.offset;\n        });\n      }\n      const minRadius = Math.min(r1, r2);\n      if (minRadius > 0) {\n        // i have to shift all colorStops and add new one in 0.\n        const maxRadius = Math.max(r1, r2),\n          percentageShift = minRadius / maxRadius;\n        colorStops.forEach((colorStop) => {\n          colorStop.offset += percentageShift * (1 - colorStop.offset);\n        });\n      }\n    }\n\n    colorStops.forEach(({ color, offset, opacity }) => {\n      markup.push(\n        '<stop ',\n        'offset=\"',\n        offset * 100 + '%',\n        '\" style=\"stop-color:',\n        color,\n        typeof opacity !== 'undefined' ? ';stop-opacity: ' + opacity : ';',\n        '\"/>\\n',\n      );\n    });\n\n    markup.push(\n      this.type === 'linear' ? '</linearGradient>' : '</radialGradient>',\n      '\\n',\n    );\n\n    return markup.join('');\n  }\n  /* _TO_SVG_END_ */\n\n  /**\n   * Returns an instance of CanvasGradient\n   * @param {CanvasRenderingContext2D} ctx Context to render on\n   * @return {CanvasGradient}\n   */\n  toLive(ctx: CanvasRenderingContext2D): CanvasGradient {\n    const { x1, y1, x2, y2, r1, r2 } = this.coords as GradientCoords<'radial'>;\n    const gradient =\n      this.type === 'linear'\n        ? ctx.createLinearGradient(x1, y1, x2, y2)\n        : ctx.createRadialGradient(x1, y1, r1, x2, y2, r2);\n\n    this.colorStops.forEach(({ color, opacity, offset }) => {\n      gradient.addColorStop(\n        offset,\n        typeof opacity !== 'undefined'\n          ? new Color(color).setAlpha(opacity).toRgba()\n          : color,\n      );\n    });\n\n    return gradient;\n  }\n\n  static async fromObject(\n    options: GradientOptions<'linear'>,\n  ): Promise<Gradient<'radial'>>;\n  static async fromObject(\n    options: GradientOptions<'radial'>,\n  ): Promise<Gradient<'radial'>>;\n  static async fromObject(\n    options: GradientOptions<'linear'> | GradientOptions<'radial'>,\n  ) {\n    const { colorStops, gradientTransform } = options;\n    return new this({\n      ...options,\n      colorStops: colorStops\n        ? colorStops.map((colorStop) => ({ ...colorStop }))\n        : undefined,\n      gradientTransform: gradientTransform ? [...gradientTransform] : undefined,\n    });\n  }\n\n  /* _FROM_SVG_START_ */\n  /**\n   * Returns {@link Gradient} instance from an SVG element\n   * @static\n   * @memberOf Gradient\n   * @param {SVGGradientElement} el SVG gradient element\n   * @param {FabricObject} instance\n   * @param {String} opacity A fill-opacity or stroke-opacity attribute to multiply to each stop's opacity.\n   * @param {SVGOptions} svgOptions an object containing the size of the SVG in order to parse correctly gradients\n   * that uses gradientUnits as 'userSpaceOnUse' and percentages.\n   * @return {Gradient} Gradient instance\n   * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement\n   * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement\n   *\n   *  @example\n   *\n   *  <linearGradient id=\"linearGrad1\">\n   *    <stop offset=\"0%\" stop-color=\"white\"/>\n   *    <stop offset=\"100%\" stop-color=\"black\"/>\n   *  </linearGradient>\n   *\n   *  OR\n   *\n   *  <linearGradient id=\"linearGrad2\">\n   *    <stop offset=\"0\" style=\"stop-color:rgb(255,255,255)\"/>\n   *    <stop offset=\"1\" style=\"stop-color:rgb(0,0,0)\"/>\n   *  </linearGradient>\n   *\n   *  OR\n   *\n   *  <radialGradient id=\"radialGrad1\">\n   *    <stop offset=\"0%\" stop-color=\"white\" stop-opacity=\"1\" />\n   *    <stop offset=\"50%\" stop-color=\"black\" stop-opacity=\"0.5\" />\n   *    <stop offset=\"100%\" stop-color=\"white\" stop-opacity=\"1\" />\n   *  </radialGradient>\n   *\n   *  OR\n   *\n   *  <radialGradient id=\"radialGrad2\">\n   *    <stop offset=\"0\" stop-color=\"rgb(255,255,255)\" />\n   *    <stop offset=\"0.5\" stop-color=\"rgb(0,0,0)\" />\n   *    <stop offset=\"1\" stop-color=\"rgb(255,255,255)\" />\n   *  </radialGradient>\n   *\n   */\n  static fromElement(\n    el: SVGGradientElement,\n    instance: FabricObject,\n    svgOptions: SVGOptions,\n  ): Gradient<GradientType> {\n    const gradientUnits = parseGradientUnits(el);\n    const center = instance._findCenterFromElement();\n    return new this({\n      id: el.getAttribute('id') || undefined,\n      type: parseType(el),\n      coords: parseCoords(el, {\n        width: svgOptions.viewBoxWidth || svgOptions.width,\n        height: svgOptions.viewBoxHeight || svgOptions.height,\n      }),\n      colorStops: parseColorStops(el, svgOptions.opacity),\n      gradientUnits,\n      gradientTransform: parseTransformAttribute(\n        el.getAttribute('gradientTransform') || '',\n      ),\n      ...(gradientUnits === 'pixels'\n        ? {\n            offsetX: instance.width / 2 - center.x,\n            offsetY: instance.height / 2 - center.y,\n          }\n        : {\n            offsetX: 0,\n            offsetY: 0,\n          }),\n    });\n  }\n  /* _FROM_SVG_END_ */\n}\n\nclassRegistry.setClass(Gradient, 'gradient');\nclassRegistry.setClass(Gradient, 'linear');\nclassRegistry.setClass(Gradient, 'radial');\n"],"names":["Gradient","constructor","options","type","gradientUnits","coords","colorStops","offsetX","offsetY","gradientTransform","id","Object","assign","this","_objectSpread","radialDefaultCoords","linearDefaultCoords","concat","uid","addColorStop","position","color","Color","push","offset","parseFloat","toRgb","opacity","getAlpha","toObject","propertiesToInclude","pick","map","colorStop","undefined","toSVG","object","additionalTransform","preTransform","arguments","length","markup","transform","iMatrix","sort","a","b","width","height","isPath","pathOffset","x","y","commonAttributes","matrixToSVG","join","x1","y1","x2","y2","r1","r2","needsSwap","reverse","forEach","minRadius","Math","min","percentageShift","max","_ref","toLive","ctx","gradient","createLinearGradient","createRadialGradient","_ref2","setAlpha","toRgba","fromObject","fromElement","el","instance","svgOptions","parseGradientUnits","center","_findCenterFromElement","getAttribute","parseType","parseCoords","viewBoxWidth","viewBoxHeight","parseColorStops","parseTransformAttribute","_defineProperty","classRegistry","setClass"],"mappings":"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"}