{"version":3,"file":"index.min.mjs","sources":["../../../../../src/util/misc/projectStroke/index.ts"],"sourcesContent":["import { Point, type XY } from '../../../Point';\nimport { findIndexRight } from '../../internals/findRight';\nimport { StrokeLineCapProjections } from './StrokeLineCapProjections';\nimport { StrokeLineJoinProjections } from './StrokeLineJoinProjections';\nimport type { TProjection, TProjectStrokeOnPointsOptions } from './types';\n\nexport * from './types';\n\n/**\n *\n * Used to calculate object's bounding box\n *\n * @see https://github.com/fabricjs/fabric.js/pull/8344\n *\n */\nexport const projectStrokeOnPoints = (\n  points: XY[],\n  options: TProjectStrokeOnPointsOptions,\n  openPath = false,\n): TProjection[] => {\n  const projections: TProjection[] = [];\n\n  if (points.length === 0) {\n    return projections;\n  }\n\n  // first we remove duplicate neighboring points\n  const reduced = points.reduce(\n    (reduced, point) => {\n      if (!reduced[reduced.length - 1].eq(point)) {\n        reduced.push(new Point(point));\n      }\n      return reduced;\n    },\n    [new Point(points[0])],\n  );\n\n  if (reduced.length === 1) {\n    openPath = true;\n  } else if (!openPath) {\n    // remove points from end in case they equal the first point\n    // in order to correctly project the first point\n    const start = reduced[0];\n    const index = findIndexRight(reduced, (point) => !point.eq(start));\n    reduced.splice(index + 1);\n  }\n\n  reduced.forEach((A, index, points) => {\n    let B: XY, C: XY;\n    if (index === 0) {\n      C = points[1];\n      B = openPath ? A : points[points.length - 1];\n    } else if (index === points.length - 1) {\n      B = points[index - 1];\n      C = openPath ? A : points[0];\n    } else {\n      B = points[index - 1];\n      C = points[index + 1];\n    }\n\n    if (openPath && points.length === 1) {\n      projections.push(\n        ...new StrokeLineCapProjections(A, A, options).project(),\n      );\n    } else if (openPath && (index === 0 || index === points.length - 1)) {\n      projections.push(\n        ...new StrokeLineCapProjections(\n          A,\n          index === 0 ? C : B,\n          options,\n        ).project(),\n      );\n    } else {\n      projections.push(\n        ...new StrokeLineJoinProjections(A, B, C, options).project(),\n      );\n    }\n  });\n\n  return projections;\n};\n"],"names":["projectStrokeOnPoints","points","options","openPath","arguments","length","undefined","projections","reduced","reduce","point","eq","push","Point","start","index","findIndexRight","splice","forEach","A","B","C","StrokeLineCapProjections","project","StrokeLineJoinProjections"],"mappings":"gRAeO,MAAMA,EAAwB,SACnCC,EACAC,GAEkB,IADlBC,EAAQC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GAER,MAAMG,EAA6B,GAEnC,GAAsB,IAAlBN,EAAOI,OACT,OAAOE,EAIT,MAAMC,EAAUP,EAAOQ,QACrB,CAACD,EAASE,KACHF,EAAQA,EAAQH,OAAS,GAAGM,GAAGD,IAClCF,EAAQI,KAAK,IAAIC,EAAMH,IAElBF,IAET,CAAC,IAAIK,EAAMZ,EAAO,MAGpB,GAAuB,IAAnBO,EAAQH,OACVF,GAAW,OACN,IAAKA,EAAU,CAGpB,MAAMW,EAAQN,EAAQ,GAChBO,EAAQC,EAAeR,GAAUE,IAAWA,EAAMC,GAAGG,KAC3DN,EAAQS,OAAOF,EAAQ,EACzB,CAkCA,OAhCAP,EAAQU,SAAQ,CAACC,EAAGJ,EAAOd,KACzB,IAAImB,EAAOC,EACG,IAAVN,GACFM,EAAIpB,EAAO,GACXmB,EAAIjB,EAAWgB,EAAIlB,EAAOA,EAAOI,OAAS,IACjCU,IAAUd,EAAOI,OAAS,GACnCe,EAAInB,EAAOc,EAAQ,GACnBM,EAAIlB,EAAWgB,EAAIlB,EAAO,KAE1BmB,EAAInB,EAAOc,EAAQ,GACnBM,EAAIpB,EAAOc,EAAQ,IAGjBZ,GAA8B,IAAlBF,EAAOI,OACrBE,EAAYK,QACP,IAAIU,EAAyBH,EAAGA,EAAGjB,GAASqB,YAExCpB,GAAuB,IAAVY,GAAeA,IAAUd,EAAOI,OAAS,EAS/DE,EAAYK,QACP,IAAIY,EAA0BL,EAAGC,EAAGC,EAAGnB,GAASqB,WATrDhB,EAAYK,QACP,IAAIU,EACLH,EACU,IAAVJ,EAAcM,EAAID,EAClBlB,GACAqB,UAMN,IAGKhB,CACT"}