{"version":3,"file":"mergeClipPaths.mjs","sources":["../../../../src/util/misc/mergeClipPaths.ts"],"sourcesContent":["import type { FabricObject } from '../../shapes/Object/FabricObject';\nimport { sendObjectToPlane } from './planeChange';\nimport { Group } from '../../shapes/Group';\n/**\n * Merges 2 clip paths into one visually equal clip path\n *\n * **IMPORTANT**:\\\n * Does **NOT** clone the arguments, clone them proir if necessary.\n *\n * Creates a wrapper (group) that contains one clip path and is clipped by the other so content is kept where both overlap.\n * Use this method if both the clip paths may have nested clip paths of their own, so assigning one to the other's clip path property is not possible.\n *\n * In order to handle the `inverted` property we follow logic described in the following cases:\\\n * **(1)** both clip paths are inverted - the clip paths pass the inverted prop to the wrapper and loose it themselves.\\\n * **(2)** one is inverted and the other isn't - the wrapper shouldn't become inverted and the inverted clip path must clip the non inverted one to produce an identical visual effect.\\\n * **(3)** both clip paths are not inverted - wrapper and clip paths remain unchanged.\n *\n * @memberOf fabric.util\n * @param {fabric.Object} c1\n * @param {fabric.Object} c2\n * @returns {fabric.Object} merged clip path\n */\nexport const mergeClipPaths = (c1: FabricObject, c2: FabricObject) => {\n  let a = c1,\n    b = c2;\n  if (a.inverted && !b.inverted) {\n    //  case (2)\n    a = c2;\n    b = c1;\n  }\n  //  `b` becomes `a`'s clip path so we transform `b` to `a` coordinate plane\n  sendObjectToPlane(b, b.group?.calcTransformMatrix(), a.calcTransformMatrix());\n  //  assign the `inverted` prop to the wrapping group\n  const inverted = a.inverted && b.inverted;\n  if (inverted) {\n    //  case (1)\n    a.inverted = b.inverted = false;\n  }\n  return new Group([a], { clipPath: b, inverted });\n};\n"],"names":["mergeClipPaths","c1","c2","_b$group","a","b","inverted","sendObjectToPlane","group","calcTransformMatrix","Group","clipPath"],"mappings":";;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACaA,cAAc,GAAGA,CAACC,EAAgB,EAAEC,EAAgB,KAAK;AAAA,EAAA,IAAAC,QAAA,CAAA;EACpE,IAAIC,CAAC,GAAGH,EAAE;AACRI,IAAAA,CAAC,GAAGH,EAAE,CAAA;EACR,IAAIE,CAAC,CAACE,QAAQ,IAAI,CAACD,CAAC,CAACC,QAAQ,EAAE;AAC7B;AACAF,IAAAA,CAAC,GAAGF,EAAE,CAAA;AACNG,IAAAA,CAAC,GAAGJ,EAAE,CAAA;AACR,GAAA;AACA;EACAM,iBAAiB,CAACF,CAAC,EAAAF,CAAAA,QAAA,GAAEE,CAAC,CAACG,KAAK,MAAA,IAAA,IAAAL,QAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAPA,QAAA,CAASM,mBAAmB,EAAE,EAAEL,CAAC,CAACK,mBAAmB,EAAE,CAAC,CAAA;AAC7E;EACA,MAAMH,QAAQ,GAAGF,CAAC,CAACE,QAAQ,IAAID,CAAC,CAACC,QAAQ,CAAA;AACzC,EAAA,IAAIA,QAAQ,EAAE;AACZ;AACAF,IAAAA,CAAC,CAACE,QAAQ,GAAGD,CAAC,CAACC,QAAQ,GAAG,KAAK,CAAA;AACjC,GAAA;AACA,EAAA,OAAO,IAAII,KAAK,CAAC,CAACN,CAAC,CAAC,EAAE;AAAEO,IAAAA,QAAQ,EAAEN,CAAC;AAAEC,IAAAA,QAAAA;AAAS,GAAC,CAAC,CAAA;AAClD;;;;"}