{"version":3,"file":"loadSVGFromURL.mjs","sources":["../../../src/parser/loadSVGFromURL.ts"],"sourcesContent":["import { request } from '../util/internals/dom_request';\nimport { parseSVGDocument, createEmptyResponse } from './parseSVGDocument';\nimport type { SVGParsingOutput, TSvgReviverCallback } from './typedefs';\nimport type { LoadImageOptions } from '../util/misc/objectEnlive';\n\n/**\n * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.\n * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)\n * @memberOf fabric\n * @param {string} url where the SVG is\n * @param {TSvgParsedCallback} callback Invoked when the parsing is done, with null if parsing wasn't possible with the list of svg nodes.\n * {@link TSvgParsedCallback} also receives `allElements` array as the last argument. This is the full list of svg nodes available in the document.\n * You may want to use it if you are trying to regroup the objects as they were originally grouped in the SVG. ( This was the reason why it was added )\n * @param {TSvgReviverCallback} [reviver] Extra callback for further parsing of SVG elements, called after each fabric object has been created.\n * Takes as input the original svg element and the generated `FabricObject` as arguments. Used to inspect extra properties not parsed by fabric,\n * or extra custom manipulation\n * @param {Object} [options] Object containing options for parsing\n * @param {String} [options.crossOrigin] crossOrigin setting to use for external resources\n * @param {AbortSignal} [options.signal] handle aborting, see https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal\n */\nexport function loadSVGFromURL(\n  url: string,\n  reviver?: TSvgReviverCallback,\n  options: LoadImageOptions = {},\n): Promise<SVGParsingOutput> {\n  // need to handle error properly\n  return new Promise<Document>((resolve, reject) => {\n    const onComplete = (r: XMLHttpRequest) => {\n      const xml = r.responseXML;\n      if (xml) {\n        resolve(xml);\n      }\n      reject();\n    };\n\n    request(url.replace(/^\\n\\s*/, '').trim(), {\n      onComplete,\n      signal: options.signal,\n    });\n  })\n    .then((parsedDoc) => parseSVGDocument(parsedDoc, reviver, options))\n    .catch(() => {\n      // this is an unhappy path, we dont care about speed\n      return createEmptyResponse();\n    });\n}\n"],"names":["loadSVGFromURL","url","reviver","options","arguments","length","undefined","Promise","resolve","reject","onComplete","r","xml","responseXML","request","replace","trim","signal","then","parsedDoc","parseSVGDocument","catch","createEmptyResponse"],"mappings":";;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,cAAcA,CAC5BC,GAAW,EACXC,OAA6B,EAEF;AAAA,EAAA,IAD3BC,OAAyB,GAAAC,SAAA,CAAAC,MAAA,GAAA,CAAA,IAAAD,SAAA,CAAA,CAAA,CAAA,KAAAE,SAAA,GAAAF,SAAA,CAAA,CAAA,CAAA,GAAG,EAAE,CAAA;AAE9B;AACA,EAAA,OAAO,IAAIG,OAAO,CAAW,CAACC,OAAO,EAAEC,MAAM,KAAK;IAChD,MAAMC,UAAU,GAAIC,CAAiB,IAAK;AACxC,MAAA,MAAMC,GAAG,GAAGD,CAAC,CAACE,WAAW,CAAA;AACzB,MAAA,IAAID,GAAG,EAAE;QACPJ,OAAO,CAACI,GAAG,CAAC,CAAA;AACd,OAAA;AACAH,MAAAA,MAAM,EAAE,CAAA;KACT,CAAA;AAEDK,IAAAA,OAAO,CAACb,GAAG,CAACc,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAACC,IAAI,EAAE,EAAE;MACxCN,UAAU;MACVO,MAAM,EAAEd,OAAO,CAACc,MAAAA;AAClB,KAAC,CAAC,CAAA;AACJ,GAAC,CAAC,CACCC,IAAI,CAAEC,SAAS,IAAKC,gBAAgB,CAACD,SAAS,EAAEjB,OAAO,EAAEC,OAAO,CAAC,CAAC,CAClEkB,KAAK,CAAC,MAAM;AACX;IACA,OAAOC,mBAAmB,EAAE,CAAA;AAC9B,GAAC,CAAC,CAAA;AACN;;;;"}