{"version":3,"file":"getCSSRules.min.mjs","sources":["../../../src/parser/getCSSRules.ts"],"sourcesContent":["import type { CSSRules } from './typedefs';\n\n/**\n * Returns CSS rules for a given SVG document\n * @param {HTMLElement} doc SVG document to parse\n * @return {Object} CSS rules of this document\n */\nexport function getCSSRules(doc: Document) {\n  const styles = doc.getElementsByTagName('style');\n  let i;\n  let len;\n  const allRules: CSSRules = {};\n\n  // very crude parsing of style contents\n  for (i = 0, len = styles.length; i < len; i++) {\n    const styleContents = (styles[i].textContent || '').replace(\n      // remove comments\n      /\\/\\*[\\s\\S]*?\\*\\//g,\n      '',\n    );\n\n    if (styleContents.trim() === '') {\n      continue;\n    }\n    // recovers all the rule in this form `body { style code... }`\n    // rules = styleContents.match(/[^{]*\\{[\\s\\S]*?\\}/g);\n    styleContents\n      .split('}')\n      // remove empty rules and remove everything if we didn't split in at least 2 pieces\n      .filter((rule, index, array) => array.length > 1 && rule.trim())\n      // at this point we have hopefully an array of rules `body { style code... `\n      .forEach((rule) => {\n        // if there is more than one opening bracket and the rule starts with '@', it is likely\n        // a nested at-rule like @media, @supports, @scope, etc. Ignore these as the code below\n        // can not handle it.\n        if (\n          (rule.match(/{/g) || []).length > 1 &&\n          rule.trim().startsWith('@')\n        ) {\n          return;\n        }\n\n        const match = rule.split('{'),\n          ruleObj: Record<string, string> = {},\n          declaration = match[1].trim(),\n          propertyValuePairs = declaration.split(';').filter(function (pair) {\n            return pair.trim();\n          });\n\n        for (i = 0, len = propertyValuePairs.length; i < len; i++) {\n          const pair = propertyValuePairs[i].split(':'),\n            property = pair[0].trim(),\n            value = pair[1].trim();\n          ruleObj[property] = value;\n        }\n        rule = match[0].trim();\n        rule.split(',').forEach((_rule) => {\n          _rule = _rule.replace(/^svg/i, '').trim();\n          if (_rule === '') {\n            return;\n          }\n          allRules[_rule] = {\n            ...(allRules[_rule] || {}),\n            ...ruleObj,\n          };\n        });\n      });\n  }\n  return allRules;\n}\n"],"names":["getCSSRules","doc","styles","getElementsByTagName","i","len","allRules","length","styleContents","textContent","replace","trim","split","filter","rule","index","array","forEach","match","startsWith","ruleObj","propertyValuePairs","pair","property","value","_rule","_objectSpread"],"mappings":"iFAOO,SAASA,EAAYC,GAC1B,MAAMC,EAASD,EAAIE,qBAAqB,SACxC,IAAIC,EACAC,EACJ,MAAMC,EAAqB,CAAA,EAG3B,IAAKF,EAAI,EAAGC,EAAMH,EAAOK,OAAQH,EAAIC,EAAKD,IAAK,CAC7C,MAAMI,GAAiBN,EAAOE,GAAGK,aAAe,IAAIC,QAElD,oBACA,IAG2B,KAAzBF,EAAcG,QAKlBH,EACGI,MAAM,KAENC,QAAO,CAACC,EAAMC,EAAOC,IAAUA,EAAMT,OAAS,GAAKO,EAAKH,SAExDM,SAASH,IAIR,IACGA,EAAKI,MAAM,OAAS,IAAIX,OAAS,GAClCO,EAAKH,OAAOQ,WAAW,KAEvB,OAGF,MAAMD,EAAQJ,EAAKF,MAAM,KACvBQ,EAAkC,CAAE,EAEpCC,EADcH,EAAM,GAAGP,OACUC,MAAM,KAAKC,QAAO,SAAUS,GAC3D,OAAOA,EAAKX,MACd,IAEF,IAAKP,EAAI,EAAGC,EAAMgB,EAAmBd,OAAQH,EAAIC,EAAKD,IAAK,CACzD,MAAMkB,EAAOD,EAAmBjB,GAAGQ,MAAM,KACvCW,EAAWD,EAAK,GAAGX,OACnBa,EAAQF,EAAK,GAAGX,OAClBS,EAAQG,GAAYC,CACtB,EACAV,EAAOI,EAAM,GAAGP,QACXC,MAAM,KAAKK,SAASQ,IAET,MADdA,EAAQA,EAAMf,QAAQ,QAAS,IAAIC,UAInCL,EAASmB,GAAMC,EAAAA,EAAA,CAAA,EACTpB,EAASmB,IAAU,IACpBL,GACJ,GACD,GAER,CACA,OAAOd,CACT"}