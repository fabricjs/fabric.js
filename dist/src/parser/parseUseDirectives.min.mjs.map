{"version":3,"file":"parseUseDirectives.min.mjs","sources":["../../../src/parser/parseUseDirectives.ts"],"sourcesContent":["import { svgNS } from './constants';\nimport { getMultipleNodes } from './getMultipleNodes';\nimport { applyViewboxTransform } from './applyViewboxTransform';\nimport { parseStyleString } from './parseStyleString';\n\nexport function parseUseDirectives(doc: Document) {\n  const nodelist = getMultipleNodes(doc, ['use', 'svg:use']);\n  const skipAttributes = ['x', 'y', 'xlink:href', 'href', 'transform'];\n\n  for (const useElement of nodelist) {\n    const useAttributes: NamedNodeMap = useElement.attributes;\n\n    const useAttrMap: Record<string, string> = {};\n    for (const attr of useAttributes) {\n      attr.value && (useAttrMap[attr.name] = attr.value);\n    }\n\n    const xlink = (useAttrMap['xlink:href'] || useAttrMap.href || '').slice(1);\n\n    if (xlink === '') {\n      return;\n    }\n    const referencedElement = doc.getElementById(xlink);\n    if (referencedElement === null) {\n      // if we can't find the target of the xlink, consider this use tag bad, similar to no xlink\n      return;\n    }\n    let clonedOriginal = referencedElement.cloneNode(true) as Element;\n\n    const originalAttributes: NamedNodeMap = clonedOriginal.attributes;\n\n    const originalAttrMap: Record<string, string> = {};\n    for (const attr of originalAttributes) {\n      attr.value && (originalAttrMap[attr.name] = attr.value);\n    }\n\n    // Transform attribute needs to be merged in a particular way\n    const { x = 0, y = 0, transform = '' } = useAttrMap;\n    const currentTrans = `${transform} ${\n      originalAttrMap.transform || ''\n    } translate(${x}, ${y})`;\n\n    applyViewboxTransform(clonedOriginal);\n\n    if (/^svg$/i.test(clonedOriginal.nodeName)) {\n      // if is an SVG, create a group and apply all the attributes on top of it\n      const el3 = clonedOriginal.ownerDocument.createElementNS(svgNS, 'g');\n      Object.entries(originalAttrMap).forEach(([name, value]) =>\n        el3.setAttributeNS(svgNS, name, value),\n      );\n      el3.append(...clonedOriginal.childNodes);\n      clonedOriginal = el3;\n    }\n\n    for (const attr of useAttributes) {\n      if (!attr) {\n        continue;\n      }\n      const { name, value } = attr;\n      if (skipAttributes.includes(name)) {\n        continue;\n      }\n\n      if (name === 'style') {\n        // when use has a style, merge the two styles, with the ref being priority (not use)\n        // priority is by feature. an attribute for fill on the original element\n        // will overwrite the fill in style or attribute for tha use\n        const styleRecord: Record<string, any> = {};\n        parseStyleString(value!, styleRecord);\n        // cleanup styleRecord from attributes of original\n        Object.entries(originalAttrMap).forEach(([name, value]) => {\n          styleRecord[name] = value;\n        });\n        // now we can put in the style of the original that will overwrite the original attributes\n        parseStyleString(originalAttrMap.style || '', styleRecord);\n        const mergedStyles = Object.entries(styleRecord)\n          .map((entry) => entry.join(':'))\n          .join(';');\n        clonedOriginal.setAttribute(name, mergedStyles);\n      } else {\n        // set the attribute from use element only if the original does not have it already\n        !originalAttrMap[name] && clonedOriginal.setAttribute(name, value!);\n      }\n    }\n\n    clonedOriginal.setAttribute('transform', currentTrans);\n    clonedOriginal.setAttribute('instantiated_by_use', '1');\n    clonedOriginal.removeAttribute('id');\n    useElement.parentNode!.replaceChild(clonedOriginal, useElement);\n  }\n}\n"],"names":["parseUseDirectives","doc","nodelist","getMultipleNodes","skipAttributes","useElement","useAttributes","attributes","useAttrMap","attr","value","name","xlink","href","slice","referencedElement","getElementById","clonedOriginal","cloneNode","originalAttributes","originalAttrMap","x","y","transform","currentTrans","concat","applyViewboxTransform","test","nodeName","el3","ownerDocument","createElementNS","svgNS","Object","entries","forEach","_ref","setAttributeNS","append","childNodes","includes","styleRecord","parseStyleString","_ref2","style","mergedStyles","map","entry","join","setAttribute","removeAttribute","parentNode","replaceChild"],"mappings":"gPAKO,SAASA,EAAmBC,GACjC,MAAMC,EAAWC,EAAiBF,EAAK,CAAC,MAAO,YACzCG,EAAiB,CAAC,IAAK,IAAK,aAAc,OAAQ,aAExD,IAAK,MAAMC,KAAcH,EAAU,CACjC,MAAMI,EAA8BD,EAAWE,WAEzCC,EAAqC,CAAA,EAC3C,IAAK,MAAMC,KAAQH,EACjBG,EAAKC,QAAUF,EAAWC,EAAKE,MAAQF,EAAKC,OAG9C,MAAME,GAASJ,EAAW,eAAiBA,EAAWK,MAAQ,IAAIC,MAAM,GAExE,GAAc,KAAVF,EACF,OAEF,MAAMG,EAAoBd,EAAIe,eAAeJ,GAC7C,GAA0B,OAAtBG,EAEF,OAEF,IAAIE,EAAiBF,EAAkBG,WAAU,GAEjD,MAAMC,EAAmCF,EAAeV,WAElDa,EAA0C,CAAA,EAChD,IAAK,MAAMX,KAAQU,EACjBV,EAAKC,QAAUU,EAAgBX,EAAKE,MAAQF,EAAKC,OAInD,MAAMW,EAAEA,EAAI,EAACC,EAAEA,EAAI,EAACC,UAAEA,EAAY,IAAOf,EACnCgB,KAAYC,OAAMF,EAASE,KAAAA,OAC/BL,EAAgBG,WAAa,kBAAEE,OACnBJ,EAACI,MAAAA,OAAKH,EAAI,KAIxB,GAFAI,EAAsBT,GAElB,SAASU,KAAKV,EAAeW,UAAW,CAE1C,MAAMC,EAAMZ,EAAea,cAAcC,gBAAgBC,EAAO,KAChEC,OAAOC,QAAQd,GAAiBe,SAAQC,IAAA,IAAEzB,EAAMD,GAAM0B,EAAA,OACpDP,EAAIQ,eAAeL,EAAOrB,EAAMD,EAAM,IAExCmB,EAAIS,UAAUrB,EAAesB,YAC7BtB,EAAiBY,CACnB,CAEA,IAAK,MAAMpB,KAAQH,EAAe,CAChC,IAAKG,EACH,SAEF,MAAME,KAAEA,EAAID,MAAEA,GAAUD,EACxB,IAAIL,EAAeoC,SAAS7B,GAI5B,GAAa,UAATA,EAAkB,CAIpB,MAAM8B,EAAmC,CAAA,EACzCC,EAAiBhC,EAAQ+B,GAEzBR,OAAOC,QAAQd,GAAiBe,SAAQQ,IAAmB,IAAjBhC,EAAMD,GAAMiC,EACpDF,EAAY9B,GAAQD,CAAK,IAG3BgC,EAAiBtB,EAAgBwB,OAAS,GAAIH,GAC9C,MAAMI,EAAeZ,OAAOC,QAAQO,GACjCK,KAAKC,GAAUA,EAAMC,KAAK,OAC1BA,KAAK,KACR/B,EAAegC,aAAatC,EAAMkC,EACpC,MAEGzB,EAAgBT,IAASM,EAAegC,aAAatC,EAAMD,EAEhE,CAEAO,EAAegC,aAAa,YAAazB,GACzCP,EAAegC,aAAa,sBAAuB,KACnDhC,EAAeiC,gBAAgB,MAC/B7C,EAAW8C,WAAYC,aAAanC,EAAgBZ,EACtD,CACF"}