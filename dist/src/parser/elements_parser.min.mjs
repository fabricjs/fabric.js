import{objectSpread2 as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{Gradient as e}from"../gradient/Gradient.min.mjs";import{Group as i}from"../shapes/Group.min.mjs";import{FabricImage as s}from"../shapes/Image.min.mjs";import{classRegistry as r}from"../ClassRegistry.min.mjs";import{invertTransform as n,multiplyTransformMatrices as a,qrDecompose as o}from"../util/misc/matrix.min.mjs";import{removeTransformMatrixForSvgParsing as m}from"../util/transform_matrix_removal.min.mjs";import{Point as l}from"../Point.min.mjs";import{FILL as c,STROKE as p,CENTER as h}from"../constants.min.mjs";import{getGradientDefs as f}from"./getGradientDefs.min.mjs";import{getCSSRules as u}from"./getCSSRules.min.mjs";import{getTagName as g}from"./getTagName.min.mjs";import{parseTransformAttribute as P}from"./parseTransformAttribute.min.mjs";const j=t=>r.getSVGClass(g(t).toLowerCase());class d{constructor(t,e,i,s,r){this.elements=t,this.options=e,this.reviver=i,this.regexUrl=/^url\(['"]?#([^'"]+)['"]?\)/g,this.doc=s,this.clipPaths=r,this.gradientDefs=f(s),this.cssRules=u(s)}parse(){return Promise.all(this.elements.map((t=>this.createObject(t))))}async createObject(t){const e=j(t);if(e){const i=await e.fromElement(t,this.options,this.cssRules);return this.resolveGradient(i,t,c),this.resolveGradient(i,t,p),i instanceof s&&i._originalElement?m(i,i.parsePreserveAspectRatioAttribute()):m(i),await this.resolveClipPath(i,t),this.reviver&&this.reviver(t,i),i}return null}extractPropertyDefinition(t,e,i){const s=t[e],r=this.regexUrl;if(!r.test(s))return;r.lastIndex=0;const n=r.exec(s)[1];return r.lastIndex=0,i[n]}resolveGradient(i,s,r){const n=this.extractPropertyDefinition(i,r,this.gradientDefs);if(n){const a=s.getAttribute(r+"-opacity"),o=e.fromElement(n,i,t(t({},this.options),{},{opacity:a}));i.set(r,o)}}async resolveClipPath(t,e){const s=this.extractPropertyDefinition(t,"clipPath",this.clipPaths);if(s){const r=n(t.calcTransformMatrix()),c=s[0].parentElement;let p=e;for(;p.parentElement&&p.getAttribute("clip-path")!==t.clipPath;)p=p.parentElement;p.parentElement.appendChild(c);const f=P("".concat(p.getAttribute("transform")||""," ").concat(c.getAttribute("originalTransform")||""));c.setAttribute("transform","matrix(".concat(f.join(","),")"));const u=await Promise.all(s.map((t=>j(t).fromElement(t,this.options,this.cssRules).then((t=>(m(t),t.fillRule=t.clipRule,delete t.clipRule,t)))))),g=1===u.length?u[0]:new i(u),d=a(r,g.calcTransformMatrix());g.clipPath&&await this.resolveClipPath(g,p);const{scaleX:v,scaleY:x,angle:b,skewX:w,translateX:y,translateY:R}=o(d);g.set({flipX:!1,flipY:!1}),g.set({scaleX:v,scaleY:x,angle:b,skewX:w,skewY:0}),g.setPositionByOrigin(new l(y,R),h,h),t.clipPath=g}else delete t.clipPath}}export{d as ElementsParser};
//# sourceMappingURL=elements_parser.min.mjs.map
