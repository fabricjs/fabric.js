{"version":3,"file":"parseSVGDocument.min.mjs","sources":["../../../src/parser/parseSVGDocument.ts"],"sourcesContent":["import { applyViewboxTransform } from './applyViewboxTransform';\nimport { svgValidTagNamesRegEx } from './constants';\nimport { hasInvalidAncestor } from './hasInvalidAncestor';\nimport { parseUseDirectives } from './parseUseDirectives';\nimport type { SVGParsingOutput, TSvgReviverCallback } from './typedefs';\nimport type { LoadImageOptions } from '../util/misc/objectEnlive';\nimport { ElementsParser } from './elements_parser';\nimport { log, SignalAbortedError } from '../util/internals/console';\nimport { getTagName } from './getTagName';\n\nconst isValidSvgTag = (el: Element) =>\n  svgValidTagNamesRegEx.test(getTagName(el));\n\nexport const createEmptyResponse = (): SVGParsingOutput => ({\n  objects: [],\n  elements: [],\n  options: {},\n  allElements: [],\n});\n\n/**\n * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback\n * @static\n * @function\n * @memberOf fabric\n * @param {HTMLElement} doc SVG document to parse\n * @param {TSvgParsedCallback} callback Invoked when the parsing is done, with null if parsing wasn't possible with the list of svg nodes.\n * @param {TSvgReviverCallback} [reviver] Extra callback for further parsing of SVG elements, called after each fabric object has been created.\n * Takes as input the original svg element and the generated `FabricObject` as arguments. Used to inspect extra properties not parsed by fabric,\n * or extra custom manipulation\n * @param {Object} [options] Object containing options for parsing\n * @param {String} [options.crossOrigin] crossOrigin setting to use for external resources\n * @param {AbortSignal} [options.signal] handle aborting, see https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal\n * @return {SVGParsingOutput}\n * {@link SVGParsingOutput} also receives `allElements` array as the last argument. This is the full list of svg nodes available in the document.\n * You may want to use it if you are trying to regroup the objects as they were originally grouped in the SVG. ( This was the reason why it was added )\n */\nexport async function parseSVGDocument(\n  doc: Document,\n  reviver?: TSvgReviverCallback,\n  { crossOrigin, signal }: LoadImageOptions = {},\n): Promise<SVGParsingOutput> {\n  if (signal && signal.aborted) {\n    log('log', new SignalAbortedError('parseSVGDocument'));\n    // this is an unhappy path, we dont care about speed\n    return createEmptyResponse();\n  }\n  const documentElement = doc.documentElement;\n  parseUseDirectives(doc);\n\n  const descendants = Array.from(documentElement.getElementsByTagName('*')),\n    options = {\n      ...applyViewboxTransform(documentElement),\n      crossOrigin,\n      signal,\n    };\n\n  const elements = descendants.filter((el) => {\n    applyViewboxTransform(el);\n    return isValidSvgTag(el) && !hasInvalidAncestor(el); // http://www.w3.org/TR/SVG/struct.html#DefsElement\n  });\n  if (!elements || (elements && !elements.length)) {\n    return {\n      ...createEmptyResponse(),\n      options,\n      allElements: descendants,\n    };\n  }\n  const localClipPaths: Record<string, Element[]> = {};\n  descendants\n    .filter((el) => getTagName(el) === 'clipPath')\n    .forEach((el) => {\n      el.setAttribute('originalTransform', el.getAttribute('transform') || '');\n      const id = el.getAttribute('id')!;\n      localClipPaths[id] = Array.from(el.getElementsByTagName('*')).filter(\n        (el) => isValidSvgTag(el),\n      );\n    });\n\n  // Precedence of rules:   style > class > attribute\n  const elementParser = new ElementsParser(\n    elements,\n    options,\n    reviver,\n    doc,\n    localClipPaths,\n  );\n\n  const instances = await elementParser.parse();\n\n  return {\n    objects: instances,\n    elements,\n    options,\n    allElements: descendants,\n  };\n}\n"],"names":["isValidSvgTag","el","svgValidTagNamesRegEx","test","getTagName","createEmptyResponse","objects","elements","options","allElements","async","parseSVGDocument","doc","reviver","crossOrigin","signal","arguments","length","undefined","aborted","log","SignalAbortedError","documentElement","parseUseDirectives","descendants","Array","from","getElementsByTagName","_objectSpread","applyViewboxTransform","filter","hasInvalidAncestor","localClipPaths","forEach","setAttribute","getAttribute","id","elementParser","ElementsParser","parse"],"mappings":"shBAUA,MAAMA,EAAiBC,GACrBC,EAAsBC,KAAKC,EAAWH,IAE3BI,EAAsBA,KAAyB,CAC1DC,QAAS,GACTC,SAAU,GACVC,QAAS,CAAE,EACXC,YAAa,KAoBRC,eAAeC,EACpBC,EACAC,GAE2B,IAD3BC,YAAEA,EAAWC,OAAEA,GAA0BC,UAAAC,OAAAD,QAAAE,IAAAF,UAAAE,GAAAF,UAAG,GAAA,GAE5C,GAAID,GAAUA,EAAOI,QAGnB,OAFAC,EAAI,MAAO,IAAIC,EAAmB,qBA9BsB,CAC1Df,QAAS,GACTC,SAAU,GACVC,QAAS,CAAE,EACXC,YAAa,IA8Bb,MAAMa,EAAkBV,EAAIU,gBAC5BC,EAAmBX,GAEnB,MAAMY,EAAcC,MAAMC,KAAKJ,EAAgBK,qBAAqB,MAClEnB,EAAOoB,EAAAA,KACFC,EAAsBP,IAAgB,GAAA,CACzCR,cACAC,WAGER,EAAWiB,EAAYM,QAAQ7B,IACnC4B,EAAsB5B,GACfD,EAAcC,KAAQ8B,EAAmB9B,MAElD,IAAKM,GAAaA,IAAaA,EAASU,OACtC,OAAAW,EAAAA,EACKvB,CAAAA,EAlDmD,CAC1DC,QAAS,GACTC,SAAU,GACVC,QAAS,CAAE,EACXC,YAAa,KA8Ce,CAAA,EAAA,CACxBD,UACAC,YAAae,IAGjB,MAAMQ,EAA4C,CAAA,EAClDR,EACGM,QAAQ7B,GAA0B,aAAnBG,EAAWH,KAC1BgC,SAAShC,IACRA,EAAGiC,aAAa,oBAAqBjC,EAAGkC,aAAa,cAAgB,IACrE,MAAMC,EAAKnC,EAAGkC,aAAa,MAC3BH,EAAeI,GAAMX,MAAMC,KAAKzB,EAAG0B,qBAAqB,MAAMG,QAC3D7B,GAAOD,EAAcC,IACvB,IAIL,MAAMoC,EAAgB,IAAIC,EACxB/B,EACAC,EACAK,EACAD,EACAoB,GAKF,MAAO,CACL1B,cAHsB+B,EAAcE,QAIpChC,WACAC,UACAC,YAAae,EAEjB"}