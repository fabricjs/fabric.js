{"version":3,"file":"Composed.min.mjs","sources":["../../../src/filters/Composed.ts"],"sourcesContent":["import { BaseFilter } from './BaseFilter';\nimport type { T2DPipelineState, TWebGLPipelineState } from './typedefs';\nimport { isWebGLPipelineState } from './utils';\nimport { classRegistry } from '../ClassRegistry';\n\ntype ComposedOwnProps = {\n  subFilters: BaseFilter<string, object>[];\n};\n\n/**\n * A container class that knows how to apply a sequence of filters to an input image.\n */\nexport class Composed extends BaseFilter<'Composed', ComposedOwnProps> {\n  /**\n   * A non sparse array of filters to apply\n   */\n  declare subFilters: ComposedOwnProps['subFilters'];\n\n  static type = 'Composed';\n\n  constructor(\n    options: { subFilters?: BaseFilter<string, object>[] } & Record<\n      string,\n      any\n    > = {},\n  ) {\n    super(options);\n    this.subFilters = options.subFilters || [];\n  }\n\n  /**\n   * Apply this container's filters to the input image provided.\n   *\n   * @param {Object} options\n   * @param {Number} options.passes The number of filters remaining to be applied.\n   */\n  applyTo(options: TWebGLPipelineState | T2DPipelineState) {\n    if (isWebGLPipelineState(options)) {\n      options.passes += this.subFilters.length - 1;\n    }\n    this.subFilters.forEach((filter) => {\n      filter.applyTo(options);\n    });\n  }\n\n  /**\n   * Serialize this filter into JSON.\n   * @returns {Object} A JSON representation of this filter.\n   */\n  //@ts-expect-error TS doesn't like this toObject\n  toObject(): {\n    type: 'Composed';\n    subFilters: ReturnType<BaseFilter<string, object>['toObject']>[];\n  } {\n    return {\n      type: this.type,\n      subFilters: this.subFilters.map((filter) => filter.toObject()),\n    };\n  }\n\n  isNeutralState() {\n    return !this.subFilters.some((filter) => !filter.isNeutralState());\n  }\n\n  /**\n   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.\n   * @static\n   * @param {oject} object Object to create an instance from\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] handle aborting `BlendImage` filter loading, see https://developer.mozilla.org/en-US/docs/Web/API/AbortController/signal\n   * @returns {Promise<Composed>}\n   */\n  static fromObject(\n    object: Record<string, any>,\n    options: { signal: AbortSignal },\n  ): Promise<Composed> {\n    return Promise.all(\n      ((object.subFilters || []) as BaseFilter<string, object>[]).map(\n        (filter) =>\n          classRegistry\n            .getClass<typeof BaseFilter>(filter.type)\n            .fromObject(filter, options),\n      ),\n    ).then(\n      (enlivedFilters) => new this({ subFilters: enlivedFilters }) as Composed,\n    );\n  }\n}\n\nclassRegistry.setClass(Composed);\n"],"names":["Composed","BaseFilter","constructor","options","arguments","length","undefined","super","this","subFilters","applyTo","isWebGLPipelineState","passes","forEach","filter","toObject","type","map","isNeutralState","some","fromObject","object","Promise","all","classRegistry","getClass","then","enlivedFilters","_defineProperty","setClass"],"mappings":"oPAYO,MAAMA,UAAiBC,EAQ5BC,WAAAA,GAKE,IAJAC,EAGCC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAA,EAEJG,MAAMJ,GACNK,KAAKC,WAAaN,EAAQM,YAAc,EAC1C,CAQAC,OAAAA,CAAQP,GACFQ,EAAqBR,KACvBA,EAAQS,QAAUJ,KAAKC,WAAWJ,OAAS,GAE7CG,KAAKC,WAAWI,SAASC,IACvBA,EAAOJ,QAAQP,EAAQ,GAE3B,CAOAY,QAAAA,GAIE,MAAO,CACLC,KAAMR,KAAKQ,KACXP,WAAYD,KAAKC,WAAWQ,KAAKH,GAAWA,EAAOC,aAEvD,CAEAG,cAAAA,GACE,OAAQV,KAAKC,WAAWU,MAAML,IAAYA,EAAOI,kBACnD,CAUA,iBAAOE,CACLC,EACAlB,GAEA,OAAOmB,QAAQC,KACXF,EAAOZ,YAAc,IAAqCQ,KACzDH,GACCU,EACGC,SAA4BX,EAAOE,MACnCI,WAAWN,EAAQX,MAE1BuB,MACCC,GAAmB,IAAInB,KAAK,CAAEC,WAAYkB,KAE/C,EAzEAC,EADW5B,EAAQ,OAML,YAuEhBwB,EAAcK,SAAS7B"}