{"version":3,"file":"Pixelate.min.mjs","sources":["../../../src/filters/Pixelate.ts"],"sourcesContent":["import { BaseFilter } from './BaseFilter';\nimport type { T2DPipelineState, TWebGLUniformLocationMap } from './typedefs';\nimport { classRegistry } from '../ClassRegistry';\nimport { fragmentSource } from './shaders/pixelate';\n\nexport type PixelateOwnProps = {\n  blocksize: number;\n};\n\nexport const pixelateDefaultValues: PixelateOwnProps = {\n  blocksize: 4,\n};\n\n/**\n * Pixelate filter class\n * @example\n * const filter = new Pixelate({\n *   blocksize: 8\n * });\n * object.filters.push(filter);\n * object.applyFilters();\n */\nexport class Pixelate extends BaseFilter<'Pixelate', PixelateOwnProps> {\n  declare blocksize: PixelateOwnProps['blocksize'];\n\n  static type = 'Pixelate';\n\n  static defaults = pixelateDefaultValues;\n\n  static uniformLocations = ['uBlocksize'];\n\n  /**\n   * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.\n   *\n   * @param {Object} options\n   * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.\n   */\n  applyTo2d({ imageData: { data, width, height } }: T2DPipelineState) {\n    for (let i = 0; i < height; i += this.blocksize) {\n      for (let j = 0; j < width; j += this.blocksize) {\n        const index = i * 4 * width + j * 4;\n        const r = data[index];\n        const g = data[index + 1];\n        const b = data[index + 2];\n        const a = data[index + 3];\n\n        for (let _i = i; _i < Math.min(i + this.blocksize, height); _i++) {\n          for (let _j = j; _j < Math.min(j + this.blocksize, width); _j++) {\n            const index = _i * 4 * width + _j * 4;\n            data[index] = r;\n            data[index + 1] = g;\n            data[index + 2] = b;\n            data[index + 3] = a;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Indicate when the filter is not gonna apply changes to the image\n   **/\n  isNeutralState() {\n    return this.blocksize === 1;\n  }\n\n  protected getFragmentSource(): string {\n    return fragmentSource;\n  }\n\n  /**\n   * Send data from this filter to its shader program's uniforms.\n   *\n   * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.\n   * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects\n   */\n  sendUniformData(\n    gl: WebGLRenderingContext,\n    uniformLocations: TWebGLUniformLocationMap,\n  ) {\n    gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);\n  }\n}\n\nclassRegistry.setClass(Pixelate);\n"],"names":["pixelateDefaultValues","blocksize","Pixelate","BaseFilter","applyTo2d","_ref","imageData","data","width","height","i","this","j","index","r","g","b","a","_i","Math","min","_j","isNeutralState","getFragmentSource","fragmentSource","sendUniformData","gl","uniformLocations","uniform1f","uBlocksize","_defineProperty","classRegistry","setClass"],"mappings":"yPASO,MAAMA,EAA0C,CACrDC,UAAW,GAYN,MAAMC,UAAiBC,EAe5BC,SAAAA,CAASC,GAA2D,IAAxDC,WAAWC,KAAEA,EAAIC,MAAEA,EAAKC,OAAEA,IAA4BJ,EAChE,IAAK,IAAIK,EAAI,EAAGA,EAAID,EAAQC,GAAKC,KAAKV,UACpC,IAAK,IAAIW,EAAI,EAAGA,EAAIJ,EAAOI,GAAKD,KAAKV,UAAW,CAC9C,MAAMY,EAAY,EAAJH,EAAQF,EAAY,EAAJI,EACxBE,EAAIP,EAAKM,GACTE,EAAIR,EAAKM,EAAQ,GACjBG,EAAIT,EAAKM,EAAQ,GACjBI,EAAIV,EAAKM,EAAQ,GAEvB,IAAK,IAAIK,EAAKR,EAAGQ,EAAKC,KAAKC,IAAIV,EAAIC,KAAKV,UAAWQ,GAASS,IAC1D,IAAK,IAAIG,EAAKT,EAAGS,EAAKF,KAAKC,IAAIR,EAAID,KAAKV,UAAWO,GAAQa,IAAM,CAC/D,MAAMR,EAAa,EAALK,EAASV,EAAa,EAALa,EAC/Bd,EAAKM,GAASC,EACdP,EAAKM,EAAQ,GAAKE,EAClBR,EAAKM,EAAQ,GAAKG,EAClBT,EAAKM,EAAQ,GAAKI,CACpB,CAEJ,CAEJ,CAKAK,cAAAA,GACE,OAA0B,IAAnBX,KAAKV,SACd,CAEUsB,iBAAAA,GACR,OAAOC,CACT,CAQAC,eAAAA,CACEC,EACAC,GAEAD,EAAGE,UAAUD,EAAiBE,WAAYlB,KAAKV,UACjD,EACD6B,EA5DY5B,EAAQ,OAGL,YAAU4B,EAHb5B,EAAQ,WAKDF,GAAqB8B,EAL5B5B,EAOe,mBAAA,CAAC,eAuD7B6B,EAAcC,SAAS9B"}