import{defineProperty as t}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{Color as s}from"../color/Color.min.mjs";import{Shadow as i}from"../Shadow.min.mjs";import{Circle as o}from"../shapes/Circle.min.mjs";import{Group as e}from"../shapes/Group.min.mjs";import{getRandomInt as n}from"../util/internals/getRandomInt.min.mjs";import{BaseBrush as a}from"./BaseBrush.min.mjs";import{CENTER as r}from"../constants.min.mjs";class h extends a{constructor(s){super(s),t(this,"width",10),this.points=[]}drawDot(t){const s=this.addPoint(t),i=this.canvas.contextTop;this._saveAndTransform(i),this.dot(i,s),i.restore()}dot(t,s){t.fillStyle=s.fill,t.beginPath(),t.arc(s.x,s.y,s.radius,0,2*Math.PI,!1),t.closePath(),t.fill()}onMouseDown(t){this.points=[],this.canvas.clearContext(this.canvas.contextTop),this._setShadow(),this.drawDot(t)}_render(){const t=this.canvas.contextTop,s=this.points;this._saveAndTransform(t);for(let i=0;i<s.length;i++)this.dot(t,s[i]);t.restore()}onMouseMove(t){!0===this.limitedToCanvasSize&&this._isOutSideCanvas(t)||(this.needsFullRender()?(this.canvas.clearContext(this.canvas.contextTop),this.addPoint(t),this._render()):this.drawDot(t))}onMouseUp(){const t=this.canvas.renderOnAddRemove;this.canvas.renderOnAddRemove=!1;const s=[];for(let t=0;t<this.points.length;t++){const e=this.points[t],n=new o({radius:e.radius,left:e.x,top:e.y,originX:r,originY:r,fill:e.fill});this.shadow&&(n.shadow=new i(this.shadow)),s.push(n)}const n=new e(s,{canvas:this.canvas});this.canvas.fire("before:path:created",{path:n}),this.canvas.add(n),this.canvas.fire("path:created",{path:n}),this.canvas.clearContext(this.canvas.contextTop),this._resetShadow(),this.canvas.renderOnAddRemove=t,this.canvas.requestRenderAll()}addPoint(t){let{x:i,y:o}=t;const e={x:i,y:o,radius:n(Math.max(0,this.width-20),this.width+20)/2,fill:new s(this.color).setAlpha(n(0,100)/100).toRgba()};return this.points.push(e),e}}export{h as CircleBrush};
//# sourceMappingURL=CircleBrush.min.mjs.map
