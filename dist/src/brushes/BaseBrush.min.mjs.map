{"version":3,"file":"BaseBrush.min.mjs","sources":["../../../src/brushes/BaseBrush.ts"],"sourcesContent":["import { Color } from '../color/Color';\nimport type { Point } from '../Point';\nimport type { Shadow } from '../Shadow';\nimport type { Canvas } from '../canvas/Canvas';\nimport type { TBrushEventData } from './typedefs';\n\n/**\n * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}\n */\nexport abstract class BaseBrush {\n  /**\n   * Color of a brush\n   * @type String\n   * @default\n   */\n  color = 'rgb(0, 0, 0)';\n\n  /**\n   * Width of a brush, has to be a Number, no string literals\n   * @type Number\n   * @default\n   */\n  width = 1;\n\n  /**\n   * Shadow object representing shadow of this shape.\n   * <b>Backwards incompatibility note:</b> This property replaces \"shadowColor\" (String), \"shadowOffsetX\" (Number),\n   * \"shadowOffsetY\" (Number) and \"shadowBlur\" (Number) since v1.2.12\n   * @type Shadow\n   * @default\n   */\n  shadow: Shadow | null = null;\n\n  /**\n   * Line endings style of a brush (one of \"butt\", \"round\", \"square\")\n   * @type String\n   * @default\n   */\n  strokeLineCap: CanvasLineCap = 'round';\n\n  /**\n   * Corner style of a brush (one of \"bevel\", \"round\", \"miter\")\n   * @type String\n   * @default\n   */\n  strokeLineJoin: CanvasLineJoin = 'round';\n\n  /**\n   * Maximum miter length (used for strokeLineJoin = \"miter\") of a brush's\n   * @type Number\n   * @default\n   */\n  strokeMiterLimit = 10;\n\n  /**\n   * Stroke Dash Array.\n   * @type Array\n   * @default\n   */\n  strokeDashArray: number[] | null = null;\n\n  /**\n   * When `true`, the free drawing is limited to the whiteboard size. Default to false.\n   * @type Boolean\n   * @default false\n   */\n\n  limitedToCanvasSize = false;\n\n  /**\n   * @todo add type\n   */\n  declare canvas: Canvas;\n\n  constructor(canvas: Canvas) {\n    this.canvas = canvas;\n  }\n\n  abstract _render(): void;\n  abstract onMouseDown(pointer: Point, ev: TBrushEventData): void;\n  abstract onMouseMove(pointer: Point, ev: TBrushEventData): void;\n  /**\n   * @returns true if brush should continue blocking interaction\n   */\n  abstract onMouseUp(ev: TBrushEventData): boolean | void;\n\n  /**\n   * Sets brush styles\n   * @private\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  _setBrushStyles(ctx: CanvasRenderingContext2D) {\n    ctx.strokeStyle = this.color;\n    ctx.lineWidth = this.width;\n    ctx.lineCap = this.strokeLineCap;\n    ctx.miterLimit = this.strokeMiterLimit;\n    ctx.lineJoin = this.strokeLineJoin;\n    ctx.setLineDash(this.strokeDashArray || []);\n  }\n\n  /**\n   * Sets the transformation on given context\n   * @param {CanvasRenderingContext2D} ctx context to render on\n   * @private\n   */\n  protected _saveAndTransform(ctx: CanvasRenderingContext2D) {\n    const v = this.canvas.viewportTransform;\n    ctx.save();\n    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);\n  }\n\n  protected needsFullRender() {\n    const color = new Color(this.color);\n    return color.getAlpha() < 1 || !!this.shadow;\n  }\n\n  /**\n   * Sets brush shadow styles\n   * @private\n   */\n  protected _setShadow() {\n    if (!this.shadow || !this.canvas) {\n      return;\n    }\n\n    const canvas = this.canvas,\n      shadow = this.shadow,\n      ctx = canvas.contextTop,\n      zoom = canvas.getZoom() * canvas.getRetinaScaling();\n\n    ctx.shadowColor = shadow.color;\n    ctx.shadowBlur = shadow.blur * zoom;\n    ctx.shadowOffsetX = shadow.offsetX * zoom;\n    ctx.shadowOffsetY = shadow.offsetY * zoom;\n  }\n\n  /**\n   * Removes brush shadow styles\n   * @private\n   */\n  protected _resetShadow() {\n    const ctx = this.canvas.contextTop;\n\n    ctx.shadowColor = '';\n    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;\n  }\n\n  /**\n   * Check is pointer is outside canvas boundaries\n   * @param {Object} pointer\n   * @private\n   */\n  protected _isOutSideCanvas(pointer: Point) {\n    return (\n      pointer.x < 0 ||\n      pointer.x > this.canvas.getWidth() ||\n      pointer.y < 0 ||\n      pointer.y > this.canvas.getHeight()\n    );\n  }\n}\n"],"names":["BaseBrush","constructor","canvas","_defineProperty","this","_setBrushStyles","ctx","strokeStyle","color","lineWidth","width","lineCap","strokeLineCap","miterLimit","strokeMiterLimit","lineJoin","strokeLineJoin","setLineDash","strokeDashArray","_saveAndTransform","v","viewportTransform","save","transform","needsFullRender","Color","getAlpha","shadow","_setShadow","contextTop","zoom","getZoom","getRetinaScaling","shadowColor","shadowBlur","blur","shadowOffsetX","offsetX","shadowOffsetY","offsetY","_resetShadow","_isOutSideCanvas","pointer","x","getWidth","y","getHeight"],"mappings":"iIASO,MAAeA,EAiEpBC,WAAAA,CAAYC,GAhEZC,eAKQ,gBAERA,eAKQ,GAERA,gBAOwB,MAExBA,uBAK+B,SAE/BA,wBAKiC,SAEjCA,0BAKmB,IAEnBA,yBAKmC,MAEnCA,8BAMsB,GAQpBC,KAAKF,OAASA,CAChB,CAeAG,eAAAA,CAAgBC,GACdA,EAAIC,YAAcH,KAAKI,MACvBF,EAAIG,UAAYL,KAAKM,MACrBJ,EAAIK,QAAUP,KAAKQ,cACnBN,EAAIO,WAAaT,KAAKU,iBACtBR,EAAIS,SAAWX,KAAKY,eACpBV,EAAIW,YAAYb,KAAKc,iBAAmB,GAC1C,CAOUC,iBAAAA,CAAkBb,GAC1B,MAAMc,EAAIhB,KAAKF,OAAOmB,kBACtBf,EAAIgB,OACJhB,EAAIiB,UAAUH,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAChD,CAEUI,eAAAA,GAER,OADc,IAAIC,EAAMrB,KAAKI,OAChBkB,WAAa,KAAOtB,KAAKuB,MACxC,CAMUC,UAAAA,GACR,IAAKxB,KAAKuB,SAAWvB,KAAKF,OACxB,OAGF,MAAMA,EAASE,KAAKF,OAClByB,EAASvB,KAAKuB,OACdrB,EAAMJ,EAAO2B,WACbC,EAAO5B,EAAO6B,UAAY7B,EAAO8B,mBAEnC1B,EAAI2B,YAAcN,EAAOnB,MACzBF,EAAI4B,WAAaP,EAAOQ,KAAOL,EAC/BxB,EAAI8B,cAAgBT,EAAOU,QAAUP,EACrCxB,EAAIgC,cAAgBX,EAAOY,QAAUT,CACvC,CAMUU,YAAAA,GACR,MAAMlC,EAAMF,KAAKF,OAAO2B,WAExBvB,EAAI2B,YAAc,GAClB3B,EAAI4B,WAAa5B,EAAI8B,cAAgB9B,EAAIgC,cAAgB,CAC3D,CAOUG,gBAAAA,CAAiBC,GACzB,OACEA,EAAQC,EAAI,GACZD,EAAQC,EAAIvC,KAAKF,OAAO0C,YACxBF,EAAQG,EAAI,GACZH,EAAQG,EAAIzC,KAAKF,OAAO4C,WAE5B"}