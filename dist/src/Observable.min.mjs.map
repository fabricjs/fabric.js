{"version":3,"file":"Observable.min.mjs","sources":["../../src/Observable.ts"],"sourcesContent":["export type TEventCallback<T = any> = (options: T) => any;\n\ntype EventRegistryObject<E> = {\n  [K in keyof E]?: TEventCallback<E[K]>;\n};\n\n/**\n * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}\n * @see {@link http://fabricjs.com/events|Events demo}\n */\nexport class Observable<EventSpec> {\n  private __eventListeners: Record<keyof EventSpec, TEventCallback[]> =\n    {} as Record<keyof EventSpec, TEventCallback[]>;\n\n  /**\n   * Observes specified event\n   * @alias on\n   * @param {string} eventName Event name (eg. 'after:render')\n   * @param {EventRegistryObject} handlers key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   * @param {Function} handler Function that receives a notification when an event of the specified type occurs\n   * @return {Function} disposer\n   */\n  on<K extends keyof EventSpec, E extends EventSpec[K]>(\n    eventName: K,\n    handler: TEventCallback<E>,\n  ): VoidFunction;\n  on(handlers: EventRegistryObject<EventSpec>): VoidFunction;\n  on<K extends keyof EventSpec, E extends EventSpec[K]>(\n    arg0: K | EventRegistryObject<EventSpec>,\n    handler?: TEventCallback<E>,\n  ): VoidFunction {\n    if (!this.__eventListeners) {\n      this.__eventListeners = {} as Record<keyof EventSpec, TEventCallback[]>;\n    }\n    if (typeof arg0 === 'object') {\n      // one object with key/value pairs was passed\n      Object.entries(arg0).forEach(([eventName, handler]) => {\n        this.on(eventName as K, handler as TEventCallback);\n      });\n      return () => this.off(arg0);\n    } else if (handler) {\n      const eventName = arg0;\n      if (!this.__eventListeners[eventName]) {\n        this.__eventListeners[eventName] = [];\n      }\n      this.__eventListeners[eventName].push(handler);\n      return () => this.off(eventName, handler);\n    } else {\n      // noop\n      return () => false;\n    }\n  }\n\n  /**\n   * Observes specified event **once**\n   * @alias once\n   * @param {string} eventName Event name (eg. 'after:render')\n   * @param {EventRegistryObject} handlers key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   * @param {Function} handler Function that receives a notification when an event of the specified type occurs\n   * @return {Function} disposer\n   */\n  once<K extends keyof EventSpec, E extends EventSpec[K]>(\n    eventName: K,\n    handler: TEventCallback<E>,\n  ): VoidFunction;\n  once(handlers: EventRegistryObject<EventSpec>): VoidFunction;\n  once<K extends keyof EventSpec, E extends EventSpec[K]>(\n    arg0: K | EventRegistryObject<EventSpec>,\n    handler?: TEventCallback<E>,\n  ): VoidFunction {\n    if (typeof arg0 === 'object') {\n      // one object with key/value pairs was passed\n      const disposers: VoidFunction[] = [];\n      Object.entries(arg0).forEach(([eventName, handler]) => {\n        disposers.push(this.once(eventName as K, handler as TEventCallback));\n      });\n      return () => disposers.forEach((d) => d());\n    } else if (handler) {\n      const disposer = this.on<K, E>(\n        arg0,\n        function onceHandler(this: Observable<EventSpec>, ...args) {\n          handler.call(this, ...args);\n          disposer();\n        },\n      );\n      return disposer;\n    } else {\n      // noop\n      return () => false;\n    }\n  }\n\n  /**\n   * @private\n   * @param {string} eventName\n   * @param {Function} [handler]\n   */\n  private _removeEventListener<K extends keyof EventSpec>(\n    eventName: K,\n    handler?: TEventCallback,\n  ) {\n    if (!this.__eventListeners[eventName]) {\n      return;\n    }\n\n    if (handler) {\n      const eventListener = this.__eventListeners[eventName];\n      const index = eventListener.indexOf(handler);\n      index > -1 && eventListener.splice(index, 1);\n    } else {\n      this.__eventListeners[eventName] = [];\n    }\n  }\n\n  /**\n   * Unsubscribe all event listeners for eventname.\n   * Do not use this pattern. You could kill internal fabricJS events.\n   * We know we should have protected events for internal flows, but we don't have yet\n   * @deprecated\n   * @param {string} eventName event name (eg. 'after:render')\n   */\n  off<K extends keyof EventSpec>(eventName: K): void;\n  /**\n   * unsubscribe an event listener\n   * @param {string} eventName event name (eg. 'after:render')\n   * @param {TEventCallback} handler event listener to unsubscribe\n   */\n  off<K extends keyof EventSpec>(eventName: K, handler: TEventCallback): void;\n  /**\n   * unsubscribe event listeners\n   * @param handlers handlers key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})\n   */\n  off(handlers: EventRegistryObject<EventSpec>): void;\n  /**\n   * unsubscribe all event listeners\n   */\n  off(): void;\n  off<K extends keyof EventSpec>(\n    arg0?: K | EventRegistryObject<EventSpec>,\n    handler?: TEventCallback,\n  ) {\n    if (!this.__eventListeners) {\n      return;\n    }\n\n    // remove all key/value pairs (event name -> event handler)\n    if (typeof arg0 === 'undefined') {\n      for (const eventName in this.__eventListeners) {\n        this._removeEventListener(eventName);\n      }\n    }\n    // one object with key/value pairs was passed\n    else if (typeof arg0 === 'object') {\n      Object.entries(arg0).forEach(([eventName, handler]) => {\n        this._removeEventListener(eventName as K, handler as TEventCallback);\n      });\n    } else {\n      this._removeEventListener(arg0, handler);\n    }\n  }\n\n  /**\n   * Fires event with an optional options object\n   * @param {String} eventName Event name to fire\n   * @param {Object} [options] Options object\n   */\n  fire<K extends keyof EventSpec>(eventName: K, options?: EventSpec[K]) {\n    if (!this.__eventListeners) {\n      return;\n    }\n\n    const listenersForEvent = this.__eventListeners[eventName]?.concat();\n    if (listenersForEvent) {\n      for (let i = 0; i < listenersForEvent.length; i++) {\n        listenersForEvent[i].call(this, options || {});\n      }\n    }\n  }\n}\n"],"names":["Observable","constructor","_defineProperty","this","on","arg0","handler","__eventListeners","Object","entries","forEach","_ref","eventName","off","push","once","disposers","_ref2","d","disposer","_len","arguments","length","args","Array","_key","call","_removeEventListener","eventListener","index","indexOf","splice","_ref3","fire","options","_this$__eventListener","listenersForEvent","concat","i"],"mappings":"+EAUO,MAAMA,EAAsBC,WAAAA,GAAAC,EAAAC,KAAA,mBAE/B,CAAA,EAAE,CAeJC,EAAAA,CACEC,EACAC,GAKA,GAHKH,KAAKI,mBACRJ,KAAKI,iBAAmB,IAEN,iBAATF,EAKT,OAHAG,OAAOC,QAAQJ,GAAMK,SAAQC,IAA0B,IAAxBC,EAAWN,GAAQK,EAChDR,KAAKC,GAAGQ,EAAgBN,EAA0B,IAE7C,IAAMH,KAAKU,IAAIR,GACjB,GAAIC,EAAS,CAClB,MAAMM,EAAYP,EAKlB,OAJKF,KAAKI,iBAAiBK,KACzBT,KAAKI,iBAAiBK,GAAa,IAErCT,KAAKI,iBAAiBK,GAAWE,KAAKR,GAC/B,IAAMH,KAAKU,IAAID,EAAWN,EACnC,CAEE,MAAO,KAAM,CAEjB,CAeAS,IAAAA,CACEV,EACAC,GAEA,GAAoB,iBAATD,EAAmB,CAE5B,MAAMW,EAA4B,GAIlC,OAHAR,OAAOC,QAAQJ,GAAMK,SAAQO,IAA0B,IAAxBL,EAAWN,GAAQW,EAChDD,EAAUF,KAAKX,KAAKY,KAAKH,EAAgBN,GAA2B,IAE/D,IAAMU,EAAUN,SAASQ,GAAMA,KACvC,CAAM,GAAIZ,EAAS,CAClB,MAAMa,EAAWhB,KAAKC,GACpBC,GACA,WAA2D,IAAA,IAAAe,EAAAC,UAAAC,OAANC,EAAIC,IAAAA,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAAJF,EAAIE,GAAAJ,UAAAI,GACvDnB,EAAQoB,KAAKvB,QAASoB,GACtBJ,GACF,IAEF,OAAOA,CACT,CAEE,MAAO,KAAM,CAEjB,CAOQQ,oBAAAA,CACNf,EACAN,GAEA,GAAKH,KAAKI,iBAAiBK,GAI3B,GAAIN,EAAS,CACX,MAAMsB,EAAgBzB,KAAKI,iBAAiBK,GACtCiB,EAAQD,EAAcE,QAAQxB,GACpCuB,GAAS,GAAKD,EAAcG,OAAOF,EAAO,EAC5C,MACE1B,KAAKI,iBAAiBK,GAAa,EAEvC,CAyBAC,GAAAA,CACER,EACAC,GAEA,GAAKH,KAAKI,iBAKV,QAAoB,IAATF,EACT,IAAK,MAAMO,KAAaT,KAAKI,iBAC3BJ,KAAKwB,qBAAqBf,OAIL,iBAATP,EACdG,OAAOC,QAAQJ,GAAMK,SAAQsB,IAA0B,IAAxBpB,EAAWN,GAAQ0B,EAChD7B,KAAKwB,qBAAqBf,EAAgBN,EAA0B,IAGtEH,KAAKwB,qBAAqBtB,EAAMC,EAEpC,CAOA2B,IAAAA,CAAgCrB,EAAcsB,GAAwB,IAAAC,EACpE,IAAKhC,KAAKI,iBACR,OAGF,MAAM6B,UAAiBD,EAAGhC,KAAKI,iBAAiBK,UAAU,IAAAuB,OAAA,EAAhCA,EAAkCE,SAC5D,GAAID,EACF,IAAK,IAAIE,EAAI,EAAGA,EAAIF,EAAkBd,OAAQgB,IAC5CF,EAAkBE,GAAGZ,KAAKvB,KAAM+B,GAAW,CAAA,EAGjD"}