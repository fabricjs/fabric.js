import{Point as t}from"./Point.min.mjs";import{createVector as n}from"./util/misc/vectors.min.mjs";class e{constructor(t){this.status=t,this.points=[]}includes(t){return this.points.some((n=>n.eq(t)))}append(){for(var t=arguments.length,n=new Array(t),e=0;e<t;e++)n[e]=arguments[e];return this.points=this.points.concat(n.filter((t=>!this.includes(t)))),this}static isPointContained(t,e,i){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.eq(i))return t.eq(e);if(e.x===i.x)return t.x===e.x&&(s||t.y>=Math.min(e.y,i.y)&&t.y<=Math.max(e.y,i.y));if(e.y===i.y)return t.y===e.y&&(s||t.x>=Math.min(e.x,i.x)&&t.x<=Math.max(e.x,i.x));{const o=n(e,i),r=n(e,t).divide(o);return s?Math.abs(r.x)===Math.abs(r.y):r.x===r.y&&r.x>=0&&r.x<=1}}static isPointInPolygon(n,e){const i=new t(n).setX(Math.min(n.x-1,...e.map((t=>t.x))));let s=0;for(let t=0;t<e.length;t++){const o=this.intersectSegmentSegment(e[t],e[(t+1)%e.length],n,i);if(o.includes(n))return!0;s+=Number("Intersection"===o.status)}return s%2==1}static intersectLineLine(n,i,s,o){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],c=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const a=i.x-n.x,l=i.y-n.y,g=o.x-s.x,y=o.y-s.y,u=n.x-s.x,h=n.y-s.y,x=g*h-y*u,m=a*h-l*u,d=y*a-g*l;if(0!==d){const i=x/d,s=m/d;return(r||0<=i&&i<=1)&&(c||0<=s&&s<=1)?new e("Intersection").append(new t(n.x+i*a,n.y+i*l)):new e}if(0===x||0===m){const t=r||c||e.isPointContained(n,s,o)||e.isPointContained(i,s,o)||e.isPointContained(s,n,i)||e.isPointContained(o,n,i);return new e(t?"Coincident":void 0)}return new e("Parallel")}static intersectSegmentLine(t,n,i,s){return e.intersectLineLine(t,n,i,s,!1,!0)}static intersectSegmentSegment(t,n,i,s){return e.intersectLineLine(t,n,i,s,!1,!1)}static intersectLinePolygon(t,n,i){let s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=new e,r=i.length;for(let c,a,l,g=0;g<r;g++){if(c=i[g],a=i[(g+1)%r],l=e.intersectLineLine(t,n,c,a,s,!1),"Coincident"===l.status)return l;o.append(...l.points)}return o.points.length>0&&(o.status="Intersection"),o}static intersectSegmentPolygon(t,n,i){return e.intersectLinePolygon(t,n,i,!1)}static intersectPolygonPolygon(t,n){const i=new e,s=t.length,o=[];for(let r=0;r<s;r++){const c=t[r],a=t[(r+1)%s],l=e.intersectSegmentPolygon(c,a,n);"Coincident"===l.status?(o.push(l),i.append(c,a)):i.append(...l.points)}return o.length>0&&o.length===t.length?new e("Coincident"):(i.points.length>0&&(i.status="Intersection"),i)}static intersectPolygonRectangle(n,i,s){const o=i.min(s),r=i.max(s),c=new t(r.x,o.y),a=new t(o.x,r.y);return e.intersectPolygonPolygon(n,[o,c,r,a])}}export{e as Intersection};
//# sourceMappingURL=Intersection.min.mjs.map
