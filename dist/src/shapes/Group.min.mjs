import{defineProperty as t,objectSpread2 as e,objectWithoutProperties as s}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{createCollectionMixin as r}from"../Collection.min.mjs";import{multiplyTransformMatrices as i,invertTransform as o}from"../util/misc/matrix.min.mjs";import{enlivenObjects as a,enlivenObjectEnlivables as n}from"../util/misc/objectEnlive.min.mjs";import{applyTransformToObject as c}from"../util/misc/objectTransforms.min.mjs";import{FabricObject as h}from"./Object/FabricObject.min.mjs";import{Rect as l}from"./Rect.min.mjs";import{classRegistry as u}from"../ClassRegistry.min.mjs";import{log as p}from"../util/internals/console.min.mjs";import{LayoutManager as _}from"../LayoutManager/LayoutManager.min.mjs";import{LAYOUT_TYPE_INITIALIZATION as d,LAYOUT_TYPE_ADDED as g,LAYOUT_TYPE_REMOVED as b,LAYOUT_TYPE_IMPERATIVE as j}from"../LayoutManager/constants.min.mjs";const f=["type","objects","layoutManager"];class m extends _{performLayout(){}}const O={strokeWidth:0,subTargetCheck:!1,interactive:!1};class v extends(r(h)){static getDefaults(){return e(e({},super.getDefaults()),v.ownDefaults)}constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),t(this,"_activeObjects",[]),t(this,"__objectSelectionTracker",void 0),t(this,"__objectSelectionDisposer",void 0),Object.assign(this,v.ownDefaults),this.setOptions(s),this.groupInit(e,s)}groupInit(t,e){var s;this._objects=[...t],this.__objectSelectionTracker=this.__objectSelectionMonitor.bind(this,!0),this.__objectSelectionDisposer=this.__objectSelectionMonitor.bind(this,!1),this.forEachObject((t=>{this.enterGroup(t,!1)})),this.layoutManager=null!==(s=e.layoutManager)&&void 0!==s?s:new _,this.layoutManager.performLayout({type:d,target:this,targets:[...t],x:e.left,y:e.top})}canEnterGroup(t){return t===this||this.isDescendantOf(t)?(p("error","Group: circular object trees are not supported, this call has no effect"),!1):-1===this._objects.indexOf(t)||(p("error","Group: duplicate objects are not supported inside group, this call has no effect"),!1)}_filterObjectsBeforeEnteringGroup(t){return t.filter(((t,e,s)=>this.canEnterGroup(t)&&s.indexOf(t)===e))}add(){for(var t=arguments.length,e=new Array(t),s=0;s<t;s++)e[s]=arguments[s];const r=this._filterObjectsBeforeEnteringGroup(e),i=super.add(...r);return this._onAfterObjectsChange(g,r),i}insertAt(t){for(var e=arguments.length,s=new Array(e>1?e-1:0),r=1;r<e;r++)s[r-1]=arguments[r];const i=this._filterObjectsBeforeEnteringGroup(s),o=super.insertAt(t,...i);return this._onAfterObjectsChange(g,i),o}remove(){const t=super.remove(...arguments);return this._onAfterObjectsChange(b,t),t}_onObjectAdded(t){this.enterGroup(t,!0),this.fire("object:added",{target:t}),t.fire("added",{target:this})}_onObjectRemoved(t,e){this.exitGroup(t,e),this.fire("object:removed",{target:t}),t.fire("removed",{target:this})}_onAfterObjectsChange(t,e){this.layoutManager.performLayout({type:t,targets:e,target:this})}_onStackOrderChanged(){this._set("dirty",!0)}_set(t,e){const s=this[t];return super._set(t,e),"canvas"===t&&s!==e&&(this._objects||[]).forEach((s=>{s._set(t,e)})),this}_shouldSetNestedCoords(){return this.subTargetCheck}removeAll(){return this._activeObjects=[],this.remove(...this._objects)}__objectSelectionMonitor(t,e){let{target:s}=e;const r=this._activeObjects;if(t)r.push(s),this._set("dirty",!0);else if(r.length>0){const t=r.indexOf(s);t>-1&&(r.splice(t,1),this._set("dirty",!0))}}_watchObject(t,e){t&&this._watchObject(!1,e),t?(e.on("selected",this.__objectSelectionTracker),e.on("deselected",this.__objectSelectionDisposer)):(e.off("selected",this.__objectSelectionTracker),e.off("deselected",this.__objectSelectionDisposer))}enterGroup(t,e){t.group&&t.group.remove(t),t._set("parent",this),this._enterGroup(t,e)}_enterGroup(t,e){e&&c(t,i(o(this.calcTransformMatrix()),t.calcTransformMatrix())),this._shouldSetNestedCoords()&&t.setCoords(),t._set("group",this),t._set("canvas",this.canvas),this._watchObject(!0,t);const s=this.canvas&&this.canvas.getActiveObject&&this.canvas.getActiveObject();s&&(s===t||t.isDescendantOf(s))&&this._activeObjects.push(t)}exitGroup(t,e){this._exitGroup(t,e),t._set("parent",void 0),t._set("canvas",void 0)}_exitGroup(t,e){t._set("group",void 0),e||(c(t,i(this.calcTransformMatrix(),t.calcTransformMatrix())),t.setCoords()),this._watchObject(!1,t);const s=this._activeObjects.length>0?this._activeObjects.indexOf(t):-1;s>-1&&this._activeObjects.splice(s,1)}shouldCache(){const t=h.prototype.shouldCache.call(this);if(t)for(let t=0;t<this._objects.length;t++)if(this._objects[t].willDrawShadow())return this.ownCaching=!1,!1;return t}willDrawShadow(){if(super.willDrawShadow())return!0;for(let t=0;t<this._objects.length;t++)if(this._objects[t].willDrawShadow())return!0;return!1}isOnACache(){return this.ownCaching||!!this.parent&&this.parent.isOnACache()}drawObject(t){this._renderBackground(t);for(let s=0;s<this._objects.length;s++){var e;null!==(e=this.canvas)&&void 0!==e&&e.preserveObjectStacking&&this._objects[s].group!==this?(t.save(),t.transform(...o(this.calcTransformMatrix())),this._objects[s].render(t),t.restore()):this._objects[s].group===this&&this._objects[s].render(t)}this._drawClipPath(t,this.clipPath)}setCoords(){super.setCoords(),this._shouldSetNestedCoords()&&this.forEachObject((t=>t.setCoords()))}triggerLayout(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.layoutManager.performLayout(e({target:this,type:j},t))}render(t){this._transformDone=!0,super.render(t),this._transformDone=!1}__serializeObjects(t,e){const s=this.includeDefaultValues;return this._objects.filter((function(t){return!t.excludeFromExport})).map((function(r){const i=r.includeDefaultValues;r.includeDefaultValues=s;const o=r[t||"toObject"](e);return r.includeDefaultValues=i,o}))}toObject(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];const s=this.layoutManager.toObject();return e(e(e({},super.toObject(["subTargetCheck","interactive",...t])),"fit-content"!==s.strategy||this.includeDefaultValues?{layoutManager:s}:{}),{},{objects:this.__serializeObjects("toObject",t)})}toString(){return"#<Group: (".concat(this.complexity(),")>")}dispose(){this.layoutManager.unsubscribeTargets({targets:this.getObjects(),target:this}),this._activeObjects=[],this.forEachObject((t=>{this._watchObject(!1,t),t.dispose()})),super.dispose()}_createSVGBgRect(t){if(!this.backgroundColor)return"";const e=l.prototype._toSVG.call(this),s=e.indexOf("COMMON_PARTS");e[s]='for="group" ';const r=e.join("");return t?t(r):r}_toSVG(t){const e=["<g ","COMMON_PARTS"," >\n"],s=this._createSVGBgRect(t);s&&e.push("\t\t",s);for(let s=0;s<this._objects.length;s++)e.push("\t\t",this._objects[s].toSVG(t));return e.push("</g>\n"),e}getSvgStyles(){const t=void 0!==this.opacity&&1!==this.opacity?"opacity: ".concat(this.opacity,";"):"",e=this.visible?"":" visibility: hidden;";return[t,this.getSvgFilter(),e].join("")}toClipPathSVG(t){const e=[],s=this._createSVGBgRect(t);s&&e.push("\t",s);for(let s=0;s<this._objects.length;s++)e.push("\t",this._objects[s].toClipPathSVG(t));return this._createBaseClipPathSVGMarkup(e,{reviver:t})}static fromObject(t,r){let{type:i,objects:o=[],layoutManager:c}=t,h=s(t,f);return Promise.all([a(o,r),n(h,r)]).then((t=>{let[s,r]=t;const i=new this(s,e(e(e({},h),r),{},{layoutManager:new m}));if(c){const t=u.getClass(c.type),e=u.getClass(c.strategy);i.layoutManager=new t(new e)}else i.layoutManager=new _;return i.layoutManager.subscribeTargets({type:d,target:i,targets:i.getObjects()}),i.setCoords(),i}))}}t(v,"type","Group"),t(v,"ownDefaults",O),u.setClass(v);export{v as Group,O as groupDefaultValues};
//# sourceMappingURL=Group.min.mjs.map
