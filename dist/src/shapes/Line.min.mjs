import{defineProperty as t,objectSpread2 as i,objectWithoutProperties as s}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{SHARED_ATTRIBUTES as e}from"../parser/attributes.min.mjs";import{parseAttributes as o}from"../parser/parseAttributes.min.mjs";import{classRegistry as r}from"../ClassRegistry.min.mjs";import{FabricObject as n}from"./Object/FabricObject.min.mjs";import{Point as m}from"../Point.min.mjs";import{isFiller as h}from"../util/typeAssertions.min.mjs";import{LEFT as c,TOP as a,CENTER as l}from"../constants.min.mjs";import"../util/misc/vectors.min.mjs";import"../util/misc/projectStroke/StrokeLineJoinProjections.min.mjs";import"../config.min.mjs";import"./Group.min.mjs";import{makeBoundingBoxFromPoints as p}from"../util/misc/boundingBoxFromPoints.min.mjs";import"../cache.min.mjs";import"../parser/constants.min.mjs";import"../util/animation/AnimationRegistry.min.mjs";import{cacheProperties as y}from"./Object/defaultValues.min.mjs";const u=["x1","y1","x2","y2"],x=["x1","y1","x2","y2"],j=["x1","x2","y1","y2"];class d extends n{constructor(){let[t,i,s,e]=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[0,0,0,0],o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),Object.assign(this,d.ownDefaults),this.setOptions(o),this.x1=t,this.x2=s,this.y1=i,this.y2=e,this._setWidthHeight();const{left:r,top:n}=o;"number"==typeof r&&this.set(c,r),"number"==typeof n&&this.set(a,n)}_setWidthHeight(){const{x1:t,y1:i,x2:s,y2:e}=this;this.width=Math.abs(s-t),this.height=Math.abs(e-i);const{left:o,top:r,width:n,height:h}=p([{x:t,y:i},{x:s,y:e}]),c=new m(o+n/2,r+h/2);this.setPositionByOrigin(c,l,l)}_set(t,i){return super._set(t,i),j.includes(t)&&this._setWidthHeight(),this}_render(t){t.beginPath();const i=this.calcLinePoints();t.moveTo(i.x1,i.y1),t.lineTo(i.x2,i.y2),t.lineWidth=this.strokeWidth;const s=t.strokeStyle;var e;h(this.stroke)?t.strokeStyle=this.stroke.toLive(t):t.strokeStyle=null!==(e=this.stroke)&&void 0!==e?e:t.fillStyle;this.stroke&&this._renderStroke(t),t.strokeStyle=s}_findCenterFromElement(){return new m((this.x1+this.x2)/2,(this.y1+this.y2)/2)}toObject(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return i(i({},super.toObject(t)),this.calcLinePoints())}_getNonTransformedDimensions(){const t=super._getNonTransformedDimensions();return"butt"===this.strokeLineCap&&(0===this.width&&(t.y-=this.strokeWidth),0===this.height&&(t.x-=this.strokeWidth)),t}calcLinePoints(){const{x1:t,x2:i,y1:s,y2:e,width:o,height:r}=this,n=t<=i?-1:1,m=s<=e?-1:1;return{x1:n*o/2,x2:n*-o/2,y1:m*r/2,y2:m*-r/2}}_toSVG(){const{x1:t,x2:i,y1:s,y2:e}=this.calcLinePoints();return["<line ","COMMON_PARTS",'x1="'.concat(t,'" y1="').concat(s,'" x2="').concat(i,'" y2="').concat(e,'" />\n')]}static async fromElement(t,i,e){const r=o(t,this.ATTRIBUTE_NAMES,e),{x1:n=0,y1:m=0,x2:h=0,y2:c=0}=r;return new this([n,m,h,c],s(r,u))}static fromObject(t){let{x1:e,y1:o,x2:r,y2:n}=t,m=s(t,x);return this._fromObject(i(i({},m),{},{points:[e,o,r,n]}),{extraParam:"points"})}}t(d,"type","Line"),t(d,"cacheProperties",[...y,...j]),t(d,"ATTRIBUTE_NAMES",e.concat(j)),r.setClass(d),r.setSVGClass(d);export{d as Line};
//# sourceMappingURL=Line.min.mjs.map
