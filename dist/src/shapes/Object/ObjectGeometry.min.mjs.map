{"version":3,"file":"ObjectGeometry.min.mjs","sources":["../../../../src/shapes/Object/ObjectGeometry.ts"],"sourcesContent":["import type {\n  TBBox,\n  TCornerPoint,\n  TDegree,\n  TMat2D,\n  TOriginX,\n  TOriginY,\n} from '../../typedefs';\nimport { SCALE_X, SCALE_Y, iMatrix } from '../../constants';\nimport { Intersection } from '../../Intersection';\nimport { Point } from '../../Point';\nimport { makeBoundingBoxFromPoints } from '../../util/misc/boundingBoxFromPoints';\nimport {\n  createRotateMatrix,\n  createTranslateMatrix,\n  composeMatrix,\n  invertTransform,\n  multiplyTransformMatrices,\n  transformPoint,\n  calcPlaneRotation,\n} from '../../util/misc/matrix';\nimport { radiansToDegrees } from '../../util/misc/radiansDegreesConversion';\nimport type { Canvas } from '../../canvas/Canvas';\nimport type { StaticCanvas } from '../../canvas/StaticCanvas';\nimport type { ObjectEvents } from '../../EventTypeDefs';\nimport type { ControlProps } from './types/ControlProps';\nimport { resolveOrigin } from '../../util/misc/resolveOrigin';\nimport type { Group } from '../Group';\nimport { calcDimensionsMatrix } from '../../util/misc/matrix';\nimport { sizeAfterTransform } from '../../util/misc/objectTransforms';\nimport { degreesToRadians } from '../../util/misc/radiansDegreesConversion';\nimport { CommonMethods } from '../../CommonMethods';\nimport type { BaseProps } from './types/BaseProps';\nimport type { FillStrokeProps } from './types/FillStrokeProps';\nimport { CENTER, LEFT, TOP } from '../../constants';\n\ntype TMatrixCache = {\n  key: number[];\n  value: TMat2D;\n};\n\ntype TACoords = TCornerPoint;\n\nexport class ObjectGeometry<EventSpec extends ObjectEvents = ObjectEvents>\n  extends CommonMethods<EventSpec>\n  implements\n    Pick<ControlProps, 'padding'>,\n    BaseProps,\n    Pick<FillStrokeProps, 'strokeWidth' | 'strokeUniform'>\n{\n  // #region Geometry\n\n  declare padding: number;\n\n  /**\n   * Describe object's corner position in scene coordinates.\n   * The coordinates are derived from the following:\n   * left, top, width, height, scaleX, scaleY, skewX, skewY, angle, strokeWidth.\n   * The coordinates do not depend on viewport changes.\n   * The coordinates get updated with {@link setCoords}.\n   * You can calculate them without updating with {@link calcACoords()}\n   */\n  declare aCoords: TACoords;\n\n  /**\n   * storage cache for object transform matrix\n   */\n  declare ownMatrixCache?: TMatrixCache;\n\n  /**\n   * storage cache for object full transform matrix\n   */\n  declare matrixCache?: TMatrixCache;\n\n  /**\n   * A Reference of the Canvas where the object is actually added\n   * @type StaticCanvas | Canvas;\n   * @default undefined\n   * @private\n   */\n  declare canvas?: StaticCanvas | Canvas;\n\n  /**\n   * @returns {number} x position according to object's {@link originX} property in canvas coordinate plane\n   */\n  getX(): number {\n    return this.getXY().x;\n  }\n\n  /**\n   * @param {number} value x position according to object's {@link originX} property in canvas coordinate plane\n   */\n  setX(value: number) {\n    this.setXY(this.getXY().setX(value));\n  }\n\n  /**\n   * @returns {number} y position according to object's {@link originY} property in canvas coordinate plane\n   */\n  getY(): number {\n    return this.getXY().y;\n  }\n\n  /**\n   * @param {number} value y position according to object's {@link originY} property in canvas coordinate plane\n   */\n  setY(value: number) {\n    this.setXY(this.getXY().setY(value));\n  }\n\n  /**\n   * @returns {number} x position according to object's {@link originX} property in parent's coordinate plane\\\n   * if parent is canvas then this property is identical to {@link getX}\n   */\n  getRelativeX(): number {\n    return this.left;\n  }\n\n  /**\n   * @param {number} value x position according to object's {@link originX} property in parent's coordinate plane\\\n   * if parent is canvas then this method is identical to {@link setX}\n   */\n  setRelativeX(value: number) {\n    this.left = value;\n  }\n\n  /**\n   * @returns {number} y position according to object's {@link originY} property in parent's coordinate plane\\\n   * if parent is canvas then this property is identical to {@link getY}\n   */\n  getRelativeY(): number {\n    return this.top;\n  }\n\n  /**\n   * @param {number} value y position according to object's {@link originY} property in parent's coordinate plane\\\n   * if parent is canvas then this property is identical to {@link setY}\n   */\n  setRelativeY(value: number) {\n    this.top = value;\n  }\n\n  /**\n   * @returns {Point} x position according to object's {@link originX} {@link originY} properties in canvas coordinate plane\n   */\n  getXY(): Point {\n    const relativePosition = this.getRelativeXY();\n    return this.group\n      ? transformPoint(relativePosition, this.group.calcTransformMatrix())\n      : relativePosition;\n  }\n\n  /**\n   * Set an object position to a particular point, the point is intended in absolute ( canvas ) coordinate.\n   * You can specify {@link originX} and {@link originY} values,\n   * that otherwise are the object's current values.\n   * @example <caption>Set object's bottom left corner to point (5,5) on canvas</caption>\n   * object.setXY(new Point(5, 5), 'left', 'bottom').\n   * @param {Point} point position in scene coordinate plane\n   * @param {TOriginX} [originX] Horizontal origin: 'left', 'center' or 'right'\n   * @param {TOriginY} [originY] Vertical origin: 'top', 'center' or 'bottom'\n   */\n  setXY(point: Point, originX?: TOriginX, originY?: TOriginY) {\n    if (this.group) {\n      point = transformPoint(\n        point,\n        invertTransform(this.group.calcTransformMatrix()),\n      );\n    }\n    this.setRelativeXY(point, originX, originY);\n  }\n\n  /**\n   * @returns {Point} x,y position according to object's {@link originX} {@link originY} properties in parent's coordinate plane\n   */\n  getRelativeXY(): Point {\n    return new Point(this.left, this.top);\n  }\n\n  /**\n   * As {@link setXY}, but in current parent's coordinate plane (the current group if any or the canvas)\n   * @param {Point} point position according to object's {@link originX} {@link originY} properties in parent's coordinate plane\n   * @param {TOriginX} [originX] Horizontal origin: 'left', 'center' or 'right'\n   * @param {TOriginY} [originY] Vertical origin: 'top', 'center' or 'bottom'\n   */\n  setRelativeXY(\n    point: Point,\n    originX: TOriginX = this.originX,\n    originY: TOriginY = this.originY,\n  ) {\n    this.setPositionByOrigin(point, originX, originY);\n  }\n\n  /**\n   * @deprecated intermidiate method to be removed, do not use\n   */\n  protected isStrokeAccountedForInDimensions() {\n    return false;\n  }\n\n  /**\n   * @return {Point[]} [tl, tr, br, bl] in the scene plane\n   */\n  getCoords(): Point[] {\n    const { tl, tr, br, bl } =\n      this.aCoords || (this.aCoords = this.calcACoords());\n    const coords = [tl, tr, br, bl];\n    if (this.group) {\n      const t = this.group.calcTransformMatrix();\n      return coords.map((p) => transformPoint(p, t));\n    }\n    return coords;\n  }\n\n  /**\n   * Checks if object intersects with the scene rect formed by {@link tl} and {@link br}\n   */\n  intersectsWithRect(tl: Point, br: Point): boolean {\n    const intersection = Intersection.intersectPolygonRectangle(\n      this.getCoords(),\n      tl,\n      br,\n    );\n    return intersection.status === 'Intersection';\n  }\n\n  /**\n   * Checks if object intersects with another object\n   * @param {Object} other Object to test\n   * @return {Boolean} true if object intersects with another object\n   */\n  intersectsWithObject(other: ObjectGeometry): boolean {\n    const intersection = Intersection.intersectPolygonPolygon(\n      this.getCoords(),\n      other.getCoords(),\n    );\n\n    return (\n      intersection.status === 'Intersection' ||\n      intersection.status === 'Coincident' ||\n      other.isContainedWithinObject(this) ||\n      this.isContainedWithinObject(other)\n    );\n  }\n\n  /**\n   * Checks if object is fully contained within area of another object\n   * @param {Object} other Object to test\n   * @return {Boolean} true if object is fully contained within area of another object\n   */\n  isContainedWithinObject(other: ObjectGeometry): boolean {\n    const points = this.getCoords();\n    return points.every((point) => other.containsPoint(point));\n  }\n\n  /**\n   * Checks if object is fully contained within the scene rect formed by {@link tl} and {@link br}\n   */\n  isContainedWithinRect(tl: Point, br: Point): boolean {\n    const { left, top, width, height } = this.getBoundingRect();\n    return (\n      left >= tl.x &&\n      left + width <= br.x &&\n      top >= tl.y &&\n      top + height <= br.y\n    );\n  }\n\n  isOverlapping<T extends ObjectGeometry>(other: T): boolean {\n    return (\n      this.intersectsWithObject(other) ||\n      this.isContainedWithinObject(other) ||\n      other.isContainedWithinObject(this)\n    );\n  }\n\n  /**\n   * Checks if point is inside the object\n   * @param {Point} point Point to check against\n   * @return {Boolean} true if point is inside the object\n   */\n  containsPoint(point: Point): boolean {\n    return Intersection.isPointInPolygon(point, this.getCoords());\n  }\n\n  /**\n   * Checks if object is contained within the canvas with current viewportTransform\n   * the check is done stopping at first point that appears on screen\n   * @return {Boolean} true if object is fully or partially contained within canvas\n   */\n  isOnScreen(): boolean {\n    if (!this.canvas) {\n      return false;\n    }\n    const { tl, br } = this.canvas.vptCoords;\n    const points = this.getCoords();\n    // if some point is on screen, the object is on screen.\n    if (\n      points.some(\n        (point) =>\n          point.x <= br.x &&\n          point.x >= tl.x &&\n          point.y <= br.y &&\n          point.y >= tl.y,\n      )\n    ) {\n      return true;\n    }\n    // no points on screen, check intersection with absolute coordinates\n    if (this.intersectsWithRect(tl, br)) {\n      return true;\n    }\n    // check if the object is so big that it contains the entire viewport\n    return this.containsPoint(tl.midPointFrom(br));\n  }\n\n  /**\n   * Checks if object is partially contained within the canvas with current viewportTransform\n   * @return {Boolean} true if object is partially contained within canvas\n   */\n  isPartiallyOnScreen(): boolean {\n    if (!this.canvas) {\n      return false;\n    }\n    const { tl, br } = this.canvas.vptCoords;\n    if (this.intersectsWithRect(tl, br)) {\n      return true;\n    }\n    const allPointsAreOutside = this.getCoords().every(\n      (point) =>\n        (point.x >= br.x || point.x <= tl.x) &&\n        (point.y >= br.y || point.y <= tl.y),\n    );\n    // check if the object is so big that it contains the entire viewport\n    return allPointsAreOutside && this.containsPoint(tl.midPointFrom(br));\n  }\n\n  /**\n   * Returns coordinates of object's bounding rectangle (left, top, width, height)\n   * the box is intended as aligned to axis of canvas.\n   * @return {Object} Object with left, top, width, height properties\n   */\n  getBoundingRect(): TBBox {\n    return makeBoundingBoxFromPoints(this.getCoords());\n  }\n\n  /**\n   * Returns width of an object's bounding box counting transformations\n   * @todo shouldn't this account for group transform and return the actual size in canvas coordinate plane?\n   * @return {Number} width value\n   */\n  getScaledWidth(): number {\n    return this._getTransformedDimensions().x;\n  }\n\n  /**\n   * Returns height of an object bounding box counting transformations\n   * @todo shouldn't this account for group transform and return the actual size in canvas coordinate plane?\n   * @return {Number} height value\n   */\n  getScaledHeight(): number {\n    return this._getTransformedDimensions().y;\n  }\n\n  /**\n   * Scales an object (equally by x and y)\n   * @param {Number} value Scale factor\n   * @return {void}\n   */\n  scale(value: number): void {\n    this._set(SCALE_X, value);\n    this._set(SCALE_Y, value);\n    this.setCoords();\n  }\n\n  /**\n   * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)\n   * @param {Number} value New width value\n   * @return {void}\n   */\n  scaleToWidth(value: number) {\n    // adjust to bounding rect factor so that rotated shapes would fit as well\n    const boundingRectFactor =\n      this.getBoundingRect().width / this.getScaledWidth();\n    return this.scale(value / this.width / boundingRectFactor);\n  }\n\n  /**\n   * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)\n   * @param {Number} value New height value\n   * @return {void}\n   */\n  scaleToHeight(value: number) {\n    // adjust to bounding rect factor so that rotated shapes would fit as well\n    const boundingRectFactor =\n      this.getBoundingRect().height / this.getScaledHeight();\n    return this.scale(value / this.height / boundingRectFactor);\n  }\n\n  getCanvasRetinaScaling() {\n    return this.canvas?.getRetinaScaling() || 1;\n  }\n\n  /**\n   * Returns the object angle relative to canvas counting also the group property\n   * @returns {TDegree}\n   */\n  getTotalAngle(): TDegree {\n    return this.group\n      ? radiansToDegrees(calcPlaneRotation(this.calcTransformMatrix()))\n      : this.angle;\n  }\n\n  /**\n   * Retrieves viewportTransform from Object's canvas if available\n   * @return {TMat2D}\n   */\n  getViewportTransform(): TMat2D {\n    return this.canvas?.viewportTransform || (iMatrix.concat() as TMat2D);\n  }\n\n  /**\n   * Calculates the coordinates of the 4 corner of the bbox, in absolute coordinates.\n   * those never change with zoom or viewport changes.\n   * @return {TCornerPoint}\n   */\n  calcACoords(): TCornerPoint {\n    const rotateMatrix = createRotateMatrix({ angle: this.angle }),\n      { x, y } = this.getRelativeCenterPoint(),\n      tMatrix = createTranslateMatrix(x, y),\n      finalMatrix = multiplyTransformMatrices(tMatrix, rotateMatrix),\n      dim = this._getTransformedDimensions(),\n      w = dim.x / 2,\n      h = dim.y / 2;\n    return {\n      // corners\n      tl: transformPoint({ x: -w, y: -h }, finalMatrix),\n      tr: transformPoint({ x: w, y: -h }, finalMatrix),\n      bl: transformPoint({ x: -w, y: h }, finalMatrix),\n      br: transformPoint({ x: w, y: h }, finalMatrix),\n    };\n  }\n\n  /**\n   * Sets corner and controls position coordinates based on current angle, width and height, left and top.\n   * aCoords are used to quickly find an object on the canvas.\n   * See {@link https://github.com/fabricjs/fabric.js/wiki/When-to-call-setCoords} and {@link http://fabricjs.com/fabric-gotchas}\n   */\n  setCoords(): void {\n    this.aCoords = this.calcACoords();\n  }\n\n  transformMatrixKey(skipGroup = false): number[] {\n    let prefix: number[] = [];\n    if (!skipGroup && this.group) {\n      prefix = this.group.transformMatrixKey(skipGroup);\n    }\n    prefix.push(\n      this.top,\n      this.left,\n      this.width,\n      this.height,\n      this.scaleX,\n      this.scaleY,\n      this.angle,\n      this.strokeWidth,\n      this.skewX,\n      this.skewY,\n      +this.flipX,\n      +this.flipY,\n      resolveOrigin(this.originX),\n      resolveOrigin(this.originY),\n    );\n\n    return prefix;\n  }\n\n  /**\n   * calculate transform matrix that represents the current transformations from the\n   * object's properties.\n   * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations\n   * There are some situation in which this is useful to avoid the fake rotation.\n   * @return {TMat2D} transform matrix for the object\n   */\n  calcTransformMatrix(skipGroup = false): TMat2D {\n    let matrix = this.calcOwnMatrix();\n    if (skipGroup || !this.group) {\n      return matrix;\n    }\n    const key = this.transformMatrixKey(skipGroup),\n      cache = this.matrixCache;\n    if (cache && cache.key.every((x, i) => x === key[i])) {\n      return cache.value;\n    }\n    if (this.group) {\n      matrix = multiplyTransformMatrices(\n        this.group.calcTransformMatrix(false),\n        matrix,\n      );\n    }\n    this.matrixCache = {\n      key,\n      value: matrix,\n    };\n    return matrix;\n  }\n\n  /**\n   * calculate transform matrix that represents the current transformations from the\n   * object's properties, this matrix does not include the group transformation\n   * @return {TMat2D} transform matrix for the object\n   */\n  calcOwnMatrix(): TMat2D {\n    const key = this.transformMatrixKey(true),\n      cache = this.ownMatrixCache;\n    if (cache && cache.key === key) {\n      return cache.value;\n    }\n    const center = this.getRelativeCenterPoint(),\n      options = {\n        angle: this.angle,\n        translateX: center.x,\n        translateY: center.y,\n        scaleX: this.scaleX,\n        scaleY: this.scaleY,\n        skewX: this.skewX,\n        skewY: this.skewY,\n        flipX: this.flipX,\n        flipY: this.flipY,\n      },\n      value = composeMatrix(options);\n    this.ownMatrixCache = {\n      key,\n      value,\n    };\n    return value;\n  }\n\n  /**\n   * Calculate object dimensions from its properties\n   * @private\n   * @returns {Point} dimensions\n   */\n  _getNonTransformedDimensions(): Point {\n    return new Point(this.width, this.height).scalarAdd(this.strokeWidth);\n  }\n\n  /**\n   * Calculate object dimensions for controls box, including padding and canvas zoom.\n   * and active selection\n   * @private\n   * @param {object} [options] transform options\n   * @returns {Point} dimensions\n   */\n  _calculateCurrentDimensions(options?: any): Point {\n    return this._getTransformedDimensions(options)\n      .transform(this.getViewportTransform(), true)\n      .scalarAdd(2 * this.padding);\n  }\n\n  // #region Origin\n\n  declare top: number;\n  declare left: number;\n  declare width: number;\n  declare height: number;\n  declare flipX: boolean;\n  declare flipY: boolean;\n  declare scaleX: number;\n  declare scaleY: number;\n  declare skewX: number;\n  declare skewY: number;\n  /**\n   * @deprecated please use 'center' as value in new projects\n   * */\n  declare originX: TOriginX;\n  /**\n   * @deprecated please use 'center' as value in new projects\n   * */\n  declare originY: TOriginY;\n  declare angle: TDegree;\n  declare strokeWidth: number;\n  declare strokeUniform: boolean;\n\n  /**\n   * Object containing this object.\n   * can influence its size and position\n   */\n  declare group?: Group;\n\n  /**\n   * Calculate object bounding box dimensions from its properties scale, skew.\n   * This bounding box is aligned with object angle and not with canvas axis or screen.\n   * @param {Object} [options]\n   * @param {Number} [options.scaleX]\n   * @param {Number} [options.scaleY]\n   * @param {Number} [options.skewX]\n   * @param {Number} [options.skewY]\n   * @private\n   * @returns {Point} dimensions\n   */\n  _getTransformedDimensions(options: any = {}): Point {\n    const dimOptions = {\n      // if scaleX or scaleY are negative numbers,\n      // this will return dimensions that are negative.\n      // and this will break assumptions around the codebase\n      scaleX: this.scaleX,\n      scaleY: this.scaleY,\n      skewX: this.skewX,\n      skewY: this.skewY,\n      width: this.width,\n      height: this.height,\n      strokeWidth: this.strokeWidth,\n      ...options,\n    };\n    // stroke is applied before/after transformations are applied according to `strokeUniform`\n    const strokeWidth = dimOptions.strokeWidth;\n    let preScalingStrokeValue = strokeWidth,\n      postScalingStrokeValue = 0;\n\n    if (this.strokeUniform) {\n      preScalingStrokeValue = 0;\n      postScalingStrokeValue = strokeWidth;\n    }\n    const dimX = dimOptions.width + preScalingStrokeValue,\n      dimY = dimOptions.height + preScalingStrokeValue,\n      noSkew = dimOptions.skewX === 0 && dimOptions.skewY === 0;\n    let finalDimensions;\n    if (noSkew) {\n      finalDimensions = new Point(\n        dimX * dimOptions.scaleX,\n        dimY * dimOptions.scaleY,\n      );\n    } else {\n      finalDimensions = sizeAfterTransform(\n        dimX,\n        dimY,\n        calcDimensionsMatrix(dimOptions),\n      );\n    }\n\n    return finalDimensions.scalarAdd(postScalingStrokeValue);\n  }\n\n  /**\n   * Translates the coordinates from a set of origin to another (based on the object's dimensions)\n   * @param {Point} point The point which corresponds to the originX and originY params\n   * @param {TOriginX} fromOriginX Horizontal origin: 'left', 'center' or 'right'\n   * @param {TOriginY} fromOriginY Vertical origin: 'top', 'center' or 'bottom'\n   * @param {TOriginX} toOriginX Horizontal origin: 'left', 'center' or 'right'\n   * @param {TOriginY} toOriginY Vertical origin: 'top', 'center' or 'bottom'\n   * @return {Point}\n   */\n  translateToGivenOrigin(\n    point: Point,\n    fromOriginX: TOriginX,\n    fromOriginY: TOriginY,\n    toOriginX: TOriginX,\n    toOriginY: TOriginY,\n  ): Point {\n    let x = point.x,\n      y = point.y;\n    const offsetX = resolveOrigin(toOriginX) - resolveOrigin(fromOriginX),\n      offsetY = resolveOrigin(toOriginY) - resolveOrigin(fromOriginY);\n\n    if (offsetX || offsetY) {\n      const dim = this._getTransformedDimensions();\n      x += offsetX * dim.x;\n      y += offsetY * dim.y;\n    }\n\n    return new Point(x, y);\n  }\n\n  /**\n   * Translates the coordinates from origin to center coordinates (based on the object's dimensions)\n   * @param {Point} point The point which corresponds to the originX and originY params\n   * @param {TOriginX} originX Horizontal origin: 'left', 'center' or 'right'\n   * @param {TOriginY} originY Vertical origin: 'top', 'center' or 'bottom'\n   * @return {Point}\n   */\n  translateToCenterPoint(\n    point: Point,\n    originX: TOriginX,\n    originY: TOriginY,\n  ): Point {\n    if (originX === CENTER && originY === CENTER) {\n      return point;\n    }\n    const p = this.translateToGivenOrigin(\n      point,\n      originX,\n      originY,\n      CENTER,\n      CENTER,\n    );\n    if (this.angle) {\n      return p.rotate(degreesToRadians(this.angle), point);\n    }\n    return p;\n  }\n\n  /**\n   * Translates the coordinates from center to origin coordinates (based on the object's dimensions)\n   * @param {Point} center The point which corresponds to center of the object\n   * @param {OriginX} originX Horizontal origin: 'left', 'center' or 'right'\n   * @param {OriginY} originY Vertical origin: 'top', 'center' or 'bottom'\n   * @return {Point}\n   */\n  translateToOriginPoint(\n    center: Point,\n    originX: TOriginX,\n    originY: TOriginY,\n  ): Point {\n    const p = this.translateToGivenOrigin(\n      center,\n      CENTER,\n      CENTER,\n      originX,\n      originY,\n    );\n    if (this.angle) {\n      return p.rotate(degreesToRadians(this.angle), center);\n    }\n    return p;\n  }\n\n  /**\n   * Returns the center coordinates of the object relative to canvas\n   * @return {Point}\n   */\n  getCenterPoint(): Point {\n    const relCenter = this.getRelativeCenterPoint();\n    return this.group\n      ? transformPoint(relCenter, this.group.calcTransformMatrix())\n      : relCenter;\n  }\n\n  /**\n   * Returns the center coordinates of the object relative to it's parent\n   * @return {Point}\n   */\n  getRelativeCenterPoint(): Point {\n    return this.translateToCenterPoint(\n      new Point(this.left, this.top),\n      this.originX,\n      this.originY,\n    );\n  }\n\n  /**\n   * Returns the position of the object as if it has a different origin.\n   * Take an object that has left, top set to 100, 100 with origin 'left', 'top'.\n   * Return the values of left top ( wrapped in a point ) that you would need to keep\n   * the same position if origin where different.\n   * Alternatively you can use this to also find which point in the parent plane is a specific origin\n   * ( where is the bottom right corner of my object? )\n   * @param {TOriginX} originX Horizontal origin: 'left', 'center' or 'right'\n   * @param {TOriginY} originY Vertical origin: 'top', 'center' or 'bottom'\n   * @return {Point}\n   */\n  getPointByOrigin(originX: TOriginX, originY: TOriginY): Point {\n    return this.translateToOriginPoint(\n      this.getRelativeCenterPoint(),\n      originX,\n      originY,\n    );\n  }\n\n  /**\n   * Sets the position of the object taking into consideration the object's origin\n   * @param {Point} pos The new position of the object\n   * @param {TOriginX} originX Horizontal origin: 'left', 'center' or 'right'\n   * @param {TOriginY} originY Vertical origin: 'top', 'center' or 'bottom'\n   * @return {void}\n   */\n  setPositionByOrigin(pos: Point, originX: TOriginX, originY: TOriginY) {\n    const center = this.translateToCenterPoint(pos, originX, originY),\n      position = this.translateToOriginPoint(\n        center,\n        this.originX,\n        this.originY,\n      );\n    this.set({ left: position.x, top: position.y });\n  }\n\n  /**\n   * @private\n   */\n  _getLeftTopCoords() {\n    return this.translateToOriginPoint(\n      this.getRelativeCenterPoint(),\n      LEFT,\n      TOP,\n    );\n  }\n}\n"],"names":["ObjectGeometry","CommonMethods","getX","this","getXY","x","setX","value","setXY","getY","y","setY","getRelativeX","left","setRelativeX","getRelativeY","top","setRelativeY","relativePosition","getRelativeXY","group","transformPoint","calcTransformMatrix","point","originX","originY","invertTransform","setRelativeXY","Point","arguments","length","undefined","setPositionByOrigin","isStrokeAccountedForInDimensions","getCoords","tl","tr","br","bl","aCoords","calcACoords","coords","t","map","p","intersectsWithRect","Intersection","intersectPolygonRectangle","status","intersectsWithObject","other","intersection","intersectPolygonPolygon","isContainedWithinObject","every","containsPoint","isContainedWithinRect","width","height","getBoundingRect","isOverlapping","isPointInPolygon","isOnScreen","canvas","vptCoords","some","midPointFrom","isPartiallyOnScreen","makeBoundingBoxFromPoints","getScaledWidth","_getTransformedDimensions","getScaledHeight","scale","_set","SCALE_X","SCALE_Y","setCoords","scaleToWidth","boundingRectFactor","scaleToHeight","getCanvasRetinaScaling","_this$canvas","getRetinaScaling","getTotalAngle","radiansToDegrees","calcPlaneRotation","angle","getViewportTransform","_this$canvas2","viewportTransform","iMatrix","concat","rotateMatrix","createRotateMatrix","getRelativeCenterPoint","tMatrix","createTranslateMatrix","finalMatrix","multiplyTransformMatrices","dim","w","h","transformMatrixKey","skipGroup","prefix","push","scaleX","scaleY","strokeWidth","skewX","skewY","flipX","flipY","resolveOrigin","matrix","calcOwnMatrix","key","cache","matrixCache","i","ownMatrixCache","center","options","translateX","translateY","composeMatrix","_getNonTransformedDimensions","scalarAdd","_calculateCurrentDimensions","transform","padding","dimOptions","_objectSpread","preScalingStrokeValue","postScalingStrokeValue","strokeUniform","dimX","dimY","finalDimensions","sizeAfterTransform","calcDimensionsMatrix","translateToGivenOrigin","fromOriginX","fromOriginY","toOriginX","toOriginY","offsetX","offsetY","translateToCenterPoint","CENTER","rotate","degreesToRadians","translateToOriginPoint","getCenterPoint","relCenter","getPointByOrigin","pos","position","set","_getLeftTopCoords","LEFT","TOP"],"mappings":"o6BA2CO,MAAMA,UACHC,EAyCRC,IAAAA,GACE,OAAOC,KAAKC,QAAQC,CACtB,CAKAC,IAAAA,CAAKC,GACHJ,KAAKK,MAAML,KAAKC,QAAQE,KAAKC,GAC/B,CAKAE,IAAAA,GACE,OAAON,KAAKC,QAAQM,CACtB,CAKAC,IAAAA,CAAKJ,GACHJ,KAAKK,MAAML,KAAKC,QAAQO,KAAKJ,GAC/B,CAMAK,YAAAA,GACE,OAAOT,KAAKU,IACd,CAMAC,YAAAA,CAAaP,GACXJ,KAAKU,KAAON,CACd,CAMAQ,YAAAA,GACE,OAAOZ,KAAKa,GACd,CAMAC,YAAAA,CAAaV,GACXJ,KAAKa,IAAMT,CACb,CAKAH,KAAAA,GACE,MAAMc,EAAmBf,KAAKgB,gBAC9B,OAAOhB,KAAKiB,MACRC,EAAeH,EAAkBf,KAAKiB,MAAME,uBAC5CJ,CACN,CAYAV,KAAAA,CAAMe,EAAcC,EAAoBC,GAClCtB,KAAKiB,QACPG,EAAQF,EACNE,EACAG,EAAgBvB,KAAKiB,MAAME,yBAG/BnB,KAAKwB,cAAcJ,EAAOC,EAASC,EACrC,CAKAN,aAAAA,GACE,OAAO,IAAIS,EAAMzB,KAAKU,KAAMV,KAAKa,IACnC,CAQAW,aAAAA,CACEJ,GAGA,IAFAC,EAAiBK,UAAAC,OAAAD,QAAAE,IAAAF,UAAAE,GAAAF,UAAG,GAAA1B,KAAKqB,QACzBC,EAAiBI,UAAAC,OAAAD,QAAAE,IAAAF,UAAAE,GAAAF,UAAG,GAAA1B,KAAKsB,QAEzBtB,KAAK6B,oBAAoBT,EAAOC,EAASC,EAC3C,CAKUQ,gCAAAA,GACR,OAAO,CACT,CAKAC,SAAAA,GACE,MAAMC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,EAAEC,GAAEA,GAClBnC,KAAKoC,UAAYpC,KAAKoC,QAAUpC,KAAKqC,eACjCC,EAAS,CAACN,EAAIC,EAAIC,EAAIC,GAC5B,GAAInC,KAAKiB,MAAO,CACd,MAAMsB,EAAIvC,KAAKiB,MAAME,sBACrB,OAAOmB,EAAOE,KAAKC,GAAMvB,EAAeuB,EAAGF,IAC7C,CACA,OAAOD,CACT,CAKAI,kBAAAA,CAAmBV,EAAWE,GAM5B,MAA+B,iBALVS,EAAaC,0BAChC5C,KAAK+B,YACLC,EACAE,GAEkBW,MACtB,CAOAC,oBAAAA,CAAqBC,GACnB,MAAMC,EAAeL,EAAaM,wBAChCjD,KAAK+B,YACLgB,EAAMhB,aAGR,MAC0B,iBAAxBiB,EAAaH,QACW,eAAxBG,EAAaH,QACbE,EAAMG,wBAAwBlD,OAC9BA,KAAKkD,wBAAwBH,EAEjC,CAOAG,uBAAAA,CAAwBH,GAEtB,OADe/C,KAAK+B,YACNoB,OAAO/B,GAAU2B,EAAMK,cAAchC,IACrD,CAKAiC,qBAAAA,CAAsBrB,EAAWE,GAC/B,MAAMxB,KAAEA,EAAIG,IAAEA,EAAGyC,MAAEA,EAAKC,OAAEA,GAAWvD,KAAKwD,kBAC1C,OACE9C,GAAQsB,EAAG9B,GACXQ,EAAO4C,GAASpB,EAAGhC,GACnBW,GAAOmB,EAAGzB,GACVM,EAAM0C,GAAUrB,EAAG3B,CAEvB,CAEAkD,aAAAA,CAAwCV,GACtC,OACE/C,KAAK8C,qBAAqBC,IAC1B/C,KAAKkD,wBAAwBH,IAC7BA,EAAMG,wBAAwBlD,KAElC,CAOAoD,aAAAA,CAAchC,GACZ,OAAOuB,EAAae,iBAAiBtC,EAAOpB,KAAK+B,YACnD,CAOA4B,UAAAA,GACE,IAAK3D,KAAK4D,OACR,OAAO,EAET,MAAM5B,GAAEA,EAAEE,GAAEA,GAAOlC,KAAK4D,OAAOC,UAG/B,QAFe7D,KAAK+B,YAGX+B,MACJ1C,GACCA,EAAMlB,GAAKgC,EAAGhC,GACdkB,EAAMlB,GAAK8B,EAAG9B,GACdkB,EAAMb,GAAK2B,EAAG3B,GACda,EAAMb,GAAKyB,EAAGzB,QAMhBP,KAAK0C,mBAAmBV,EAAIE,IAIzBlC,KAAKoD,cAAcpB,EAAG+B,aAAa7B,IAC5C,CAMA8B,mBAAAA,GACE,IAAKhE,KAAK4D,OACR,OAAO,EAET,MAAM5B,GAAEA,EAAEE,GAAEA,GAAOlC,KAAK4D,OAAOC,UAC/B,GAAI7D,KAAK0C,mBAAmBV,EAAIE,GAC9B,OAAO,EAQT,OAN4BlC,KAAK+B,YAAYoB,OAC1C/B,IACEA,EAAMlB,GAAKgC,EAAGhC,GAAKkB,EAAMlB,GAAK8B,EAAG9B,KACjCkB,EAAMb,GAAK2B,EAAG3B,GAAKa,EAAMb,GAAKyB,EAAGzB,MAGRP,KAAKoD,cAAcpB,EAAG+B,aAAa7B,GACnE,CAOAsB,eAAAA,GACE,OAAOS,EAA0BjE,KAAK+B,YACxC,CAOAmC,cAAAA,GACE,OAAOlE,KAAKmE,4BAA4BjE,CAC1C,CAOAkE,eAAAA,GACE,OAAOpE,KAAKmE,4BAA4B5D,CAC1C,CAOA8D,KAAAA,CAAMjE,GACJJ,KAAKsE,KAAKC,EAASnE,GACnBJ,KAAKsE,KAAKE,EAASpE,GACnBJ,KAAKyE,WACP,CAOAC,YAAAA,CAAatE,GAEX,MAAMuE,EACJ3E,KAAKwD,kBAAkBF,MAAQtD,KAAKkE,iBACtC,OAAOlE,KAAKqE,MAAMjE,EAAQJ,KAAKsD,MAAQqB,EACzC,CAOAC,aAAAA,CAAcxE,GAEZ,MAAMuE,EACJ3E,KAAKwD,kBAAkBD,OAASvD,KAAKoE,kBACvC,OAAOpE,KAAKqE,MAAMjE,EAAQJ,KAAKuD,OAASoB,EAC1C,CAEAE,sBAAAA,GAAyB,IAAAC,EACvB,OAAkBA,QAAXA,EAAI9E,KAAC4D,cAALkB,IAAWA,OAAXA,EAAAA,EAAaC,qBAAsB,CAC5C,CAMAC,aAAAA,GACE,OAAOhF,KAAKiB,MACRgE,EAAiBC,EAAkBlF,KAAKmB,wBACxCnB,KAAKmF,KACX,CAMAC,oBAAAA,GAA+B,IAAAC,EAC7B,eAAOA,EAAArF,KAAK4D,cAAM,IAAAyB,OAAA,EAAXA,EAAaC,oBAAsBC,EAAQC,QACpD,CAOAnD,WAAAA,GACE,MAAMoD,EAAeC,EAAmB,CAAEP,MAAOnF,KAAKmF,SACpDjF,EAAEA,EAACK,EAAEA,GAAMP,KAAK2F,yBAChBC,EAAUC,EAAsB3F,EAAGK,GACnCuF,EAAcC,EAA0BH,EAASH,GACjDO,EAAMhG,KAAKmE,4BACX8B,EAAID,EAAI9F,EAAI,EACZgG,EAAIF,EAAIzF,EAAI,EACd,MAAO,CAELyB,GAAId,EAAe,CAAEhB,GAAI+F,EAAG1F,GAAI2F,GAAKJ,GACrC7D,GAAIf,EAAe,CAAEhB,EAAG+F,EAAG1F,GAAI2F,GAAKJ,GACpC3D,GAAIjB,EAAe,CAAEhB,GAAI+F,EAAG1F,EAAG2F,GAAKJ,GACpC5D,GAAIhB,EAAe,CAAEhB,EAAG+F,EAAG1F,EAAG2F,GAAKJ,GAEvC,CAOArB,SAAAA,GACEzE,KAAKoC,QAAUpC,KAAKqC,aACtB,CAEA8D,kBAAAA,GAAgD,IAA7BC,EAAS1E,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GACtB2E,EAAmB,GAqBvB,OApBKD,GAAapG,KAAKiB,QACrBoF,EAASrG,KAAKiB,MAAMkF,mBAAmBC,IAEzCC,EAAOC,KACLtG,KAAKa,IACLb,KAAKU,KACLV,KAAKsD,MACLtD,KAAKuD,OACLvD,KAAKuG,OACLvG,KAAKwG,OACLxG,KAAKmF,MACLnF,KAAKyG,YACLzG,KAAK0G,MACL1G,KAAK2G,OACJ3G,KAAK4G,OACL5G,KAAK6G,MACNC,EAAc9G,KAAKqB,SACnByF,EAAc9G,KAAKsB,UAGd+E,CACT,CASAlF,mBAAAA,GAA+C,IAA3BiF,EAAS1E,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GACvBqF,EAAS/G,KAAKgH,gBAClB,GAAIZ,IAAcpG,KAAKiB,MACrB,OAAO8F,EAET,MAAME,EAAMjH,KAAKmG,mBAAmBC,GAClCc,EAAQlH,KAAKmH,YACf,OAAID,GAASA,EAAMD,IAAI9D,OAAM,CAACjD,EAAGkH,IAAMlH,IAAM+G,EAAIG,KACxCF,EAAM9G,OAEXJ,KAAKiB,QACP8F,EAAShB,EACP/F,KAAKiB,MAAME,qBAAoB,GAC/B4F,IAGJ/G,KAAKmH,YAAc,CACjBF,MACA7G,MAAO2G,GAEFA,EACT,CAOAC,aAAAA,GACE,MAAMC,EAAMjH,KAAKmG,oBAAmB,GAClCe,EAAQlH,KAAKqH,eACf,GAAIH,GAASA,EAAMD,MAAQA,EACzB,OAAOC,EAAM9G,MAEf,MAAMkH,EAAStH,KAAK2F,yBAClB4B,EAAU,CACRpC,MAAOnF,KAAKmF,MACZqC,WAAYF,EAAOpH,EACnBuH,WAAYH,EAAO/G,EACnBgG,OAAQvG,KAAKuG,OACbC,OAAQxG,KAAKwG,OACbE,MAAO1G,KAAK0G,MACZC,MAAO3G,KAAK2G,MACZC,MAAO5G,KAAK4G,MACZC,MAAO7G,KAAK6G,OAEdzG,EAAQsH,EAAcH,GAKxB,OAJAvH,KAAKqH,eAAiB,CACpBJ,MACA7G,SAEKA,CACT,CAOAuH,4BAAAA,GACE,OAAO,IAAIlG,EAAMzB,KAAKsD,MAAOtD,KAAKuD,QAAQqE,UAAU5H,KAAKyG,YAC3D,CASAoB,2BAAAA,CAA4BN,GAC1B,OAAOvH,KAAKmE,0BAA0BoD,GACnCO,UAAU9H,KAAKoF,wBAAwB,GACvCwC,UAAU,EAAI5H,KAAK+H,QACxB,CA2CA5D,yBAAAA,GAAoD,IAA1BoD,EAAY7F,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAA,EACvC,MAAMsG,EAAUC,EAAA,CAId1B,OAAQvG,KAAKuG,OACbC,OAAQxG,KAAKwG,OACbE,MAAO1G,KAAK0G,MACZC,MAAO3G,KAAK2G,MACZrD,MAAOtD,KAAKsD,MACZC,OAAQvD,KAAKuD,OACbkD,YAAazG,KAAKyG,aACfc,GAGCd,EAAcuB,EAAWvB,YAC/B,IAAIyB,EAAwBzB,EAC1B0B,EAAyB,EAEvBnI,KAAKoI,gBACPF,EAAwB,EACxBC,EAAyB1B,GAE3B,MAAM4B,EAAOL,EAAW1E,MAAQ4E,EAC9BI,EAAON,EAAWzE,OAAS2E,EAE7B,IAAIK,EAcJ,OAZEA,EAH8B,IAArBP,EAAWtB,OAAoC,IAArBsB,EAAWrB,MAG5B,IAAIlF,EACpB4G,EAAOL,EAAWzB,OAClB+B,EAAON,EAAWxB,QAGFgC,EAChBH,EACAC,EACAG,EAAqBT,IAIlBO,EAAgBX,UAAUO,EACnC,CAWAO,sBAAAA,CACEtH,EACAuH,EACAC,EACAC,EACAC,GAEA,IAAI5I,EAAIkB,EAAMlB,EACZK,EAAIa,EAAMb,EACZ,MAAMwI,EAAUjC,EAAc+B,GAAa/B,EAAc6B,GACvDK,EAAUlC,EAAcgC,GAAahC,EAAc8B,GAErD,GAAIG,GAAWC,EAAS,CACtB,MAAMhD,EAAMhG,KAAKmE,4BACjBjE,GAAK6I,EAAU/C,EAAI9F,EACnBK,GAAKyI,EAAUhD,EAAIzF,CACrB,CAEA,OAAO,IAAIkB,EAAMvB,EAAGK,EACtB,CASA0I,sBAAAA,CACE7H,EACAC,EACAC,GAEA,GAAID,IAAY6H,GAAU5H,IAAY4H,EACpC,OAAO9H,EAET,MAAMqB,EAAIzC,KAAK0I,uBACbtH,EACAC,EACAC,EACA4H,EACAA,GAEF,OAAIlJ,KAAKmF,MACA1C,EAAE0G,OAAOC,EAAiBpJ,KAAKmF,OAAQ/D,GAEzCqB,CACT,CASA4G,sBAAAA,CACE/B,EACAjG,EACAC,GAEA,MAAMmB,EAAIzC,KAAK0I,uBACbpB,EACA4B,EACAA,EACA7H,EACAC,GAEF,OAAItB,KAAKmF,MACA1C,EAAE0G,OAAOC,EAAiBpJ,KAAKmF,OAAQmC,GAEzC7E,CACT,CAMA6G,cAAAA,GACE,MAAMC,EAAYvJ,KAAK2F,yBACvB,OAAO3F,KAAKiB,MACRC,EAAeqI,EAAWvJ,KAAKiB,MAAME,uBACrCoI,CACN,CAMA5D,sBAAAA,GACE,OAAO3F,KAAKiJ,uBACV,IAAIxH,EAAMzB,KAAKU,KAAMV,KAAKa,KAC1Bb,KAAKqB,QACLrB,KAAKsB,QAET,CAaAkI,gBAAAA,CAAiBnI,EAAmBC,GAClC,OAAOtB,KAAKqJ,uBACVrJ,KAAK2F,yBACLtE,EACAC,EAEJ,CASAO,mBAAAA,CAAoB4H,EAAYpI,EAAmBC,GACjD,MAAMgG,EAAStH,KAAKiJ,uBAAuBQ,EAAKpI,EAASC,GACvDoI,EAAW1J,KAAKqJ,uBACd/B,EACAtH,KAAKqB,QACLrB,KAAKsB,SAETtB,KAAK2J,IAAI,CAAEjJ,KAAMgJ,EAASxJ,EAAGW,IAAK6I,EAASnJ,GAC7C,CAKAqJ,iBAAAA,GACE,OAAO5J,KAAKqJ,uBACVrJ,KAAK2F,yBACLkE,EACAC,EAEJ"}