import{ObjectGeometry as t}from"./ObjectGeometry.min.mjs";class o extends t{isDescendantOf(t){const{parent:o,group:e}=this;return o===t||e===t||this.canvas===t||!!o&&o.isDescendantOf(t)||!!e&&e!==o&&e.isDescendantOf(t)}getAncestors(){const t=[];let e=this;do{e=e instanceof o?e.parent:void 0,e&&t.push(e)}while(e);return t}findCommonAncestors(t){if(this===t)return{fork:[],otherFork:[],common:[this,...this.getAncestors()]};const o=this.getAncestors(),e=t.getAncestors();if(0===o.length&&e.length>0&&this===e[e.length-1])return{fork:[],otherFork:[t,...e.slice(0,e.length-1)],common:[this]};for(let n,r=0;r<o.length;r++){if(n=o[r],n===t)return{fork:[this,...o.slice(0,r)],otherFork:[],common:o.slice(r)};for(let s=0;s<e.length;s++){if(this===e[s])return{fork:[],otherFork:[t,...e.slice(0,s)],common:[this,...o]};if(n===e[s])return{fork:[this,...o.slice(0,r)],otherFork:[t,...e.slice(0,s)],common:o.slice(r)}}}return{fork:[this,...o],otherFork:[t,...e],common:[]}}hasCommonAncestors(t){const o=this.findCommonAncestors(t);return o&&!!o.common.length}isInFrontOf(t){if(this===t)return;const o=this.findCommonAncestors(t);if(o.fork.includes(t))return!0;if(o.otherFork.includes(this))return!1;const e=o.common[0]||this.canvas;if(!e)return;const n=o.fork.pop(),r=o.otherFork.pop(),s=e._objects.indexOf(n),i=e._objects.indexOf(r);return s>-1&&s>i}}export{o as StackedObject};
//# sourceMappingURL=StackedObject.min.mjs.map
