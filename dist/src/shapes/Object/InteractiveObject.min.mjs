import{defineProperty as t,objectSpread2 as r}from"../../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{Point as o,ZERO as s}from"../../Point.min.mjs";import{FabricObject as e}from"./Object.min.mjs";import{degreesToRadians as i}from"../../util/misc/radiansDegreesConversion.min.mjs";import{createTranslateMatrix as n,createRotateMatrix as a,multiplyTransformMatrices as l,qrDecompose as c,calcDimensionsMatrix as h}from"../../util/misc/matrix.min.mjs";import{sizeAfterTransform as d}from"../../util/misc/objectTransforms.min.mjs";import{createObjectDefaultControls as C}from"../../controls/commonControls.min.mjs";import{interactiveObjectDefaultValues as u}from"./defaultValues.min.mjs";import{SCALE as m}from"../../constants.min.mjs";class f extends e{static getDefaults(){return r(r({},super.getDefaults()),f.ownDefaults)}constructor(t){super(),Object.assign(this,this.constructor.createControls(),f.ownDefaults),this.setOptions(t)}static createControls(){return{controls:C()}}_updateCacheCanvas(){const t=this.canvas;if(this.noScaleCache&&t&&t._currentTransform){const r=t._currentTransform,o=r.target,s=r.action;if(this===o&&s&&s.startsWith(m))return!1}return super._updateCacheCanvas()}getActiveControl(){const t=this.__corner;return t?{key:t,control:this.controls[t],coord:this.oCoords[t]}:void 0}findControl(t){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this.hasControls||!this.canvas)return;this.__corner=void 0;const o=Object.entries(this.oCoords);for(let s=o.length-1;s>=0;s--){const[e,i]=o[s],n=this.controls[e];if(n.shouldActivate(e,this,t,r?i.touchCorner:i.corner))return this.__corner=e,{key:e,control:n,coord:this.oCoords[e]}}}calcOCoords(){const t=this.getViewportTransform(),r=this.getCenterPoint(),o=n(r.x,r.y),s=a({angle:this.getTotalAngle()-(this.group&&this.flipX?180:0)}),e=l(o,s),i=l(t,e),h=l(i,[1/t[0],0,0,1/t[3],0,0]),d=this.group?c(this.calcTransformMatrix()):void 0;d&&(d.scaleX=Math.abs(d.scaleX),d.scaleY=Math.abs(d.scaleY));const C=this._calculateCurrentDimensions(d),u={};return this.forEachControl(((t,r)=>{const o=t.positionHandler(C,h,this,t);u[r]=Object.assign(o,this._calcCornerCoords(t,o))})),u}_calcCornerCoords(t,r){const o=this.getTotalAngle();return{corner:t.calcCornerCoords(o,this.cornerSize,r.x,r.y,!1,this),touchCorner:t.calcCornerCoords(o,this.touchCornerSize,r.x,r.y,!0,this)}}setCoords(){super.setCoords(),this.canvas&&(this.oCoords=this.calcOCoords())}forEachControl(t){for(const r in this.controls)t(this.controls[r],r,this)}drawSelectionBackground(t){if(!this.selectionBackgroundColor||this.canvas&&this.canvas._activeObject!==this)return;t.save();const r=this.getRelativeCenterPoint(),o=this._calculateCurrentDimensions(),s=this.getViewportTransform();t.translate(r.x,r.y),t.scale(1/s[0],1/s[3]),t.rotate(i(this.angle)),t.fillStyle=this.selectionBackgroundColor,t.fillRect(-o.x/2,-o.y/2,o.x,o.y),t.restore()}strokeBorders(t,r){t.strokeRect(-r.x/2,-r.y/2,r.x,r.y)}_drawBorders(t,o){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const e=r({hasControls:this.hasControls,borderColor:this.borderColor,borderDashArray:this.borderDashArray},s);t.save(),t.strokeStyle=e.borderColor,this._setLineDash(t,e.borderDashArray),this.strokeBorders(t,o),e.hasControls&&this.drawControlsConnectingLines(t,o),t.restore()}_renderControls(t){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{hasBorders:s,hasControls:e}=this,n=r({hasBorders:s,hasControls:e},o),a=this.getViewportTransform(),h=n.hasBorders,d=n.hasControls,C=l(a,this.calcTransformMatrix()),u=c(C);t.save(),t.translate(u.translateX,u.translateY),t.lineWidth=1*this.borderScaleFactor,this.group===this.parent&&(t.globalAlpha=this.isMoving?this.borderOpacityWhenMoving:1),this.flipX&&(u.angle-=180),t.rotate(i(this.group?u.angle:this.angle)),h&&this.drawBorders(t,u,o),d&&this.drawControls(t,o),t.restore()}drawBorders(t,r,e){let i;if(e&&e.forActiveSelection||this.group){const t=d(this.width,this.height,h(r)),e=this.isStrokeAccountedForInDimensions()?s:(this.strokeUniform?(new o).scalarAdd(this.canvas?this.canvas.getZoom():1):new o(r.scaleX,r.scaleY)).scalarMultiply(this.strokeWidth);i=t.add(e).scalarAdd(this.borderScaleFactor).scalarAdd(2*this.padding)}else i=this._calculateCurrentDimensions().scalarAdd(this.borderScaleFactor);this._drawBorders(t,i,e)}drawControlsConnectingLines(t,r){let o=!1;t.beginPath(),this.forEachControl(((s,e)=>{s.withConnection&&s.getVisibility(this,e)&&(o=!0,t.moveTo(s.x*r.x,s.y*r.y),t.lineTo(s.x*r.x+s.offsetX,s.y*r.y+s.offsetY))})),o&&t.stroke()}drawControls(t){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.save();const s=this.getCanvasRetinaScaling(),{cornerStrokeColor:e,cornerDashArray:i,cornerColor:n}=this,a=r({cornerStrokeColor:e,cornerDashArray:i,cornerColor:n},o);t.setTransform(s,0,0,s,0,0),t.strokeStyle=t.fillStyle=a.cornerColor,this.transparentCorners||(t.strokeStyle=a.cornerStrokeColor),this._setLineDash(t,a.cornerDashArray),this.forEachControl(((r,o)=>{if(r.getVisibility(this,o)){const s=this.oCoords[o];r.render(t,s.x,s.y,a,this)}})),t.restore()}isControlVisible(t){return this.controls[t]&&this.controls[t].getVisibility(this,t)}setControlVisible(t,r){this._controlsVisibility||(this._controlsVisibility={}),this._controlsVisibility[t]=r}setControlsVisibility(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object.entries(t).forEach((t=>{let[r,o]=t;return this.setControlVisible(r,o)}))}clearContextTop(t){if(!this.canvas)return;const r=this.canvas.contextTop;if(!r)return;const o=this.canvas.viewportTransform;r.save(),r.transform(o[0],o[1],o[2],o[3],o[4],o[5]),this.transform(r);const s=this.width+4,e=this.height+4;return r.clearRect(-s/2,-e/2,s,e),t||r.restore(),r}onDeselect(t){return!1}onSelect(t){return!1}shouldStartDragging(t){return!1}onDragStart(t){return!1}canDrop(t){return!1}renderDragSourceEffect(t){}renderDropTargetEffect(t){}}t(f,"ownDefaults",u);export{f as InteractiveFabricObject};
//# sourceMappingURL=InteractiveObject.min.mjs.map
