{"version":3,"file":"Textbox.min.mjs","sources":["../../../src/shapes/Textbox.ts"],"sourcesContent":["import type { TClassProperties, TOptions } from '../typedefs';\nimport { IText } from './IText/IText';\nimport { classRegistry } from '../ClassRegistry';\nimport { createTextboxDefaultControls } from '../controls/commonControls';\nimport { JUSTIFY } from './Text/constants';\nimport type { TextStyleDeclaration } from './Text/StyledText';\nimport type { SerializedITextProps, ITextProps } from './IText/IText';\nimport type { ITextEvents } from './IText/ITextBehavior';\nimport type { TextLinesInfo } from './Text/Text';\nimport type { Control } from '../controls/Control';\n\n// @TODO: Many things here are configuration related and shouldn't be on the class nor prototype\n// regexes, list of properties that are not suppose to change by instances, magic consts.\n// this will be a separated effort\nexport const textboxDefaultValues: Partial<TClassProperties<Textbox>> = {\n  minWidth: 20,\n  dynamicMinWidth: 2,\n  lockScalingFlip: true,\n  noScaleCache: false,\n  _wordJoiners: /[ \\t\\r]/,\n  splitByGrapheme: false,\n};\n\nexport type GraphemeData = {\n  wordsData: {\n    word: string[];\n    width: number;\n  }[][];\n  largestWordWidth: number;\n};\n\nexport type StyleMap = Record<string, { line: number; offset: number }>;\n\n// @TODO this is not complete\ninterface UniqueTextboxProps {\n  minWidth: number;\n  splitByGrapheme: boolean;\n  dynamicMinWidth: number;\n  _wordJoiners: RegExp;\n}\n\nexport interface SerializedTextboxProps\n  extends SerializedITextProps,\n    Pick<UniqueTextboxProps, 'minWidth' | 'splitByGrapheme'> {}\n\nexport interface TextboxProps extends ITextProps, UniqueTextboxProps {}\n\n/**\n * Textbox class, based on IText, allows the user to resize the text rectangle\n * and wraps lines automatically. Textboxes have their Y scaling locked, the\n * user can only change width. Height is adjusted automatically based on the\n * wrapping of lines.\n */\nexport class Textbox<\n    Props extends TOptions<TextboxProps> = Partial<TextboxProps>,\n    SProps extends SerializedTextboxProps = SerializedTextboxProps,\n    EventSpec extends ITextEvents = ITextEvents,\n  >\n  extends IText<Props, SProps, EventSpec>\n  implements UniqueTextboxProps\n{\n  /**\n   * Minimum width of textbox, in pixels.\n   * @type Number\n   * @default\n   */\n  declare minWidth: number;\n\n  /**\n   * Minimum calculated width of a textbox, in pixels.\n   * fixed to 2 so that an empty textbox cannot go to 0\n   * and is still selectable without text.\n   * @type Number\n   * @default\n   */\n  declare dynamicMinWidth: number;\n\n  /**\n   * Use this boolean property in order to split strings that have no white space concept.\n   * this is a cheap way to help with chinese/japanese\n   * @type Boolean\n   * @since 2.6.0\n   */\n  declare splitByGrapheme: boolean;\n\n  declare _wordJoiners: RegExp;\n\n  declare _styleMap: StyleMap;\n\n  declare isWrapping: boolean;\n\n  static type = 'Textbox';\n\n  static textLayoutProperties = [...IText.textLayoutProperties, 'width'];\n\n  static ownDefaults = textboxDefaultValues;\n\n  static getDefaults(): Record<string, any> {\n    return {\n      ...super.getDefaults(),\n      ...Textbox.ownDefaults,\n    };\n  }\n\n  /**\n   * Constructor\n   * @param {String} text Text string\n   * @param {Object} [options] Options object\n   */\n  constructor(text: string, options?: Props) {\n    super(text, { ...Textbox.ownDefaults, ...options } as Props);\n  }\n\n  /**\n   * Creates the default control object.\n   * If you prefer to have on instance of controls shared among all objects\n   * make this function return an empty object and add controls to the ownDefaults object\n   */\n  static createControls(): { controls: Record<string, Control> } {\n    return { controls: createTextboxDefaultControls() };\n  }\n\n  /**\n   * Unlike superclass's version of this function, Textbox does not update\n   * its width.\n   * @private\n   * @override\n   */\n  initDimensions() {\n    if (!this.initialized) {\n      return;\n    }\n    this.isEditing && this.initDelayedCursor();\n    this._clearCache();\n    // clear dynamicMinWidth as it will be different after we re-wrap line\n    this.dynamicMinWidth = 0;\n    // wrap lines\n    this._styleMap = this._generateStyleMap(this._splitText());\n    // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap\n    if (this.dynamicMinWidth > this.width) {\n      this._set('width', this.dynamicMinWidth);\n    }\n    if (this.textAlign.includes(JUSTIFY)) {\n      // once text is measured we need to make space fatter to make justified text.\n      this.enlargeSpaces();\n    }\n    // clear cache and re-calculate height\n    this.height = this.calcTextHeight();\n  }\n\n  /**\n   * Generate an object that translates the style object so that it is\n   * broken up by visual lines (new lines and automatic wrapping).\n   * The original text styles object is broken up by actual lines (new lines only),\n   * which is only sufficient for Text / IText\n   * @private\n   */\n  _generateStyleMap(textInfo: TextLinesInfo): StyleMap {\n    let realLineCount = 0,\n      realLineCharCount = 0,\n      charCount = 0;\n    const map: StyleMap = {};\n\n    for (let i = 0; i < textInfo.graphemeLines.length; i++) {\n      if (textInfo.graphemeText[charCount] === '\\n' && i > 0) {\n        realLineCharCount = 0;\n        charCount++;\n        realLineCount++;\n      } else if (\n        !this.splitByGrapheme &&\n        this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) &&\n        i > 0\n      ) {\n        // this case deals with space's that are removed from end of lines when wrapping\n        realLineCharCount++;\n        charCount++;\n      }\n\n      map[i] = { line: realLineCount, offset: realLineCharCount };\n\n      charCount += textInfo.graphemeLines[i].length;\n      realLineCharCount += textInfo.graphemeLines[i].length;\n    }\n\n    return map;\n  }\n\n  /**\n   * Returns true if object has a style property or has it on a specified line\n   * @param {Number} lineIndex\n   * @return {Boolean}\n   */\n  styleHas(property: keyof TextStyleDeclaration, lineIndex: number): boolean {\n    if (this._styleMap && !this.isWrapping) {\n      const map = this._styleMap[lineIndex];\n      if (map) {\n        lineIndex = map.line;\n      }\n    }\n    return super.styleHas(property, lineIndex);\n  }\n\n  /**\n   * Returns true if object has no styling or no styling in a line\n   * @param {Number} lineIndex , lineIndex is on wrapped lines.\n   * @return {Boolean}\n   */\n  isEmptyStyles(lineIndex: number): boolean {\n    if (!this.styles) {\n      return true;\n    }\n    let offset = 0,\n      nextLineIndex = lineIndex + 1,\n      nextOffset: number,\n      shouldLimit = false;\n    const map = this._styleMap[lineIndex],\n      mapNextLine = this._styleMap[lineIndex + 1];\n    if (map) {\n      lineIndex = map.line;\n      offset = map.offset;\n    }\n    if (mapNextLine) {\n      nextLineIndex = mapNextLine.line;\n      shouldLimit = nextLineIndex === lineIndex;\n      nextOffset = mapNextLine.offset;\n    }\n    const obj =\n      typeof lineIndex === 'undefined'\n        ? this.styles\n        : { line: this.styles[lineIndex] };\n    for (const p1 in obj) {\n      for (const p2 in obj[p1]) {\n        const p2Number = parseInt(p2, 10);\n        if (p2Number >= offset && (!shouldLimit || p2Number < nextOffset!)) {\n          // eslint-disable-next-line no-unused-vars\n          for (const p3 in obj[p1][p2]) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @protected\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @return {TextStyleDeclaration} a style object reference to the existing one or a new empty object when undefined\n   */\n  _getStyleDeclaration(\n    lineIndex: number,\n    charIndex: number,\n  ): TextStyleDeclaration {\n    if (this._styleMap && !this.isWrapping) {\n      const map = this._styleMap[lineIndex];\n      if (!map) {\n        return {};\n      }\n      lineIndex = map.line;\n      charIndex = map.offset + charIndex;\n    }\n    return super._getStyleDeclaration(lineIndex, charIndex);\n  }\n\n  /**\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @param {Object} style\n   * @private\n   */\n  protected _setStyleDeclaration(\n    lineIndex: number,\n    charIndex: number,\n    style: object,\n  ) {\n    const map = this._styleMap[lineIndex];\n    super._setStyleDeclaration(map.line, map.offset + charIndex, style);\n  }\n\n  /**\n   * @param {Number} lineIndex\n   * @param {Number} charIndex\n   * @private\n   */\n  protected _deleteStyleDeclaration(lineIndex: number, charIndex: number) {\n    const map = this._styleMap[lineIndex];\n    super._deleteStyleDeclaration(map.line, map.offset + charIndex);\n  }\n\n  /**\n   * probably broken need a fix\n   * Returns the real style line that correspond to the wrapped lineIndex line\n   * Used just to verify if the line does exist or not.\n   * @param {Number} lineIndex\n   * @returns {Boolean} if the line exists or not\n   * @private\n   */\n  protected _getLineStyle(lineIndex: number): boolean {\n    const map = this._styleMap[lineIndex];\n    return !!this.styles[map.line];\n  }\n\n  /**\n   * Set the line style to an empty object so that is initialized\n   * @param {Number} lineIndex\n   * @param {Object} style\n   * @private\n   */\n  protected _setLineStyle(lineIndex: number) {\n    const map = this._styleMap[lineIndex];\n    super._setLineStyle(map.line);\n  }\n\n  /**\n   * Wraps text using the 'width' property of Textbox. First this function\n   * splits text on newlines, so we preserve newlines entered by the user.\n   * Then it wraps each line using the width of the Textbox by calling\n   * _wrapLine().\n   * @param {Array} lines The string array of text that is split into lines\n   * @param {Number} desiredWidth width you want to wrap to\n   * @returns {Array} Array of lines\n   */\n  _wrapText(lines: string[], desiredWidth: number): string[][] {\n    this.isWrapping = true;\n    // extract all thewords and the widths to optimally wrap lines.\n    const data = this.getGraphemeDataForRender(lines);\n    const wrapped: string[][] = [];\n    for (let i = 0; i < data.wordsData.length; i++) {\n      wrapped.push(...this._wrapLine(i, desiredWidth, data));\n    }\n    this.isWrapping = false;\n    return wrapped;\n  }\n\n  /**\n   * For each line of text terminated by an hard line stop,\n   * measure each word width and extract the largest word from all.\n   * The returned words here are the one that at the end will be rendered.\n   * @param {string[]} lines the lines we need to measure\n   *\n   */\n  getGraphemeDataForRender(lines: string[]): GraphemeData {\n    const splitByGrapheme = this.splitByGrapheme,\n      infix = splitByGrapheme ? '' : ' ';\n\n    let largestWordWidth = 0;\n\n    const data = lines.map((line, lineIndex) => {\n      let offset = 0;\n      const wordsOrGraphemes = splitByGrapheme\n        ? this.graphemeSplit(line)\n        : this.wordSplit(line);\n\n      if (wordsOrGraphemes.length === 0) {\n        return [{ word: [], width: 0 }];\n      }\n\n      return wordsOrGraphemes.map((word: string) => {\n        // if using splitByGrapheme words are already in graphemes.\n        const graphemeArray = splitByGrapheme\n          ? [word]\n          : this.graphemeSplit(word);\n        const width = this._measureWord(graphemeArray, lineIndex, offset);\n        largestWordWidth = Math.max(width, largestWordWidth);\n        offset += graphemeArray.length + infix.length;\n        return { word: graphemeArray, width };\n      });\n    });\n\n    return {\n      wordsData: data,\n      largestWordWidth,\n    };\n  }\n\n  /**\n   * Helper function to measure a string of text, given its lineIndex and charIndex offset\n   * It gets called when charBounds are not available yet.\n   * Override if necessary\n   * Use with {@link Textbox#wordSplit}\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {String} text\n   * @param {number} lineIndex\n   * @param {number} charOffset\n   * @returns {number}\n   */\n  _measureWord(word: string[], lineIndex: number, charOffset = 0): number {\n    let width = 0,\n      prevGrapheme;\n    const skipLeft = true;\n    for (let i = 0, len = word.length; i < len; i++) {\n      const box = this._getGraphemeBox(\n        word[i],\n        lineIndex,\n        i + charOffset,\n        prevGrapheme,\n        skipLeft,\n      );\n      width += box.kernedWidth;\n      prevGrapheme = word[i];\n    }\n    return width;\n  }\n\n  /**\n   * Override this method to customize word splitting\n   * Use with {@link Textbox#_measureWord}\n   * @param {string} value\n   * @returns {string[]} array of words\n   */\n  wordSplit(value: string): string[] {\n    return value.split(this._wordJoiners);\n  }\n\n  /**\n   * Wraps a line of text using the width of the Textbox as desiredWidth\n   * and leveraging the known width o words from GraphemeData\n   * @private\n   * @param {Number} lineIndex\n   * @param {Number} desiredWidth width you want to wrap the line to\n   * @param {GraphemeData} graphemeData an object containing all the lines' words width.\n   * @param {Number} reservedSpace space to remove from wrapping for custom functionalities\n   * @returns {Array} Array of line(s) into which the given text is wrapped\n   * to.\n   */\n  _wrapLine(\n    lineIndex: number,\n    desiredWidth: number,\n    { largestWordWidth, wordsData }: GraphemeData,\n    reservedSpace = 0,\n  ): string[][] {\n    const additionalSpace = this._getWidthOfCharSpacing(),\n      splitByGrapheme = this.splitByGrapheme,\n      graphemeLines = [],\n      infix = splitByGrapheme ? '' : ' ';\n\n    let lineWidth = 0,\n      line: string[] = [],\n      // spaces in different languages?\n      offset = 0,\n      infixWidth = 0,\n      lineJustStarted = true;\n\n    desiredWidth -= reservedSpace;\n\n    const maxWidth = Math.max(\n      desiredWidth,\n      largestWordWidth,\n      this.dynamicMinWidth,\n    );\n    // layout words\n    const data = wordsData[lineIndex];\n    offset = 0;\n    let i;\n    for (i = 0; i < data.length; i++) {\n      const { word, width: wordWidth } = data[i];\n      offset += word.length;\n\n      lineWidth += infixWidth + wordWidth - additionalSpace;\n      if (lineWidth > maxWidth && !lineJustStarted) {\n        graphemeLines.push(line);\n        line = [];\n        lineWidth = wordWidth;\n        lineJustStarted = true;\n      } else {\n        lineWidth += additionalSpace;\n      }\n\n      if (!lineJustStarted && !splitByGrapheme) {\n        line.push(infix);\n      }\n      line = line.concat(word);\n\n      infixWidth = splitByGrapheme\n        ? 0\n        : this._measureWord([infix], lineIndex, offset);\n      offset++;\n      lineJustStarted = false;\n    }\n\n    i && graphemeLines.push(line);\n\n    // TODO: this code is probably not necessary anymore.\n    // it can be moved out of this function since largestWordWidth is now\n    // known in advance\n    if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {\n      this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;\n    }\n    return graphemeLines;\n  }\n\n  /**\n   * Detect if the text line is ended with an hard break\n   * text and itext do not have wrapping, return false\n   * @param {Number} lineIndex text to split\n   * @return {Boolean}\n   */\n  isEndOfWrapping(lineIndex: number): boolean {\n    if (!this._styleMap[lineIndex + 1]) {\n      // is last line, return true;\n      return true;\n    }\n    if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {\n      // this is last line before a line break, return true;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Detect if a line has a linebreak and so we need to account for it when moving\n   * and counting style.\n   * This is important only for splitByGrapheme at the end of wrapping.\n   * If we are not wrapping the offset is always 1\n   * @return Number\n   */\n  missingNewlineOffset(lineIndex: number, skipWrapping?: boolean): 0 | 1 {\n    if (this.splitByGrapheme && !skipWrapping) {\n      return this.isEndOfWrapping(lineIndex) ? 1 : 0;\n    }\n    return 1;\n  }\n\n  /**\n   * Gets lines of text to render in the Textbox. This function calculates\n   * text wrapping on the fly every time it is called.\n   * @param {String} text text to split\n   * @returns {Array} Array of lines in the Textbox.\n   * @override\n   */\n  _splitTextIntoLines(text: string) {\n    const newText = super._splitTextIntoLines(text),\n      graphemeLines = this._wrapText(newText.lines, this.width),\n      lines = new Array(graphemeLines.length);\n    for (let i = 0; i < graphemeLines.length; i++) {\n      lines[i] = graphemeLines[i].join('');\n    }\n    newText.lines = lines;\n    newText.graphemeLines = graphemeLines;\n    return newText;\n  }\n\n  getMinWidth() {\n    return Math.max(this.minWidth, this.dynamicMinWidth);\n  }\n\n  _removeExtraneousStyles() {\n    const linesToKeep = new Map();\n    for (const prop in this._styleMap) {\n      const propNumber = parseInt(prop, 10);\n      if (this._textLines[propNumber]) {\n        const lineIndex = this._styleMap[prop].line;\n        linesToKeep.set(`${lineIndex}`, true);\n      }\n    }\n    for (const prop in this.styles) {\n      if (!linesToKeep.has(prop)) {\n        delete this.styles[prop];\n      }\n    }\n  }\n\n  /**\n   * Returns object representation of an instance\n   * @method toObject\n   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output\n   * @return {Object} object representation of an instance\n   */\n  toObject<\n    T extends Omit<Props & TClassProperties<this>, keyof SProps>,\n    K extends keyof T = never,\n  >(propertiesToInclude: K[] = []): Pick<T, K> & SProps {\n    return super.toObject<T, K>([\n      'minWidth',\n      'splitByGrapheme',\n      ...propertiesToInclude,\n    ] as K[]) as Pick<T, K> & SProps;\n  }\n}\n\nclassRegistry.setClass(Textbox);\n"],"names":["textboxDefaultValues","minWidth","dynamicMinWidth","lockScalingFlip","noScaleCache","_wordJoiners","splitByGrapheme","Textbox","IText","getDefaults","_objectSpread","super","ownDefaults","constructor","text","options","createControls","controls","createTextboxDefaultControls","initDimensions","this","initialized","isEditing","initDelayedCursor","_clearCache","_styleMap","_generateStyleMap","_splitText","width","_set","textAlign","includes","JUSTIFY","enlargeSpaces","height","calcTextHeight","textInfo","realLineCount","realLineCharCount","charCount","map","i","graphemeLines","length","graphemeText","_reSpaceAndTab","test","line","offset","styleHas","property","lineIndex","isWrapping","isEmptyStyles","styles","nextOffset","nextLineIndex","shouldLimit","mapNextLine","obj","p1","p2","p2Number","parseInt","p3","_getStyleDeclaration","charIndex","_setStyleDeclaration","style","_deleteStyleDeclaration","_getLineStyle","_setLineStyle","_wrapText","lines","desiredWidth","data","getGraphemeDataForRender","wrapped","wordsData","push","_wrapLine","infix","largestWordWidth","wordsOrGraphemes","graphemeSplit","wordSplit","word","graphemeArray","_measureWord","Math","max","prevGrapheme","charOffset","arguments","undefined","len","_getGraphemeBox","kernedWidth","value","split","_ref","reservedSpace","additionalSpace","_getWidthOfCharSpacing","lineWidth","infixWidth","lineJustStarted","maxWidth","wordWidth","concat","isEndOfWrapping","missingNewlineOffset","skipWrapping","_splitTextIntoLines","newText","Array","join","getMinWidth","_removeExtraneousStyles","linesToKeep","Map","prop","propNumber","_textLines","set","has","toObject","propertiesToInclude","_defineProperty","textLayoutProperties","classRegistry","setClass"],"mappings":"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"}