{"version":3,"file":"Canvas.min.mjs","sources":["../../../src/canvas/Canvas.ts"],"sourcesContent":["import { classRegistry } from '../ClassRegistry';\nimport { NONE } from '../constants';\nimport type {\n  CanvasEvents,\n  DragEventData,\n  ObjectEvents,\n  TPointerEvent,\n  TPointerEventNames,\n  Transform,\n} from '../EventTypeDefs';\nimport { Point } from '../Point';\nimport type { ActiveSelection } from '../shapes/ActiveSelection';\nimport type { Group } from '../shapes/Group';\nimport type { IText } from '../shapes/IText/IText';\nimport type { FabricObject } from '../shapes/Object/FabricObject';\nimport { isTouchEvent, stopEvent } from '../util/dom_event';\nimport { getDocumentFromElement, getWindowFromElement } from '../util/dom_misc';\nimport { sendPointToPlane } from '../util/misc/planeChange';\nimport { isActiveSelection } from '../util/typeAssertions';\nimport type { CanvasOptions, TCanvasOptions } from './CanvasOptions';\nimport { SelectableCanvas } from './SelectableCanvas';\nimport { TextEditingManager } from './TextEditingManager';\n\nconst addEventOptions = { passive: false } as EventListenerOptions;\n\nconst getEventPoints = (canvas: Canvas, e: TPointerEvent) => {\n  const viewportPoint = canvas.getViewportPoint(e);\n  const scenePoint = canvas.getScenePoint(e);\n  return {\n    viewportPoint,\n    scenePoint,\n    pointer: viewportPoint,\n    absolutePointer: scenePoint,\n  };\n};\n\n// just to be clear, the utils are now deprecated and those are here exactly as minifier helpers\n// because el.addEventListener can't me be minified while a const yes and we use it 47 times in this file.\n// few bytes but why give it away.\nconst addListener = (\n  el: HTMLElement | Document,\n  ...args: Parameters<HTMLElement['addEventListener']>\n) => el.addEventListener(...args);\nconst removeListener = (\n  el: HTMLElement | Document,\n  ...args: Parameters<HTMLElement['removeEventListener']>\n) => el.removeEventListener(...args);\n\nconst syntheticEventConfig = {\n  mouse: {\n    in: 'over',\n    out: 'out',\n    targetIn: 'mouseover',\n    targetOut: 'mouseout',\n    canvasIn: 'mouse:over',\n    canvasOut: 'mouse:out',\n  },\n  drag: {\n    in: 'enter',\n    out: 'leave',\n    targetIn: 'dragenter',\n    targetOut: 'dragleave',\n    canvasIn: 'drag:enter',\n    canvasOut: 'drag:leave',\n  },\n} as const;\n\ntype TSyntheticEventContext = {\n  mouse: { e: TPointerEvent };\n  drag: DragEventData;\n};\n\nexport class Canvas extends SelectableCanvas implements CanvasOptions {\n  /**\n   * Contains the id of the touch event that owns the fabric transform\n   * @type Number\n   * @private\n   */\n  declare mainTouchId?: number;\n\n  declare enablePointerEvents: boolean;\n\n  /**\n   * Holds a reference to a setTimeout timer for event synchronization\n   * @type number\n   * @private\n   */\n  private declare _willAddMouseDown: number;\n\n  /**\n   * Holds a reference to an object on the canvas that is receiving the drag over event.\n   * @type FabricObject\n   * @private\n   */\n  private declare _draggedoverTarget?: FabricObject;\n\n  /**\n   * Holds a reference to an object on the canvas from where the drag operation started\n   * @type FabricObject\n   * @private\n   */\n  private declare _dragSource?: FabricObject;\n\n  /**\n   * Holds a reference to an object on the canvas that is the current drop target\n   * May differ from {@link _draggedoverTarget}\n   * @todo inspect whether {@link _draggedoverTarget} and {@link _dropTarget} should be merged somehow\n   * @type FabricObject\n   * @private\n   */\n  private declare _dropTarget: FabricObject<ObjectEvents> | undefined;\n\n  private _isClick: boolean;\n\n  textEditingManager = new TextEditingManager(this);\n\n  constructor(el?: string | HTMLCanvasElement, options: TCanvasOptions = {}) {\n    super(el, options);\n    // bind event handlers\n    (\n      [\n        '_onMouseDown',\n        '_onTouchStart',\n        '_onMouseMove',\n        '_onMouseUp',\n        '_onTouchEnd',\n        '_onResize',\n        // '_onGesture',\n        // '_onDrag',\n        // '_onShake',\n        // '_onLongPress',\n        // '_onOrientationChange',\n        '_onMouseWheel',\n        '_onMouseOut',\n        '_onMouseEnter',\n        '_onContextMenu',\n        '_onDoubleClick',\n        '_onDragStart',\n        '_onDragEnd',\n        '_onDragProgress',\n        '_onDragOver',\n        '_onDragEnter',\n        '_onDragLeave',\n        '_onDrop',\n      ] as (keyof this)[]\n    ).forEach((eventHandler) => {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n      this[eventHandler] = (this[eventHandler] as Function).bind(this);\n    });\n    // register event handlers\n    this.addOrRemove(addListener, 'add');\n  }\n\n  /**\n   * return an event prefix pointer or mouse.\n   * @private\n   */\n  private _getEventPrefix() {\n    return this.enablePointerEvents ? 'pointer' : 'mouse';\n  }\n\n  addOrRemove(functor: any, _eventjsFunctor: 'add' | 'remove') {\n    const canvasElement = this.upperCanvasEl,\n      eventTypePrefix = this._getEventPrefix();\n    functor(getWindowFromElement(canvasElement), 'resize', this._onResize);\n    functor(canvasElement, eventTypePrefix + 'down', this._onMouseDown);\n    functor(\n      canvasElement,\n      `${eventTypePrefix}move`,\n      this._onMouseMove,\n      addEventOptions,\n    );\n    functor(canvasElement, `${eventTypePrefix}out`, this._onMouseOut);\n    functor(canvasElement, `${eventTypePrefix}enter`, this._onMouseEnter);\n    functor(canvasElement, 'wheel', this._onMouseWheel);\n    functor(canvasElement, 'contextmenu', this._onContextMenu);\n    functor(canvasElement, 'dblclick', this._onDoubleClick);\n    functor(canvasElement, 'dragstart', this._onDragStart);\n    functor(canvasElement, 'dragend', this._onDragEnd);\n    functor(canvasElement, 'dragover', this._onDragOver);\n    functor(canvasElement, 'dragenter', this._onDragEnter);\n    functor(canvasElement, 'dragleave', this._onDragLeave);\n    functor(canvasElement, 'drop', this._onDrop);\n    if (!this.enablePointerEvents) {\n      functor(canvasElement, 'touchstart', this._onTouchStart, addEventOptions);\n    }\n    // if (typeof eventjs !== 'undefined' && eventjsFunctor in eventjs) {\n    //   eventjs[eventjsFunctor](canvasElement, 'gesture', this._onGesture);\n    //   eventjs[eventjsFunctor](canvasElement, 'drag', this._onDrag);\n    //   eventjs[eventjsFunctor](\n    //     canvasElement,\n    //     'orientation',\n    //     this._onOrientationChange\n    //   );\n    //   eventjs[eventjsFunctor](canvasElement, 'shake', this._onShake);\n    //   eventjs[eventjsFunctor](canvasElement, 'longpress', this._onLongPress);\n    // }\n  }\n\n  /**\n   * Removes all event listeners\n   */\n  removeListeners() {\n    this.addOrRemove(removeListener, 'remove');\n    // if you dispose on a mouseDown, before mouse up, you need to clean document to...\n    const eventTypePrefix = this._getEventPrefix();\n    const doc = getDocumentFromElement(this.upperCanvasEl);\n    removeListener(\n      doc,\n      `${eventTypePrefix}up`,\n      this._onMouseUp as EventListener,\n    );\n    removeListener(\n      doc,\n      'touchend',\n      this._onTouchEnd as EventListener,\n      addEventOptions,\n    );\n    removeListener(\n      doc,\n      `${eventTypePrefix}move`,\n      this._onMouseMove as EventListener,\n      addEventOptions,\n    );\n    removeListener(\n      doc,\n      'touchmove',\n      this._onMouseMove as EventListener,\n      addEventOptions,\n    );\n  }\n\n  /**\n   * @private\n   * @param {Event} [e] Event object fired on wheel event\n   */\n  private _onMouseWheel(e: MouseEvent) {\n    this.__onMouseWheel(e);\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  private _onMouseOut(e: TPointerEvent) {\n    const target = this._hoveredTarget;\n    const shared = {\n      e,\n      ...getEventPoints(this, e),\n    };\n    this.fire('mouse:out', { ...shared, target });\n    this._hoveredTarget = undefined;\n    target && target.fire('mouseout', { ...shared });\n    this._hoveredTargets.forEach((nestedTarget) => {\n      this.fire('mouse:out', { ...shared, target: nestedTarget });\n      nestedTarget && nestedTarget.fire('mouseout', { ...shared });\n    });\n    this._hoveredTargets = [];\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mouseenter\n   */\n  private _onMouseEnter(e: TPointerEvent) {\n    // This find target and consequent 'mouse:over' is used to\n    // clear old instances on hovered target.\n    // calling findTarget has the side effect of killing target.__corner.\n    // as a short term fix we are not firing this if we are currently transforming.\n    // as a long term fix we need to separate the action of finding a target with the\n    // side effects we added to it.\n    if (!this._currentTransform && !this.findTarget(e)) {\n      this.fire('mouse:over', {\n        e,\n        ...getEventPoints(this, e),\n      });\n      this._hoveredTarget = undefined;\n      this._hoveredTargets = [];\n    }\n  }\n\n  /**\n   * supports native like text dragging\n   * @private\n   * @param {DragEvent} e\n   */\n  private _onDragStart(e: DragEvent) {\n    this._isClick = false;\n    const activeObject = this.getActiveObject();\n    if (activeObject && activeObject.onDragStart(e)) {\n      this._dragSource = activeObject;\n      const options = { e, target: activeObject };\n      this.fire('dragstart', options);\n      activeObject.fire('dragstart', options);\n      addListener(\n        this.upperCanvasEl,\n        'drag',\n        this._onDragProgress as EventListener,\n      );\n      return;\n    }\n    stopEvent(e);\n  }\n\n  /**\n   * First we clear top context where the effects are being rendered.\n   * Then we render the effects.\n   * Doing so will render the correct effect for all cases including an overlap between `source` and `target`.\n   * @private\n   */\n  private _renderDragEffects(\n    e: DragEvent,\n    source?: FabricObject,\n    target?: FabricObject,\n  ) {\n    let dirty = false;\n    // clear top context\n    const dropTarget = this._dropTarget;\n    if (dropTarget && dropTarget !== source && dropTarget !== target) {\n      dropTarget.clearContextTop();\n      dirty = true;\n    }\n    source?.clearContextTop();\n    target !== source && target?.clearContextTop();\n    // render effects\n    const ctx = this.contextTop;\n    ctx.save();\n    ctx.transform(...this.viewportTransform);\n    if (source) {\n      ctx.save();\n      source.transform(ctx);\n      source.renderDragSourceEffect(e);\n      ctx.restore();\n      dirty = true;\n    }\n    if (target) {\n      ctx.save();\n      target.transform(ctx);\n      target.renderDropTargetEffect(e);\n      ctx.restore();\n      dirty = true;\n    }\n    ctx.restore();\n    dirty && (this.contextTopDirty = true);\n  }\n\n  /**\n   * supports native like text dragging\n   * https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations#finishing_a_drag\n   * @private\n   * @param {DragEvent} e\n   */\n  private _onDragEnd(e: DragEvent) {\n    const didDrop = !!e.dataTransfer && e.dataTransfer.dropEffect !== NONE,\n      dropTarget = didDrop ? this._activeObject : undefined,\n      options = {\n        e,\n        target: this._dragSource as FabricObject,\n        subTargets: this.targets,\n        dragSource: this._dragSource as FabricObject,\n        didDrop,\n        dropTarget: dropTarget as FabricObject,\n      };\n    removeListener(\n      this.upperCanvasEl,\n      'drag',\n      this._onDragProgress as EventListener,\n    );\n    this.fire('dragend', options);\n    this._dragSource && this._dragSource.fire('dragend', options);\n    delete this._dragSource;\n    // we need to call mouse up synthetically because the browser won't\n    this._onMouseUp(e);\n  }\n\n  /**\n   * fire `drag` event on canvas and drag source\n   * @private\n   * @param {DragEvent} e\n   */\n  private _onDragProgress(e: DragEvent) {\n    const options = {\n      e,\n      target: this._dragSource as FabricObject | undefined,\n      dragSource: this._dragSource as FabricObject | undefined,\n      dropTarget: this._draggedoverTarget as FabricObject,\n    };\n    this.fire('drag', options);\n    this._dragSource && this._dragSource.fire('drag', options);\n  }\n\n  /**\n   * As opposed to {@link findTarget} we want the top most object to be returned w/o the active object cutting in line.\n   * Override at will\n   */\n  protected findDragTargets(e: DragEvent) {\n    this.targets = [];\n    const target = this._searchPossibleTargets(\n      this._objects,\n      this.getViewportPoint(e),\n    );\n    return {\n      target,\n      targets: [...this.targets],\n    };\n  }\n\n  /**\n   * prevent default to allow drop event to be fired\n   * https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Drag_operations#specifying_drop_targets\n   * @private\n   * @param {DragEvent} [e] Event object fired on Event.js shake\n   */\n  private _onDragOver(e: DragEvent) {\n    const eventType = 'dragover';\n    const { target, targets } = this.findDragTargets(e);\n    const dragSource = this._dragSource as FabricObject;\n    const options = {\n      e,\n      target,\n      subTargets: targets,\n      dragSource,\n      canDrop: false,\n      dropTarget: undefined,\n    };\n    let dropTarget;\n    //  fire on canvas\n    this.fire(eventType, options);\n    //  make sure we fire dragenter events before dragover\n    //  if dragleave is needed, object will not fire dragover so we don't need to trouble ourselves with it\n    this._fireEnterLeaveEvents(target, options);\n    if (target) {\n      if (target.canDrop(e)) {\n        dropTarget = target;\n      }\n      target.fire(eventType, options);\n    }\n    //  propagate the event to subtargets\n    for (let i = 0; i < targets.length; i++) {\n      const subTarget = targets[i];\n      // accept event only if previous targets didn't (the accepting target calls `preventDefault` to inform that the event is taken)\n      // TODO: verify if those should loop in inverse order then?\n      // what is the order of subtargets?\n      if (subTarget.canDrop(e)) {\n        dropTarget = subTarget;\n      }\n      subTarget.fire(eventType, options);\n    }\n    //  render drag effects now that relations between source and target is clear\n    this._renderDragEffects(e, dragSource, dropTarget);\n    this._dropTarget = dropTarget;\n  }\n\n  /**\n   * fire `dragleave` on `dragover` targets\n   * @private\n   * @param {Event} [e] Event object fired on Event.js shake\n   */\n  private _onDragEnter(e: DragEvent) {\n    const { target, targets } = this.findDragTargets(e);\n    const options = {\n      e,\n      target,\n      subTargets: targets,\n      dragSource: this._dragSource,\n    };\n    this.fire('dragenter', options);\n    //  fire dragenter on targets\n    this._fireEnterLeaveEvents(target, options);\n  }\n\n  /**\n   * fire `dragleave` on `dragover` targets\n   * @private\n   * @param {Event} [e] Event object fired on Event.js shake\n   */\n  private _onDragLeave(e: DragEvent) {\n    const options = {\n      e,\n      target: this._draggedoverTarget,\n      subTargets: this.targets,\n      dragSource: this._dragSource,\n    };\n    this.fire('dragleave', options);\n\n    //  fire dragleave on targets\n    this._fireEnterLeaveEvents(undefined, options);\n    this._renderDragEffects(e, this._dragSource);\n    this._dropTarget = undefined;\n    //  clear targets\n    this.targets = [];\n    this._hoveredTargets = [];\n  }\n\n  /**\n   * `drop:before` is a an event that allows you to schedule logic\n   * before the `drop` event. Prefer `drop` event always, but if you need\n   * to run some drop-disabling logic on an event, since there is no way\n   * to handle event handlers ordering, use `drop:before`\n   * @private\n   * @param {Event} e\n   */\n  private _onDrop(e: DragEvent) {\n    const { target, targets } = this.findDragTargets(e);\n    const options = this._basicEventHandler('drop:before', {\n      e,\n      target,\n      subTargets: targets,\n      dragSource: this._dragSource,\n      ...getEventPoints(this, e),\n    });\n    //  will be set by the drop target\n    options.didDrop = false;\n    //  will be set by the drop target, used in case options.target refuses the drop\n    options.dropTarget = undefined;\n    //  fire `drop`\n    this._basicEventHandler('drop', options);\n    //  inform canvas of the drop\n    //  we do this because canvas was unaware of what happened at the time the `drop` event was fired on it\n    //  use for side effects\n    this.fire('drop:after', options);\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  private _onContextMenu(e: TPointerEvent): false {\n    const target = this.findTarget(e),\n      subTargets = this.targets || [];\n    const options = this._basicEventHandler('contextmenu:before', {\n      e,\n      target,\n      subTargets,\n    });\n    // TODO: this line is silly because the dev can subscribe to the event and prevent it themselves\n    this.stopContextMenu && stopEvent(e);\n    this._basicEventHandler('contextmenu', options);\n    return false;\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  private _onDoubleClick(e: TPointerEvent) {\n    this._cacheTransformEventData(e);\n    this._handleEvent(e, 'dblclick');\n    this._resetTransformEventData();\n  }\n\n  /**\n   * Return a the id of an event.\n   * returns either the pointerId or the identifier or 0 for the mouse event\n   * @private\n   * @param {Event} evt Event object\n   */\n  getPointerId(evt: TouchEvent | PointerEvent): number {\n    const changedTouches = (evt as TouchEvent).changedTouches;\n\n    if (changedTouches) {\n      return changedTouches[0] && changedTouches[0].identifier;\n    }\n\n    if (this.enablePointerEvents) {\n      return (evt as PointerEvent).pointerId;\n    }\n\n    return -1;\n  }\n\n  /**\n   * Determines if an event has the id of the event that is considered main\n   * @private\n   * @param {evt} event Event object\n   */\n  _isMainEvent(evt: TPointerEvent): boolean {\n    if ((evt as PointerEvent).isPrimary === true) {\n      return true;\n    }\n    if ((evt as PointerEvent).isPrimary === false) {\n      return false;\n    }\n    if (evt.type === 'touchend' && (evt as TouchEvent).touches.length === 0) {\n      return true;\n    }\n    if ((evt as TouchEvent).changedTouches) {\n      return (\n        (evt as TouchEvent).changedTouches[0].identifier === this.mainTouchId\n      );\n    }\n    return true;\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  _onTouchStart(e: TouchEvent) {\n    e.preventDefault();\n    if (this.mainTouchId === undefined) {\n      this.mainTouchId = this.getPointerId(e);\n    }\n    this.__onMouseDown(e);\n    this._resetTransformEventData();\n    const canvasElement = this.upperCanvasEl,\n      eventTypePrefix = this._getEventPrefix();\n    const doc = getDocumentFromElement(canvasElement);\n    addListener(\n      doc,\n      'touchend',\n      this._onTouchEnd as EventListener,\n      addEventOptions,\n    );\n    addListener(\n      doc,\n      'touchmove',\n      this._onMouseMove as EventListener,\n      addEventOptions,\n    );\n    // Unbind mousedown to prevent double triggers from touch devices\n    removeListener(\n      canvasElement,\n      `${eventTypePrefix}down`,\n      this._onMouseDown as EventListener,\n    );\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  _onMouseDown(e: TPointerEvent) {\n    this.__onMouseDown(e);\n    this._resetTransformEventData();\n    const canvasElement = this.upperCanvasEl,\n      eventTypePrefix = this._getEventPrefix();\n    removeListener(\n      canvasElement,\n      `${eventTypePrefix}move`,\n      this._onMouseMove as EventListener,\n      addEventOptions,\n    );\n    const doc = getDocumentFromElement(canvasElement);\n    addListener(doc, `${eventTypePrefix}up`, this._onMouseUp as EventListener);\n    addListener(\n      doc,\n      `${eventTypePrefix}move`,\n      this._onMouseMove as EventListener,\n      addEventOptions,\n    );\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  _onTouchEnd(e: TouchEvent) {\n    if (e.touches.length > 0) {\n      // if there are still touches stop here\n      return;\n    }\n    this.__onMouseUp(e);\n    this._resetTransformEventData();\n    delete this.mainTouchId;\n    const eventTypePrefix = this._getEventPrefix();\n    const doc = getDocumentFromElement(this.upperCanvasEl);\n    removeListener(\n      doc,\n      'touchend',\n      this._onTouchEnd as EventListener,\n      addEventOptions,\n    );\n    removeListener(\n      doc,\n      'touchmove',\n      this._onMouseMove as EventListener,\n      addEventOptions,\n    );\n    if (this._willAddMouseDown) {\n      clearTimeout(this._willAddMouseDown);\n    }\n    this._willAddMouseDown = setTimeout(() => {\n      // Wait 400ms before rebinding mousedown to prevent double triggers\n      // from touch devices\n      addListener(\n        this.upperCanvasEl,\n        `${eventTypePrefix}down`,\n        this._onMouseDown as EventListener,\n      );\n      this._willAddMouseDown = 0;\n    }, 400) as unknown as number;\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mouseup\n   */\n  _onMouseUp(e: TPointerEvent) {\n    this.__onMouseUp(e);\n    this._resetTransformEventData();\n    const canvasElement = this.upperCanvasEl,\n      eventTypePrefix = this._getEventPrefix();\n    if (this._isMainEvent(e)) {\n      const doc = getDocumentFromElement(this.upperCanvasEl);\n      removeListener(\n        doc,\n        `${eventTypePrefix}up`,\n        this._onMouseUp as EventListener,\n      );\n      removeListener(\n        doc,\n        `${eventTypePrefix}move`,\n        this._onMouseMove as EventListener,\n        addEventOptions,\n      );\n      addListener(\n        canvasElement,\n        `${eventTypePrefix}move`,\n        this._onMouseMove as EventListener,\n        addEventOptions,\n      );\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousemove\n   */\n  _onMouseMove(e: TPointerEvent) {\n    const activeObject = this.getActiveObject();\n    !this.allowTouchScrolling &&\n      (!activeObject ||\n        // a drag event sequence is started by the active object flagging itself on mousedown / mousedown:before\n        // we must not prevent the event's default behavior in order for the window to start dragging\n        !activeObject.shouldStartDragging(e)) &&\n      e.preventDefault &&\n      e.preventDefault();\n    this.__onMouseMove(e);\n  }\n\n  /**\n   * @private\n   */\n  _onResize() {\n    this.calcOffset();\n    this._resetTransformEventData();\n  }\n\n  /**\n   * Decides whether the canvas should be redrawn in mouseup and mousedown events.\n   * @private\n   * @param {Object} target\n   */\n  _shouldRender(target: FabricObject | undefined) {\n    const activeObject = this.getActiveObject();\n    // if just one of them is available or if they are both but are different objects\n    // this covers: switch of target, from target to no target, selection of target\n    // multiSelection with key and mouse\n    return (\n      !!activeObject !== !!target ||\n      (activeObject && target && activeObject !== target)\n    );\n  }\n\n  /**\n   * Method that defines the actions when mouse is released on canvas.\n   * The method resets the currentTransform parameters, store the image corner\n   * position in the image object and render the canvas on top.\n   * @private\n   * @param {Event} e Event object fired on mouseup\n   */\n  __onMouseUp(e: TPointerEvent) {\n    this._cacheTransformEventData(e);\n    this._handleEvent(e, 'up:before');\n\n    const transform = this._currentTransform;\n    const isClick = this._isClick;\n    const target = this._target;\n\n    // if right/middle click just fire events and return\n    // target undefined will make the _handleEvent search the target\n    const { button } = e as MouseEvent;\n    if (button) {\n      ((this.fireMiddleClick && button === 1) ||\n        (this.fireRightClick && button === 2)) &&\n        this._handleEvent(e, 'up');\n      this._resetTransformEventData();\n      return;\n    }\n\n    if (this.isDrawingMode && this._isCurrentlyDrawing) {\n      this._onMouseUpInDrawingMode(e);\n      return;\n    }\n\n    if (!this._isMainEvent(e)) {\n      return;\n    }\n    let shouldRender = false;\n    if (transform) {\n      this._finalizeCurrentTransform(e);\n      shouldRender = transform.actionPerformed;\n    }\n    if (!isClick) {\n      const targetWasActive = target === this._activeObject;\n      this.handleSelection(e);\n      if (!shouldRender) {\n        shouldRender =\n          this._shouldRender(target) ||\n          (!targetWasActive && target === this._activeObject);\n      }\n    }\n    let pointer, corner;\n    if (target) {\n      const found = target.findControl(\n        this.getViewportPoint(e),\n        isTouchEvent(e),\n      );\n      const { key, control } = found || {};\n      corner = key;\n      if (\n        target.selectable &&\n        target !== this._activeObject &&\n        target.activeOn === 'up'\n      ) {\n        this.setActiveObject(target, e);\n        shouldRender = true;\n      } else if (control) {\n        const mouseUpHandler = control.getMouseUpHandler(e, target, control);\n        if (mouseUpHandler) {\n          pointer = this.getScenePoint(e);\n          mouseUpHandler.call(control, e, transform!, pointer.x, pointer.y);\n        }\n      }\n      target.isMoving = false;\n    }\n    // if we are ending up a transform on a different control or a new object\n    // fire the original mouse up from the corner that started the transform\n    if (\n      transform &&\n      (transform.target !== target || transform.corner !== corner)\n    ) {\n      const originalControl =\n          transform.target && transform.target.controls[transform.corner],\n        originalMouseUpHandler =\n          originalControl &&\n          originalControl.getMouseUpHandler(\n            e,\n            transform.target,\n            originalControl,\n          );\n      pointer = pointer || this.getScenePoint(e);\n      originalMouseUpHandler &&\n        originalMouseUpHandler.call(\n          originalControl,\n          e,\n          transform,\n          pointer.x,\n          pointer.y,\n        );\n    }\n    this._setCursorFromEvent(e, target);\n    this._handleEvent(e, 'up');\n    this._groupSelector = null;\n    this._currentTransform = null;\n    // reset the target information about which corner is selected\n    target && (target.__corner = undefined);\n    if (shouldRender) {\n      this.requestRenderAll();\n    } else if (!isClick && !(this._activeObject as IText)?.isEditing) {\n      this.renderTop();\n    }\n  }\n\n  _basicEventHandler<T extends keyof (CanvasEvents | ObjectEvents)>(\n    eventType: T,\n    options: (CanvasEvents & ObjectEvents)[T],\n  ) {\n    const { target, subTargets = [] } = options as {\n      target?: FabricObject;\n      subTargets: FabricObject[];\n    };\n    this.fire(eventType, options);\n    target && target.fire(eventType, options);\n    for (let i = 0; i < subTargets.length; i++) {\n      subTargets[i] !== target && subTargets[i].fire(eventType, options);\n    }\n    return options;\n  }\n\n  /**\n   * @private\n   * Handle event firing for target and subtargets\n   * @param {TPointerEvent} e event from mouse\n   * @param {TPointerEventNames} eventType\n   */\n  _handleEvent<T extends TPointerEventNames>(e: TPointerEvent, eventType: T) {\n    const target = this._target,\n      targets = this.targets || [],\n      options: CanvasEvents[`mouse:${T}`] = {\n        e,\n        target,\n        subTargets: targets,\n        ...getEventPoints(this, e),\n        transform: this._currentTransform,\n        ...(eventType === 'up:before' || eventType === 'up'\n          ? {\n              isClick: this._isClick,\n              currentTarget: this.findTarget(e),\n              // set by the preceding `findTarget` call\n              currentSubTargets: this.targets,\n            }\n          : {}),\n      } as CanvasEvents[`mouse:${T}`];\n    this.fire(`mouse:${eventType}`, options);\n    // this may be a little be more complicated of what we want to handle\n    target && target.fire(`mouse${eventType}`, options);\n    for (let i = 0; i < targets.length; i++) {\n      targets[i] !== target && targets[i].fire(`mouse${eventType}`, options);\n    }\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  _onMouseDownInDrawingMode(e: TPointerEvent) {\n    this._isCurrentlyDrawing = true;\n    if (this.getActiveObject()) {\n      this.discardActiveObject(e);\n      this.requestRenderAll();\n    }\n    // TODO: this is a scene point so it should be renamed\n    const pointer = this.getScenePoint(e);\n    this.freeDrawingBrush &&\n      this.freeDrawingBrush.onMouseDown(pointer, { e, pointer });\n    this._handleEvent(e, 'down');\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mousemove\n   */\n  _onMouseMoveInDrawingMode(e: TPointerEvent) {\n    if (this._isCurrentlyDrawing) {\n      const pointer = this.getScenePoint(e);\n      this.freeDrawingBrush &&\n        this.freeDrawingBrush.onMouseMove(pointer, {\n          e,\n          // this is an absolute pointer, the naming is wrong\n          pointer,\n        });\n    }\n    this.setCursor(this.freeDrawingCursor);\n    this._handleEvent(e, 'move');\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event object fired on mouseup\n   */\n  _onMouseUpInDrawingMode(e: TPointerEvent) {\n    const pointer = this.getScenePoint(e);\n    if (this.freeDrawingBrush) {\n      this._isCurrentlyDrawing = !!this.freeDrawingBrush.onMouseUp({\n        e: e,\n        // this is an absolute pointer, the naming is wrong\n        pointer,\n      });\n    } else {\n      this._isCurrentlyDrawing = false;\n    }\n    this._handleEvent(e, 'up');\n  }\n\n  /**\n   * Method that defines the actions when mouse is clicked on canvas.\n   * The method inits the currentTransform parameters and renders all the\n   * canvas so the current image can be placed on the top canvas and the rest\n   * in on the container one.\n   * @private\n   * @param {Event} e Event object fired on mousedown\n   */\n  __onMouseDown(e: TPointerEvent) {\n    this._isClick = true;\n    this._cacheTransformEventData(e);\n    this._handleEvent(e, 'down:before');\n\n    let target: FabricObject | undefined = this._target;\n\n    // if right/middle click just fire events\n    const { button } = e as MouseEvent;\n    if (button) {\n      ((this.fireMiddleClick && button === 1) ||\n        (this.fireRightClick && button === 2)) &&\n        this._handleEvent(e, 'down');\n      this._resetTransformEventData();\n      return;\n    }\n\n    if (this.isDrawingMode) {\n      this._onMouseDownInDrawingMode(e);\n      return;\n    }\n\n    if (!this._isMainEvent(e)) {\n      return;\n    }\n\n    // ignore if some object is being transformed at this moment\n    if (this._currentTransform) {\n      return;\n    }\n\n    let shouldRender = this._shouldRender(target);\n    let grouped = false;\n    if (this.handleMultiSelection(e, target)) {\n      // active object might have changed while grouping\n      target = this._activeObject;\n      grouped = true;\n      shouldRender = true;\n    } else if (this._shouldClearSelection(e, target)) {\n      this.discardActiveObject(e);\n    }\n    // we start a group selector rectangle if\n    // selection is enabled\n    // and there is no target, or the following 3 conditions are satisfied:\n    // target is not selectable ( otherwise we selected it )\n    // target is not editing\n    // target is not already selected ( otherwise we drag )\n    if (\n      this.selection &&\n      (!target ||\n        (!target.selectable &&\n          !(target as IText).isEditing &&\n          target !== this._activeObject))\n    ) {\n      const p = this.getScenePoint(e);\n      this._groupSelector = {\n        x: p.x,\n        y: p.y,\n        deltaY: 0,\n        deltaX: 0,\n      };\n    }\n\n    if (target) {\n      const alreadySelected = target === this._activeObject;\n      if (target.selectable && target.activeOn === 'down') {\n        this.setActiveObject(target, e);\n      }\n      const handle = target.findControl(\n        this.getViewportPoint(e),\n        isTouchEvent(e),\n      );\n      if (target === this._activeObject && (handle || !grouped)) {\n        this._setupCurrentTransform(e, target, alreadySelected);\n        const control = handle ? handle.control : undefined,\n          pointer = this.getScenePoint(e),\n          mouseDownHandler =\n            control && control.getMouseDownHandler(e, target, control);\n        mouseDownHandler &&\n          mouseDownHandler.call(\n            control,\n            e,\n            this._currentTransform!,\n            pointer.x,\n            pointer.y,\n          );\n      }\n    }\n    //  we clear `_objectsToRender` in case of a change in order to repopulate it at rendering\n    //  run before firing the `down` event to give the dev a chance to populate it themselves\n    shouldRender && (this._objectsToRender = undefined);\n    this._handleEvent(e, 'down');\n    // we must renderAll so that we update the visuals\n    shouldRender && this.requestRenderAll();\n  }\n\n  /**\n   * reset cache form common information needed during event processing\n   * @private\n   */\n  _resetTransformEventData() {\n    this._target = undefined;\n    this._pointer = undefined;\n    this._absolutePointer = undefined;\n  }\n\n  /**\n   * Cache common information needed during event processing\n   * @private\n   * @param {Event} e Event object fired on event\n   */\n  _cacheTransformEventData(e: TPointerEvent) {\n    // reset in order to avoid stale caching\n    this._resetTransformEventData();\n    this._pointer = this.getViewportPoint(e);\n    this._absolutePointer = sendPointToPlane(\n      this._pointer,\n      undefined,\n      this.viewportTransform,\n    );\n    this._target = this._currentTransform\n      ? this._currentTransform.target\n      : this.findTarget(e);\n  }\n\n  /**\n   * Method that defines the actions when mouse is hovering the canvas.\n   * The currentTransform parameter will define whether the user is rotating/scaling/translating\n   * an image or neither of them (only hovering). A group selection is also possible and would cancel\n   * all any other type of action.\n   * In case of an image transformation only the top canvas will be rendered.\n   * @private\n   * @param {Event} e Event object fired on mousemove\n   */\n  __onMouseMove(e: TPointerEvent) {\n    this._isClick = false;\n    this._cacheTransformEventData(e);\n    this._handleEvent(e, 'move:before');\n\n    if (this.isDrawingMode) {\n      this._onMouseMoveInDrawingMode(e);\n      return;\n    }\n\n    if (!this._isMainEvent(e)) {\n      return;\n    }\n\n    const groupSelector = this._groupSelector;\n\n    // We initially clicked in an empty area, so we draw a box for multiple selection\n    if (groupSelector) {\n      const pointer = this.getScenePoint(e);\n\n      groupSelector.deltaX = pointer.x - groupSelector.x;\n      groupSelector.deltaY = pointer.y - groupSelector.y;\n\n      this.renderTop();\n    } else if (!this._currentTransform) {\n      const target = this.findTarget(e);\n      this._setCursorFromEvent(e, target);\n      this._fireOverOutEvents(e, target);\n    } else {\n      this._transformObject(e);\n    }\n    this.textEditingManager.onMouseMove(e);\n    this._handleEvent(e, 'move');\n    this._resetTransformEventData();\n  }\n\n  /**\n   * Manage the mouseout, mouseover events for the fabric object on the canvas\n   * @param {Fabric.Object} target the target where the target from the mousemove event\n   * @param {Event} e Event object fired on mousemove\n   * @private\n   */\n  _fireOverOutEvents(e: TPointerEvent, target?: FabricObject) {\n    const _hoveredTarget = this._hoveredTarget,\n      _hoveredTargets = this._hoveredTargets,\n      targets = this.targets,\n      length = Math.max(_hoveredTargets.length, targets.length);\n\n    this.fireSyntheticInOutEvents('mouse', {\n      e,\n      target,\n      oldTarget: _hoveredTarget,\n      fireCanvas: true,\n    });\n    for (let i = 0; i < length; i++) {\n      this.fireSyntheticInOutEvents('mouse', {\n        e,\n        target: targets[i],\n        oldTarget: _hoveredTargets[i],\n      });\n    }\n    this._hoveredTarget = target;\n    this._hoveredTargets = this.targets.concat();\n  }\n\n  /**\n   * Manage the dragEnter, dragLeave events for the fabric objects on the canvas\n   * @param {Fabric.Object} target the target where the target from the onDrag event\n   * @param {Object} data Event object fired on dragover\n   * @private\n   */\n  _fireEnterLeaveEvents(target: FabricObject | undefined, data: DragEventData) {\n    const draggedoverTarget = this._draggedoverTarget,\n      _hoveredTargets = this._hoveredTargets,\n      targets = this.targets,\n      length = Math.max(_hoveredTargets.length, targets.length);\n\n    this.fireSyntheticInOutEvents('drag', {\n      ...data,\n      target,\n      oldTarget: draggedoverTarget,\n      fireCanvas: true,\n    });\n    for (let i = 0; i < length; i++) {\n      this.fireSyntheticInOutEvents('drag', {\n        ...data,\n        target: targets[i],\n        oldTarget: _hoveredTargets[i],\n      });\n    }\n    this._draggedoverTarget = target;\n  }\n\n  /**\n   * Manage the synthetic in/out events for the fabric objects on the canvas\n   * @param {Fabric.Object} target the target where the target from the supported events\n   * @param {Object} data Event object fired\n   * @param {Object} config configuration for the function to work\n   * @param {String} config.targetName property on the canvas where the old target is stored\n   * @param {String} [config.canvasEvtOut] name of the event to fire at canvas level for out\n   * @param {String} config.evtOut name of the event to fire for out\n   * @param {String} [config.canvasEvtIn] name of the event to fire at canvas level for in\n   * @param {String} config.evtIn name of the event to fire for in\n   * @private\n   */\n  fireSyntheticInOutEvents<T extends keyof TSyntheticEventContext>(\n    type: T,\n    {\n      target,\n      oldTarget,\n      fireCanvas,\n      e,\n      ...data\n    }: TSyntheticEventContext[T] & {\n      target?: FabricObject;\n      oldTarget?: FabricObject;\n      fireCanvas?: boolean;\n    },\n  ) {\n    const { targetIn, targetOut, canvasIn, canvasOut } =\n      syntheticEventConfig[type];\n    const targetChanged = oldTarget !== target;\n\n    if (oldTarget && targetChanged) {\n      const outOpt: CanvasEvents[typeof canvasOut] = {\n        ...data,\n        e,\n        target: oldTarget,\n        nextTarget: target,\n        ...getEventPoints(this, e),\n      };\n      fireCanvas && this.fire(canvasOut, outOpt);\n      oldTarget.fire(targetOut, outOpt);\n    }\n    if (target && targetChanged) {\n      const inOpt: CanvasEvents[typeof canvasIn] = {\n        ...data,\n        e,\n        target,\n        previousTarget: oldTarget,\n        ...getEventPoints(this, e),\n      };\n      fireCanvas && this.fire(canvasIn, inOpt);\n      target.fire(targetIn, inOpt);\n    }\n  }\n\n  /**\n   * Method that defines actions when an Event Mouse Wheel\n   * @param {Event} e Event object fired on mouseup\n   */\n  __onMouseWheel(e: TPointerEvent) {\n    this._cacheTransformEventData(e);\n    this._handleEvent(e, 'wheel');\n    this._resetTransformEventData();\n  }\n\n  /**\n   * @private\n   * @param {Event} e Event fired on mousemove\n   */\n  _transformObject(e: TPointerEvent) {\n    const scenePoint = this.getScenePoint(e),\n      transform = this._currentTransform!,\n      target = transform.target,\n      //  transform pointer to target's containing coordinate plane\n      //  both pointer and object should agree on every point\n      localPointer = target.group\n        ? sendPointToPlane(\n            scenePoint,\n            undefined,\n            target.group.calcTransformMatrix(),\n          )\n        : scenePoint;\n    transform.shiftKey = e.shiftKey;\n    transform.altKey = !!this.centeredKey && e[this.centeredKey];\n\n    this._performTransformAction(e, transform, localPointer);\n    transform.actionPerformed && this.requestRenderAll();\n  }\n\n  /**\n   * @private\n   */\n  _performTransformAction(\n    e: TPointerEvent,\n    transform: Transform,\n    pointer: Point,\n  ) {\n    const { action, actionHandler, target } = transform;\n\n    const actionPerformed =\n      !!actionHandler && actionHandler(e, transform, pointer.x, pointer.y);\n    actionPerformed && target.setCoords();\n\n    // this object could be created from the function in the control handlers\n    if (action === 'drag' && actionPerformed) {\n      transform.target.isMoving = true;\n      this.setCursor(transform.target.moveCursor || this.moveCursor);\n    }\n    transform.actionPerformed = transform.actionPerformed || actionPerformed;\n  }\n\n  /**\n   * Sets the cursor depending on where the canvas is being hovered.\n   * Note: very buggy in Opera\n   * @param {Event} e Event object\n   * @param {Object} target Object that the mouse is hovering, if so.\n   */\n  _setCursorFromEvent(e: TPointerEvent, target?: FabricObject) {\n    if (!target) {\n      this.setCursor(this.defaultCursor);\n      return;\n    }\n    let hoverCursor = target.hoverCursor || this.hoverCursor;\n    const activeSelection = isActiveSelection(this._activeObject)\n        ? this._activeObject\n        : null,\n      // only show proper corner when group selection is not active\n      corner =\n        (!activeSelection || target.group !== activeSelection) &&\n        // here we call findTargetCorner always with undefined for the touch parameter.\n        // we assume that if you are using a cursor you do not need to interact with\n        // the bigger touch area.\n        target.findControl(this.getViewportPoint(e));\n\n    if (!corner) {\n      if ((target as Group).subTargetCheck) {\n        // hoverCursor should come from top-most subTarget,\n        // so we walk the array backwards\n        this.targets\n          .concat()\n          .reverse()\n          .map((_target) => {\n            hoverCursor = _target.hoverCursor || hoverCursor;\n          });\n      }\n      this.setCursor(hoverCursor);\n    } else {\n      const control = corner.control;\n      this.setCursor(control.cursorStyleHandler(e, control, target));\n    }\n  }\n\n  /**\n   * ## Handles multiple selection\n   * - toggles `target` selection (selects/deselects `target` if it isn't/is selected respectively)\n   * - sets the active object in case it is not set or in case there is a single active object left under active selection.\n   * ---\n   * - If the active object is the active selection we add/remove `target` from it\n   * - If not, add the active object and `target` to the active selection and make it the active object.\n   * @private\n   * @param {TPointerEvent} e Event object\n   * @param {FabricObject} target target of event to select/deselect\n   * @returns true if grouping occurred\n   */\n  protected handleMultiSelection(e: TPointerEvent, target?: FabricObject) {\n    const activeObject = this._activeObject;\n    const isAS = isActiveSelection(activeObject);\n    if (\n      // check if an active object exists on canvas and if the user is pressing the `selectionKey` while canvas supports multi selection.\n      !!activeObject &&\n      this._isSelectionKeyPressed(e) &&\n      this.selection &&\n      // on top of that the user also has to hit a target that is selectable.\n      !!target &&\n      target.selectable &&\n      // group target and active object only if they are different objects\n      // else we try to find a subtarget of `ActiveSelection`\n      (activeObject !== target || isAS) &&\n      //  make sure `activeObject` and `target` aren't ancestors of each other in case `activeObject` is not `ActiveSelection`\n      // if it is then we want to remove `target` from it\n      (isAS ||\n        (!target.isDescendantOf(activeObject) &&\n          !activeObject.isDescendantOf(target))) &&\n      //  target accepts selection\n      !target.onSelect({ e }) &&\n      // make sure we are not on top of a control\n      !activeObject.getActiveControl()\n    ) {\n      if (isAS) {\n        const prevActiveObjects = activeObject.getObjects();\n        if (target === activeObject) {\n          const pointer = this.getViewportPoint(e);\n          target =\n            // first search active objects for a target to remove\n            this.searchPossibleTargets(prevActiveObjects, pointer) ||\n            //  if not found, search under active selection for a target to add\n            // `prevActiveObjects` will be searched but we already know they will not be found\n            this.searchPossibleTargets(this._objects, pointer);\n          // if nothing is found bail out\n          if (!target || !target.selectable) {\n            return false;\n          }\n        }\n        if (target.group === activeObject) {\n          // `target` is part of active selection => remove it\n          activeObject.remove(target);\n          this._hoveredTarget = target;\n          this._hoveredTargets = [...this.targets];\n          // if after removing an object we are left with one only...\n          if (activeObject.size() === 1) {\n            // activate last remaining object\n            // deselecting the active selection will remove the remaining object from it\n            this._setActiveObject(activeObject.item(0), e);\n          }\n        } else {\n          // `target` isn't part of active selection => add it\n          activeObject.multiSelectAdd(target);\n          this._hoveredTarget = activeObject;\n          this._hoveredTargets = [...this.targets];\n        }\n        this._fireSelectionEvents(prevActiveObjects, e);\n      } else {\n        (activeObject as IText).exitEditing &&\n          (activeObject as IText).exitEditing();\n        // add the active object and the target to the active selection and set it as the active object\n        const klass =\n          classRegistry.getClass<typeof ActiveSelection>('ActiveSelection');\n        const newActiveSelection = new klass([], {\n          /**\n           * it is crucial to pass the canvas ref before calling {@link ActiveSelection#multiSelectAdd}\n           * since it uses {@link FabricObject#isInFrontOf} which relies on the canvas ref\n           */\n          canvas: this,\n        });\n        newActiveSelection.multiSelectAdd(activeObject, target);\n        this._hoveredTarget = newActiveSelection;\n        // ISSUE 4115: should we consider subTargets here?\n        // this._hoveredTargets = [];\n        // this._hoveredTargets = this.targets.concat();\n        this._setActiveObject(newActiveSelection, e);\n        this._fireSelectionEvents([activeObject], e);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * ## Handles selection\n   * - selects objects that are contained in (and possibly intersecting) the selection bounding box\n   * - sets the active object\n   * ---\n   * runs on mouse up after a mouse move\n   */\n  protected handleSelection(e: TPointerEvent) {\n    if (!this.selection || !this._groupSelector) {\n      return false;\n    }\n    const { x, y, deltaX, deltaY } = this._groupSelector,\n      point1 = new Point(x, y),\n      point2 = point1.add(new Point(deltaX, deltaY)),\n      tl = point1.min(point2),\n      br = point1.max(point2),\n      size = br.subtract(tl);\n\n    const collectedObjects = this.collectObjects(\n      {\n        left: tl.x,\n        top: tl.y,\n        width: size.x,\n        height: size.y,\n      },\n      { includeIntersecting: !this.selectionFullyContained },\n    ) as FabricObject[];\n\n    const objects =\n      // though this method runs only after mouse move the pointer could do a mouse up on the same position as mouse down\n      // should it be handled as is?\n      point1.eq(point2)\n        ? collectedObjects[0]\n          ? [collectedObjects[0]]\n          : []\n        : collectedObjects.length > 1\n          ? collectedObjects\n              .filter((object) => !object.onSelect({ e }))\n              .reverse()\n          : // `setActiveObject` will call `onSelect(collectedObjects[0])` in this case\n            collectedObjects;\n\n    // set active object\n    if (objects.length === 1) {\n      // set as active object\n      this.setActiveObject(objects[0], e);\n    } else if (objects.length > 1) {\n      // add to active selection and make it the active object\n      const klass =\n        classRegistry.getClass<typeof ActiveSelection>('ActiveSelection');\n      this.setActiveObject(new klass(objects, { canvas: this }), e);\n    }\n\n    // cleanup\n    this._groupSelector = null;\n    return true;\n  }\n\n  /**\n   * @override clear {@link textEditingManager}\n   */\n  clear() {\n    this.textEditingManager.clear();\n    super.clear();\n  }\n\n  /**\n   * @override clear {@link textEditingManager}\n   */\n  destroy() {\n    this.removeListeners();\n    this.textEditingManager.dispose();\n    super.destroy();\n  }\n}\n"],"names":["addEventOptions","passive","getEventPoints","canvas","e","viewportPoint","getViewportPoint","scenePoint","getScenePoint","pointer","absolutePointer","addListener","el","_len","arguments","length","args","Array","_key","addEventListener","removeListener","_len2","_key2","removeEventListener","syntheticEventConfig","mouse","in","out","targetIn","targetOut","canvasIn","canvasOut","drag","Canvas","SelectableCanvas","constructor","super","undefined","_defineProperty","this","TextEditingManager","forEach","eventHandler","bind","addOrRemove","_getEventPrefix","enablePointerEvents","functor","_eventjsFunctor","canvasElement","upperCanvasEl","eventTypePrefix","getWindowFromElement","_onResize","_onMouseDown","concat","_onMouseMove","_onMouseOut","_onMouseEnter","_onMouseWheel","_onContextMenu","_onDoubleClick","_onDragStart","_onDragEnd","_onDragOver","_onDragEnter","_onDragLeave","_onDrop","_onTouchStart","removeListeners","doc","getDocumentFromElement","_onMouseUp","_onTouchEnd","__onMouseWheel","target","_hoveredTarget","shared","_objectSpread","fire","_hoveredTargets","nestedTarget","_currentTransform","findTarget","_isClick","activeObject","getActiveObject","onDragStart","_dragSource","options","_onDragProgress","stopEvent","_renderDragEffects","source","dirty","dropTarget","_dropTarget","clearContextTop","ctx","contextTop","save","transform","viewportTransform","renderDragSourceEffect","restore","renderDropTargetEffect","contextTopDirty","didDrop","dataTransfer","dropEffect","NONE","_activeObject","subTargets","targets","dragSource","_draggedoverTarget","findDragTargets","_searchPossibleTargets","_objects","eventType","canDrop","_fireEnterLeaveEvents","i","subTarget","_basicEventHandler","stopContextMenu","_cacheTransformEventData","_handleEvent","_resetTransformEventData","getPointerId","evt","changedTouches","identifier","pointerId","_isMainEvent","isPrimary","type","touches","mainTouchId","preventDefault","__onMouseDown","__onMouseUp","_willAddMouseDown","clearTimeout","setTimeout","allowTouchScrolling","shouldStartDragging","__onMouseMove","calcOffset","_shouldRender","_this$_activeObject","isClick","_target","button","fireMiddleClick","fireRightClick","isDrawingMode","_isCurrentlyDrawing","_onMouseUpInDrawingMode","corner","shouldRender","_finalizeCurrentTransform","actionPerformed","targetWasActive","handleSelection","found","findControl","isTouchEvent","key","control","selectable","activeOn","setActiveObject","mouseUpHandler","getMouseUpHandler","call","x","y","isMoving","originalControl","controls","originalMouseUpHandler","_setCursorFromEvent","_groupSelector","__corner","requestRenderAll","isEditing","renderTop","currentTarget","currentSubTargets","_onMouseDownInDrawingMode","discardActiveObject","freeDrawingBrush","onMouseDown","_onMouseMoveInDrawingMode","onMouseMove","setCursor","freeDrawingCursor","onMouseUp","grouped","handleMultiSelection","_shouldClearSelection","selection","p","deltaY","deltaX","alreadySelected","handle","_setupCurrentTransform","mouseDownHandler","getMouseDownHandler","_objectsToRender","_pointer","_absolutePointer","sendPointToPlane","groupSelector","_transformObject","_fireOverOutEvents","textEditingManager","Math","max","fireSyntheticInOutEvents","oldTarget","fireCanvas","data","draggedoverTarget","_ref","_objectWithoutProperties","_excluded","targetChanged","outOpt","nextTarget","inOpt","previousTarget","localPointer","group","calcTransformMatrix","shiftKey","altKey","centeredKey","_performTransformAction","action","actionHandler","setCoords","moveCursor","defaultCursor","hoverCursor","activeSelection","isActiveSelection","cursorStyleHandler","subTargetCheck","reverse","map","isAS","_isSelectionKeyPressed","isDescendantOf","onSelect","getActiveControl","prevActiveObjects","getObjects","searchPossibleTargets","remove","size","_setActiveObject","item","multiSelectAdd","_fireSelectionEvents","exitEditing","newActiveSelection","classRegistry","getClass","point1","Point","point2","add","tl","min","subtract","collectedObjects","collectObjects","left","top","width","height","includeIntersecting","selectionFullyContained","objects","eq","filter","object","klass","clear","destroy","dispose"],"mappings":"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"}