{"version":3,"file":"ClipPathLayout.min.mjs","sources":["../../../../src/LayoutManager/LayoutStrategies/ClipPathLayout.ts"],"sourcesContent":["import { Point } from '../../Point';\nimport type { FabricObject } from '../../shapes/Object/FabricObject';\nimport { makeBoundingBoxFromPoints } from '../../util/misc/boundingBoxFromPoints';\nimport { sendPointToPlane } from '../../util/misc/planeChange';\nimport type { LayoutStrategyResult, StrictLayoutContext } from '../types';\nimport { LayoutStrategy } from './LayoutStrategy';\nimport { getObjectBounds } from './utils';\nimport { classRegistry } from '../../ClassRegistry';\n\n/**\n * Layout will adjust the bounding box to match the clip path bounding box.\n */\nexport class ClipPathLayout extends LayoutStrategy {\n  static readonly type = 'clip-path';\n\n  shouldPerformLayout(context: StrictLayoutContext): boolean {\n    return !!context.target.clipPath && super.shouldPerformLayout(context);\n  }\n\n  shouldLayoutClipPath() {\n    return false;\n  }\n\n  calcLayoutResult(\n    context: StrictLayoutContext,\n    objects: FabricObject[],\n  ): LayoutStrategyResult | undefined {\n    const { target } = context;\n    const { clipPath, group } = target;\n    if (!clipPath || !this.shouldPerformLayout(context)) {\n      return;\n    }\n    // TODO: remove stroke calculation from this case\n    const { width, height } = makeBoundingBoxFromPoints(\n      getObjectBounds(target, clipPath as FabricObject),\n    );\n    const size = new Point(width, height);\n    if (clipPath.absolutePositioned) {\n      //  we want the center point to exist in group's containing plane\n      const clipPathCenter = sendPointToPlane(\n        clipPath.getRelativeCenterPoint(),\n        undefined,\n        group ? group.calcTransformMatrix() : undefined,\n      );\n      return {\n        center: clipPathCenter,\n        size,\n      };\n    } else {\n      //  we want the center point to exist in group's containing plane, so we send it upwards\n      const clipPathCenter = clipPath\n        .getRelativeCenterPoint()\n        .transform(target.calcOwnMatrix(), true);\n      if (this.shouldPerformLayout(context)) {\n        // the clip path is positioned relative to the group's center which is affected by the bbox\n        // so we first calculate the bbox\n        const { center = new Point(), correction = new Point() } =\n          this.calcBoundingBox(objects, context) || {};\n        return {\n          center: center.add(clipPathCenter),\n          correction: correction.subtract(clipPathCenter),\n          size,\n        };\n      } else {\n        return {\n          center: target.getRelativeCenterPoint().add(clipPathCenter),\n          size,\n        };\n      }\n    }\n  }\n}\n\nclassRegistry.setClass(ClipPathLayout);\n"],"names":["ClipPathLayout","LayoutStrategy","shouldPerformLayout","context","target","clipPath","super","shouldLayoutClipPath","calcLayoutResult","objects","group","this","width","height","makeBoundingBoxFromPoints","getObjectBounds","size","Point","absolutePositioned","center","sendPointToPlane","getRelativeCenterPoint","undefined","calcTransformMatrix","clipPathCenter","transform","calcOwnMatrix","correction","calcBoundingBox","add","subtract","_defineProperty","classRegistry","setClass"],"mappings":"0cAYO,MAAMA,UAAuBC,EAGlCC,mBAAAA,CAAoBC,GAClB,QAASA,EAAQC,OAAOC,UAAYC,MAAMJ,oBAAoBC,EAChE,CAEAI,oBAAAA,GACE,OAAO,CACT,CAEAC,gBAAAA,CACEL,EACAM,GAEA,MAAML,OAAEA,GAAWD,GACbE,SAAEA,EAAQK,MAAEA,GAAUN,EAC5B,IAAKC,IAAaM,KAAKT,oBAAoBC,GACzC,OAGF,MAAMS,MAAEA,EAAKC,OAAEA,GAAWC,EACxBC,EAAgBX,EAAQC,IAEpBW,EAAO,IAAIC,EAAML,EAAOC,GAC9B,GAAIR,EAASa,mBAAoB,CAO/B,MAAO,CACLC,OANqBC,EACrBf,EAASgB,8BACTC,EACAZ,EAAQA,EAAMa,2BAAwBD,GAItCN,OAEJ,CAAO,CAEL,MAAMQ,EAAiBnB,EACpBgB,yBACAI,UAAUrB,EAAOsB,iBAAiB,GACrC,GAAIf,KAAKT,oBAAoBC,GAAU,CAGrC,MAAMgB,OAAEA,EAAS,IAAIF,EAAOU,WAAEA,EAAa,IAAIV,GAC7CN,KAAKiB,gBAAgBnB,EAASN,IAAY,CAAA,EAC5C,MAAO,CACLgB,OAAQA,EAAOU,IAAIL,GACnBG,WAAYA,EAAWG,SAASN,GAChCR,OAEJ,CACE,MAAO,CACLG,OAAQf,EAAOiB,yBAAyBQ,IAAIL,GAC5CR,OAGN,CACF,EACDe,EA3DY/B,EAAc,OACF,aA4DzBgC,EAAcC,SAASjC"}