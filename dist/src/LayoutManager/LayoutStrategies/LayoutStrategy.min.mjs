import{defineProperty as t}from"../../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{Point as e}from"../../Point.min.mjs";import{makeBoundingBoxFromPoints as r}from"../../util/misc/boundingBoxFromPoints.min.mjs";import{LAYOUT_TYPE_INITIALIZATION as i,LAYOUT_TYPE_IMPERATIVE as o}from"../constants.min.mjs";import{getObjectBounds as n}from"./utils.min.mjs";class s{calcLayoutResult(t,e){if(this.shouldPerformLayout(t))return this.calcBoundingBox(e,t)}shouldPerformLayout(t){let{type:e,prevStrategy:r,strategy:n}=t;return e===i||e===o||!!r&&n!==r}shouldLayoutClipPath(t){let{type:e,target:{clipPath:r}}=t;return e!==i&&r&&!r.absolutePositioned}getInitialSize(t,e){return e.size}calcBoundingBox(t,s){const{type:a,target:l}=s;if(a===o&&s.overrides)return s.overrides;if(0===t.length)return;const{left:m,top:u,width:c,height:p}=r(t.map((t=>n(l,t))).reduce(((t,e)=>t.concat(e)),[])),d=new e(c,p),f=new e(m,u).add(d.scalarDivide(2));if(a===i){const t=this.getInitialSize(s,{size:d,center:f});return{center:f,relativeCorrection:new e(0,0),size:t}}return{center:f.transform(l.calcOwnMatrix()),size:d}}}t(s,"type","strategy");export{s as LayoutStrategy};
//# sourceMappingURL=LayoutStrategy.min.mjs.map
