{"version":3,"file":"LayoutStrategy.min.mjs","sources":["../../../../src/LayoutManager/LayoutStrategies/LayoutStrategy.ts"],"sourcesContent":["import { Point } from '../../Point';\nimport type { FabricObject } from '../../shapes/Object/FabricObject';\nimport { makeBoundingBoxFromPoints } from '../../util/misc/boundingBoxFromPoints';\nimport {\n  LAYOUT_TYPE_INITIALIZATION,\n  LAYOUT_TYPE_IMPERATIVE,\n} from '../constants';\nimport type {\n  InitializationLayoutContext,\n  LayoutStrategyResult,\n  StrictLayoutContext,\n} from '../types';\nimport { getObjectBounds } from './utils';\n\n/**\n * Exposes a main public method {@link calcLayoutResult} that is used by the `LayoutManager` to perform layout.\n * Returning `undefined` signals the `LayoutManager` to skip the layout.\n *\n * In charge of calculating the bounding box of the passed objects.\n */\nexport abstract class LayoutStrategy {\n  /**\n   * override by subclass for persistence (TS does not support `static abstract`)\n   */\n  static type = 'strategy';\n\n  /**\n   * Used by the `LayoutManager` to perform layout\n   * @TODO/fix: if this method is calcResult, should calc unconditionally.\n   * the condition to not calc should be evaluated by the layoutManager.\n   * @returns layout result **OR** `undefined` to skip layout\n   */\n  public calcLayoutResult(\n    context: StrictLayoutContext,\n    objects: FabricObject[],\n  ): LayoutStrategyResult | undefined {\n    if (this.shouldPerformLayout(context)) {\n      return this.calcBoundingBox(objects, context);\n    }\n  }\n\n  shouldPerformLayout({ type, prevStrategy, strategy }: StrictLayoutContext) {\n    return (\n      type === LAYOUT_TYPE_INITIALIZATION ||\n      type === LAYOUT_TYPE_IMPERATIVE ||\n      (!!prevStrategy && strategy !== prevStrategy)\n    );\n  }\n\n  shouldLayoutClipPath({ type, target: { clipPath } }: StrictLayoutContext) {\n    return (\n      type !== LAYOUT_TYPE_INITIALIZATION &&\n      clipPath &&\n      !clipPath.absolutePositioned\n    );\n  }\n\n  getInitialSize(\n    context: StrictLayoutContext & InitializationLayoutContext,\n    result: Pick<LayoutStrategyResult, 'center' | 'size'>,\n  ) {\n    return result.size;\n  }\n\n  /**\n   * Override this method to customize layout.\n   */\n  calcBoundingBox(\n    objects: FabricObject[],\n    context: StrictLayoutContext,\n  ): LayoutStrategyResult | undefined {\n    const { type, target } = context;\n    if (type === LAYOUT_TYPE_IMPERATIVE && context.overrides) {\n      return context.overrides;\n    }\n    if (objects.length === 0) {\n      return;\n    }\n    const { left, top, width, height } = makeBoundingBoxFromPoints(\n      objects\n        .map((object) => getObjectBounds(target, object))\n        .reduce<Point[]>((coords, curr) => coords.concat(curr), []),\n    );\n    const bboxSize = new Point(width, height);\n    const bboxLeftTop = new Point(left, top);\n    const bboxCenter = bboxLeftTop.add(bboxSize.scalarDivide(2));\n\n    if (type === LAYOUT_TYPE_INITIALIZATION) {\n      const actualSize = this.getInitialSize(context, {\n        size: bboxSize,\n        center: bboxCenter,\n      });\n      return {\n        // in `initialization` we do not account for target's transformation matrix\n        center: bboxCenter,\n        // TODO: investigate if this is still necessary\n        relativeCorrection: new Point(0, 0),\n        size: actualSize,\n      };\n    } else {\n      //  we send `relativeCenter` up to group's containing plane\n      const center = bboxCenter.transform(target.calcOwnMatrix());\n      return {\n        center,\n        size: bboxSize,\n      };\n    }\n  }\n}\n"],"names":["LayoutStrategy","calcLayoutResult","context","objects","this","shouldPerformLayout","calcBoundingBox","_ref","type","prevStrategy","strategy","LAYOUT_TYPE_INITIALIZATION","LAYOUT_TYPE_IMPERATIVE","shouldLayoutClipPath","_ref2","target","clipPath","absolutePositioned","getInitialSize","result","size","overrides","length","left","top","width","height","makeBoundingBoxFromPoints","map","object","getObjectBounds","reduce","coords","curr","concat","bboxSize","Point","bboxCenter","add","scalarDivide","actualSize","center","relativeCorrection","transform","calcOwnMatrix","_defineProperty"],"mappings":"2WAoBO,MAAeA,EAYbC,gBAAAA,CACLC,EACAC,GAEA,GAAIC,KAAKC,oBAAoBH,GAC3B,OAAOE,KAAKE,gBAAgBH,EAASD,EAEzC,CAEAG,mBAAAA,CAAmBE,GAAwD,IAAvDC,KAAEA,EAAIC,aAAEA,EAAYC,SAAEA,GAA+BH,EACvE,OACEC,IAASG,GACTH,IAASI,KACNH,GAAgBC,IAAaD,CAEpC,CAEAI,oBAAAA,CAAoBC,GAAsD,IAArDN,KAAEA,EAAMO,QAAQC,SAAEA,IAAiCF,EACtE,OACEN,IAASG,GACTK,IACCA,EAASC,kBAEd,CAEAC,cAAAA,CACEhB,EACAiB,GAEA,OAAOA,EAAOC,IAChB,CAKAd,eAAAA,CACEH,EACAD,GAEA,MAAMM,KAAEA,EAAIO,OAAEA,GAAWb,EACzB,GAAIM,IAASI,GAA0BV,EAAQmB,UAC7C,OAAOnB,EAAQmB,UAEjB,GAAuB,IAAnBlB,EAAQmB,OACV,OAEF,MAAMC,KAAEA,EAAIC,IAAEA,EAAGC,MAAEA,EAAKC,OAAEA,GAAWC,EACnCxB,EACGyB,KAAKC,GAAWC,EAAgBf,EAAQc,KACxCE,QAAgB,CAACC,EAAQC,IAASD,EAAOE,OAAOD,IAAO,KAEtDE,EAAW,IAAIC,EAAMX,EAAOC,GAE5BW,EADc,IAAID,EAAMb,EAAMC,GACLc,IAAIH,EAASI,aAAa,IAEzD,GAAI/B,IAASG,EAA4B,CACvC,MAAM6B,EAAapC,KAAKc,eAAehB,EAAS,CAC9CkB,KAAMe,EACNM,OAAQJ,IAEV,MAAO,CAELI,OAAQJ,EAERK,mBAAoB,IAAIN,EAAM,EAAG,GACjChB,KAAMoB,EAEV,CAGE,MAAO,CACLC,OAFaJ,EAAWM,UAAU5B,EAAO6B,iBAGzCxB,KAAMe,EAGZ,EAtFAU,EADoB7C,EAAc,OAIpB"}