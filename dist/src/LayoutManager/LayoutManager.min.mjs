import{defineProperty as t,objectSpread2 as e,objectWithoutProperties as r}from"../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{Point as s}from"../Point.min.mjs";import{MODIFIED as o,MOVING as a,RESIZING as i,ROTATING as n,SCALING as u,SKEWING as c,CHANGED as y,MODIFY_POLY as g,MODIFY_PATH as l,iMatrix as b,CENTER as p}from"../constants.min.mjs";import{invertTransform as h}from"../util/misc/matrix.min.mjs";import{resolveOrigin as m}from"../util/misc/resolveOrigin.min.mjs";import{FitContentLayout as f}from"./LayoutStrategies/FitContentLayout.min.mjs";import{LAYOUT_TYPE_OBJECT_MODIFIED as j,LAYOUT_TYPE_OBJECT_MODIFYING as d,LAYOUT_TYPE_INITIALIZATION as L,LAYOUT_TYPE_ADDED as v,LAYOUT_TYPE_REMOVED as x,LAYOUT_TYPE_IMPERATIVE as O}from"./constants.min.mjs";import{classRegistry as C}from"../ClassRegistry.min.mjs";const P=["strategy"],_=["target","strategy","bubbles","prevStrategy"],S="layoutManager";class w{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:new f;t(this,"strategy",void 0),this.strategy=e,this._subscriptions=new Map}performLayout(t){const r=e(e({bubbles:!0,strategy:this.strategy},t),{},{prevStrategy:this._prevLayoutStrategy,stopPropagation(){this.bubbles=!1}});this.onBeforeLayout(r);const s=this.getLayoutResult(r);s&&this.commitLayout(r,s),this.onAfterLayout(r,s),this._prevLayoutStrategy=r.strategy}attachHandlers(t,e){const{target:r}=e;return[o,a,i,n,u,c,y,g,l].map((e=>t.on(e,(t=>this.performLayout(e===o?{type:j,trigger:e,e:t,target:r}:{type:d,trigger:e,e:t,target:r})))))}subscribe(t,e){this.unsubscribe(t,e);const r=this.attachHandlers(t,e);this._subscriptions.set(t,r)}unsubscribe(t,e){(this._subscriptions.get(t)||[]).forEach((t=>t())),this._subscriptions.delete(t)}unsubscribeTargets(t){t.targets.forEach((e=>this.unsubscribe(e,t)))}subscribeTargets(t){t.targets.forEach((e=>this.subscribe(e,t)))}onBeforeLayout(t){const{target:s,type:o}=t,{canvas:a}=s;if(o===L||o===v?this.subscribeTargets(t):o===x&&this.unsubscribeTargets(t),s.fire("layout:before",{context:t}),a&&a.fire("object:layout:before",{target:s,context:t}),o===O&&t.deep){const o=r(t,P);s.forEachObject((t=>t.layoutManager&&t.layoutManager.performLayout(e(e({},o),{},{bubbles:!1,target:t}))))}}getLayoutResult(t){const{target:e,strategy:r,type:o}=t,a=r.calcLayoutResult(t,e.getObjects());if(!a)return;const i=o===L?new s:e.getRelativeCenterPoint(),{center:n,correction:u=new s,relativeCorrection:c=new s}=a,y=i.subtract(n).add(u).transform(o===L?b:h(e.calcOwnMatrix()),!0).add(c);return{result:a,prevCenter:i,nextCenter:n,offset:y}}commitLayout(t,e){const{target:r}=t,{result:{size:s},nextCenter:o}=e;var a,i;(r.set({width:s.x,height:s.y}),this.layoutObjects(t,e),t.type===L)?r.set({left:null!==(a=t.x)&&void 0!==a?a:o.x+s.x*m(r.originX),top:null!==(i=t.y)&&void 0!==i?i:o.y+s.y*m(r.originY)}):(r.setPositionByOrigin(o,p,p),r.setCoords(),r.set("dirty",!0))}layoutObjects(t,e){const{target:r}=t;r.forEachObject((s=>{s.group===r&&this.layoutObject(t,e,s)})),t.strategy.shouldLayoutClipPath(t)&&this.layoutObject(t,e,r.clipPath)}layoutObject(t,e,r){let{offset:s}=e;r.set({left:r.left+s.x,top:r.top+s.y})}onAfterLayout(t,s){const{target:o,strategy:a,bubbles:i,prevStrategy:n}=t,u=r(t,_),{canvas:c}=o;o.fire("layout:after",{context:t,result:s}),c&&c.fire("object:layout:after",{context:t,result:s,target:o});const y=o.parent;i&&null!=y&&y.layoutManager&&((u.path||(u.path=[])).push(o),y.layoutManager.performLayout(e(e({},u),{},{target:y}))),o.set("dirty",!0)}dispose(){const{_subscriptions:t}=this;t.forEach((t=>t.forEach((t=>t())))),t.clear()}toObject(){return{type:S,strategy:this.strategy.constructor.type}}toJSON(){return this.toObject()}}C.setClass(w,S);export{w as LayoutManager};
//# sourceMappingURL=LayoutManager.min.mjs.map
