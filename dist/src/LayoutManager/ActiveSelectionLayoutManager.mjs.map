{"version":3,"file":"ActiveSelectionLayoutManager.mjs","sources":["../../../src/LayoutManager/ActiveSelectionLayoutManager.ts"],"sourcesContent":["import { LayoutManager } from './LayoutManager';\nimport type { RegistrationContext, StrictLayoutContext } from './types';\nimport type { Group } from '../shapes/Group';\n\n/**\n * Today the LayoutManager class also takes care of subscribing event handlers\n * to update the group layout when the group is interactive and a transform is applied\n * to a child object.\n * The ActiveSelection is never interactive, but it could contain objects from\n * groups that are.\n * The standard LayoutManager would subscribe the children of the activeSelection to\n * perform layout changes to the active selection itself, what we need instead is that\n * the transformation applied to the active selection will trigger changes to the\n * original group of the children ( the one referenced under the parent property )\n * This subclass of the LayoutManager has a single duty to fill the gap of this difference.`\n */\nexport class ActiveSelectionLayoutManager extends LayoutManager {\n  subscribeTargets(\n    context: RegistrationContext & Partial<StrictLayoutContext>,\n  ): void {\n    const activeSelection = context.target;\n    const parents = context.targets.reduce((parents, target) => {\n      target.parent && parents.add(target.parent);\n      return parents;\n    }, new Set<Group>());\n    parents.forEach((parent) => {\n      parent.layoutManager.subscribeTargets({\n        target: parent,\n        targets: [activeSelection],\n      });\n    });\n  }\n\n  /**\n   * unsubscribe from parent only if all its children were deselected\n   */\n  unsubscribeTargets(\n    context: RegistrationContext & Partial<StrictLayoutContext>,\n  ): void {\n    const activeSelection = context.target;\n    const selectedObjects = activeSelection.getObjects();\n    const parents = context.targets.reduce((parents, target) => {\n      target.parent && parents.add(target.parent);\n      return parents;\n    }, new Set<Group>());\n    parents.forEach((parent) => {\n      !selectedObjects.some((object) => object.parent === parent) &&\n        parent.layoutManager.unsubscribeTargets({\n          target: parent,\n          targets: [activeSelection],\n        });\n    });\n  }\n}\n"],"names":["ActiveSelectionLayoutManager","LayoutManager","subscribeTargets","context","activeSelection","target","parents","targets","reduce","parent","add","Set","forEach","layoutManager","unsubscribeTargets","selectedObjects","getObjects","some","object"],"mappings":";;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMA,4BAA4B,SAASC,aAAa,CAAC;EAC9DC,gBAAgBA,CACdC,OAA2D,EACrD;AACN,IAAA,MAAMC,eAAe,GAAGD,OAAO,CAACE,MAAM,CAAA;AACtC,IAAA,MAAMC,OAAO,GAAGH,OAAO,CAACI,OAAO,CAACC,MAAM,CAAC,CAACF,OAAO,EAAED,MAAM,KAAK;MAC1DA,MAAM,CAACI,MAAM,IAAIH,OAAO,CAACI,GAAG,CAACL,MAAM,CAACI,MAAM,CAAC,CAAA;AAC3C,MAAA,OAAOH,OAAO,CAAA;AAChB,KAAC,EAAE,IAAIK,GAAG,EAAS,CAAC,CAAA;AACpBL,IAAAA,OAAO,CAACM,OAAO,CAAEH,MAAM,IAAK;AAC1BA,MAAAA,MAAM,CAACI,aAAa,CAACX,gBAAgB,CAAC;AACpCG,QAAAA,MAAM,EAAEI,MAAM;QACdF,OAAO,EAAE,CAACH,eAAe,CAAA;AAC3B,OAAC,CAAC,CAAA;AACJ,KAAC,CAAC,CAAA;AACJ,GAAA;;AAEA;AACF;AACA;EACEU,kBAAkBA,CAChBX,OAA2D,EACrD;AACN,IAAA,MAAMC,eAAe,GAAGD,OAAO,CAACE,MAAM,CAAA;AACtC,IAAA,MAAMU,eAAe,GAAGX,eAAe,CAACY,UAAU,EAAE,CAAA;AACpD,IAAA,MAAMV,OAAO,GAAGH,OAAO,CAACI,OAAO,CAACC,MAAM,CAAC,CAACF,OAAO,EAAED,MAAM,KAAK;MAC1DA,MAAM,CAACI,MAAM,IAAIH,OAAO,CAACI,GAAG,CAACL,MAAM,CAACI,MAAM,CAAC,CAAA;AAC3C,MAAA,OAAOH,OAAO,CAAA;AAChB,KAAC,EAAE,IAAIK,GAAG,EAAS,CAAC,CAAA;AACpBL,IAAAA,OAAO,CAACM,OAAO,CAAEH,MAAM,IAAK;AAC1B,MAAA,CAACM,eAAe,CAACE,IAAI,CAAEC,MAAM,IAAKA,MAAM,CAACT,MAAM,KAAKA,MAAM,CAAC,IACzDA,MAAM,CAACI,aAAa,CAACC,kBAAkB,CAAC;AACtCT,QAAAA,MAAM,EAAEI,MAAM;QACdF,OAAO,EAAE,CAACH,eAAe,CAAA;AAC3B,OAAC,CAAC,CAAA;AACN,KAAC,CAAC,CAAA;AACJ,GAAA;AACF;;;;"}