{"version":3,"file":"ActiveSelectionLayoutManager.min.mjs","sources":["../../../src/LayoutManager/ActiveSelectionLayoutManager.ts"],"sourcesContent":["import { LayoutManager } from './LayoutManager';\nimport type { RegistrationContext, StrictLayoutContext } from './types';\nimport type { Group } from '../shapes/Group';\n\n/**\n * Today the LayoutManager class also takes care of subscribing event handlers\n * to update the group layout when the group is interactive and a transform is applied\n * to a child object.\n * The ActiveSelection is never interactive, but it could contain objects from\n * groups that are.\n * The standard LayoutManager would subscribe the children of the activeSelection to\n * perform layout changes to the active selection itself, what we need instead is that\n * the transformation applied to the active selection will trigger changes to the\n * original group of the children ( the one referenced under the parent property )\n * This subclass of the LayoutManager has a single duty to fill the gap of this difference.`\n */\nexport class ActiveSelectionLayoutManager extends LayoutManager {\n  subscribeTargets(\n    context: RegistrationContext & Partial<StrictLayoutContext>,\n  ): void {\n    const activeSelection = context.target;\n    const parents = context.targets.reduce((parents, target) => {\n      target.parent && parents.add(target.parent);\n      return parents;\n    }, new Set<Group>());\n    parents.forEach((parent) => {\n      parent.layoutManager.subscribeTargets({\n        target: parent,\n        targets: [activeSelection],\n      });\n    });\n  }\n\n  /**\n   * unsubscribe from parent only if all its children were deselected\n   */\n  unsubscribeTargets(\n    context: RegistrationContext & Partial<StrictLayoutContext>,\n  ): void {\n    const activeSelection = context.target;\n    const selectedObjects = activeSelection.getObjects();\n    const parents = context.targets.reduce((parents, target) => {\n      target.parent && parents.add(target.parent);\n      return parents;\n    }, new Set<Group>());\n    parents.forEach((parent) => {\n      !selectedObjects.some((object) => object.parent === parent) &&\n        parent.layoutManager.unsubscribeTargets({\n          target: parent,\n          targets: [activeSelection],\n        });\n    });\n  }\n}\n"],"names":["ActiveSelectionLayoutManager","LayoutManager","subscribeTargets","context","activeSelection","target","targets","reduce","parents","parent","add","Set","forEach","layoutManager","unsubscribeTargets","selectedObjects","getObjects","some","object"],"mappings":"wDAgBO,MAAMA,UAAqCC,EAChDC,gBAAAA,CACEC,GAEA,MAAMC,EAAkBD,EAAQE,OAChBF,EAAQG,QAAQC,QAAO,CAACC,EAASH,KAC/CA,EAAOI,QAAUD,EAAQE,IAAIL,EAAOI,QAC7BD,IACN,IAAIG,KACCC,SAASH,IACfA,EAAOI,cAAcX,iBAAiB,CACpCG,OAAQI,EACRH,QAAS,CAACF,IACV,GAEN,CAKAU,kBAAAA,CACEX,GAEA,MAAMC,EAAkBD,EAAQE,OAC1BU,EAAkBX,EAAgBY,aACxBb,EAAQG,QAAQC,QAAO,CAACC,EAASH,KAC/CA,EAAOI,QAAUD,EAAQE,IAAIL,EAAOI,QAC7BD,IACN,IAAIG,KACCC,SAASH,KACdM,EAAgBE,MAAMC,GAAWA,EAAOT,SAAWA,KAClDA,EAAOI,cAAcC,mBAAmB,CACtCT,OAAQI,EACRH,QAAS,CAACF,IACV,GAER"}