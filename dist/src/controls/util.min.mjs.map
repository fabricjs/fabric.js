{"version":3,"file":"util.min.mjs","sources":["../../../src/controls/util.ts"],"sourcesContent":["import type {\n  TPointerEvent,\n  Transform,\n  TransformAction,\n  BasicTransformEvent,\n} from '../EventTypeDefs';\nimport { resolveOrigin } from '../util/misc/resolveOrigin';\nimport { Point } from '../Point';\nimport type { FabricObject } from '../shapes/Object/FabricObject';\nimport type { TOriginX, TOriginY } from '../typedefs';\nimport {\n  degreesToRadians,\n  radiansToDegrees,\n} from '../util/misc/radiansDegreesConversion';\nimport type { Control } from './Control';\nimport { CENTER } from '../constants';\n\nexport const NOT_ALLOWED_CURSOR = 'not-allowed';\n\n/**\n * @param {Boolean} alreadySelected true if target is already selected\n * @param {String} corner a string representing the corner ml, mr, tl ...\n * @param {Event} e Event object\n * @param {FabricObject} [target] inserted back to help overriding. Unused\n */\nexport const getActionFromCorner = (\n  alreadySelected: boolean,\n  corner: string | undefined,\n  e: TPointerEvent,\n  target: FabricObject,\n) => {\n  if (!corner || !alreadySelected) {\n    return 'drag';\n  }\n  const control = target.controls[corner];\n  return control.getActionName(e, control, target);\n};\n\n/**\n * Checks if transform is centered\n * @param {Object} transform transform data\n * @return {Boolean} true if transform is centered\n */\nexport function isTransformCentered(transform: Transform) {\n  return (\n    resolveOrigin(transform.originX) === resolveOrigin(CENTER) &&\n    resolveOrigin(transform.originY) === resolveOrigin(CENTER)\n  );\n}\n\nexport function invertOrigin(origin: TOriginX | TOriginY) {\n  return -resolveOrigin(origin) + 0.5;\n}\n\nexport const isLocked = (\n  target: FabricObject,\n  lockingKey:\n    | 'lockMovementX'\n    | 'lockMovementY'\n    | 'lockRotation'\n    | 'lockScalingX'\n    | 'lockScalingY'\n    | 'lockSkewingX'\n    | 'lockSkewingY'\n    | 'lockScalingFlip',\n) => target[lockingKey];\n\nexport const commonEventInfo: TransformAction<\n  Transform,\n  BasicTransformEvent\n> = (eventData, transform, x, y) => {\n  return {\n    e: eventData,\n    transform,\n    pointer: new Point(x, y),\n  };\n};\n\n/**\n * Combine control position and object angle to find the control direction compared\n * to the object center.\n * @param {FabricObject} fabricObject the fabric object for which we are rendering controls\n * @param {Control} control the control class\n * @return {Number} 0 - 7 a quadrant number\n */\nexport function findCornerQuadrant(\n  fabricObject: FabricObject,\n  control: Control,\n): number {\n  //  angle is relative to canvas plane\n  const angle = fabricObject.getTotalAngle(),\n    cornerAngle =\n      angle + radiansToDegrees(Math.atan2(control.y, control.x)) + 360;\n  return Math.round((cornerAngle % 360) / 45);\n}\n\n/**\n * @returns the normalized point (rotated relative to center) in local coordinates\n */\nfunction normalizePoint(\n  target: FabricObject,\n  point: Point,\n  originX: TOriginX,\n  originY: TOriginY,\n): Point {\n  const center = target.getRelativeCenterPoint(),\n    p =\n      typeof originX !== 'undefined' && typeof originY !== 'undefined'\n        ? target.translateToGivenOrigin(\n            center,\n            CENTER,\n            CENTER,\n            originX,\n            originY,\n          )\n        : new Point(target.left, target.top),\n    p2 = target.angle\n      ? point.rotate(-degreesToRadians(target.angle), center)\n      : point;\n  return p2.subtract(p);\n}\n\n/**\n * Transforms a point to the offset from the given origin\n * @param {Object} transform\n * @param {String} originX\n * @param {String} originY\n * @param {number} x\n * @param {number} y\n * @return {Fabric.Point} the normalized point\n */\nexport function getLocalPoint(\n  { target, corner }: Transform,\n  originX: TOriginX,\n  originY: TOriginY,\n  x: number,\n  y: number,\n) {\n  const control = target.controls[corner],\n    zoom = target.canvas?.getZoom() || 1,\n    padding = target.padding / zoom,\n    localPoint = normalizePoint(target, new Point(x, y), originX, originY);\n  if (localPoint.x >= padding) {\n    localPoint.x -= padding;\n  }\n  if (localPoint.x <= -padding) {\n    localPoint.x += padding;\n  }\n  if (localPoint.y >= padding) {\n    localPoint.y -= padding;\n  }\n  if (localPoint.y <= padding) {\n    localPoint.y += padding;\n  }\n  localPoint.x -= control.offsetX;\n  localPoint.y -= control.offsetY;\n  return localPoint;\n}\n"],"names":["NOT_ALLOWED_CURSOR","getActionFromCorner","alreadySelected","corner","e","target","control","controls","getActionName","isTransformCentered","transform","resolveOrigin","originX","CENTER","originY","invertOrigin","origin","isLocked","lockingKey","commonEventInfo","eventData","x","y","pointer","Point","findCornerQuadrant","fabricObject","cornerAngle","getTotalAngle","radiansToDegrees","Math","atan2","round","getLocalPoint","_ref","_target$canvas","zoom","canvas","getZoom","padding","localPoint","point","center","getRelativeCenterPoint","p","translateToGivenOrigin","left","top","angle","rotate","degreesToRadians","subtract","normalizePoint","offsetX","offsetY"],"mappings":"iQAiBO,MAAMA,EAAqB,cAQrBC,EAAsBA,CACjCC,EACAC,EACAC,EACAC,KAEA,IAAKF,IAAWD,EACd,MAAO,OAET,MAAMI,EAAUD,EAAOE,SAASJ,GAChC,OAAOG,EAAQE,cAAcJ,EAAGE,EAASD,EAAO,EAQ3C,SAASI,EAAoBC,GAClC,OACEC,EAAcD,EAAUE,WAAaD,EAAcE,IACnDF,EAAcD,EAAUI,WAAaH,EAAcE,EAEvD,CAEO,SAASE,EAAaC,GAC3B,MAAgC,GAAxBL,EAAcK,EACxB,CAEO,MAAMC,EAAWA,CACtBZ,EACAa,IASGb,EAAOa,GAECC,EAGTA,CAACC,EAAWV,EAAWW,EAAGC,KACrB,CACLlB,EAAGgB,EACHV,YACAa,QAAS,IAAIC,EAAMH,EAAGC,KAWnB,SAASG,EACdC,EACApB,GAGA,MACEqB,EADYD,EAAaE,gBAEfC,EAAiBC,KAAKC,MAAMzB,EAAQgB,EAAGhB,EAAQe,IAAM,IACjE,OAAOS,KAAKE,MAAOL,EAAc,IAAO,GAC1C,CAqCO,SAASM,EAAaC,EAE3BtB,EACAE,EACAO,EACAC,GACA,IAAAa,EAAA,IALA9B,OAAEA,EAAMF,OAAEA,GAAmB+B,EAM7B,MAAM5B,EAAUD,EAAOE,SAASJ,GAC9BiC,GAAoB,QAAbD,EAAA9B,EAAOgC,cAAM,IAAAF,OAAA,EAAbA,EAAeG,YAAa,EACnCC,EAAUlC,EAAOkC,QAAUH,EAC3BI,EA1CJ,SACEnC,EACAoC,EACA7B,EACAE,GAEA,MAAM4B,EAASrC,EAAOsC,yBACpBC,OACqB,IAAZhC,QAA8C,IAAZE,EACrCT,EAAOwC,uBACLH,EACA7B,EACAA,EACAD,EACAE,GAEF,IAAIU,EAAMnB,EAAOyC,KAAMzC,EAAO0C,KAItC,OAHO1C,EAAO2C,MACRP,EAAMQ,QAAQC,EAAiB7C,EAAO2C,OAAQN,GAC9CD,GACIU,SAASP,EACrB,CAqBiBQ,CAAe/C,EAAQ,IAAImB,EAAMH,EAAGC,GAAIV,EAASE,GAehE,OAdI0B,EAAWnB,GAAKkB,IAClBC,EAAWnB,GAAKkB,GAEdC,EAAWnB,IAAMkB,IACnBC,EAAWnB,GAAKkB,GAEdC,EAAWlB,GAAKiB,IAClBC,EAAWlB,GAAKiB,GAEdC,EAAWlB,GAAKiB,IAClBC,EAAWlB,GAAKiB,GAElBC,EAAWnB,GAAKf,EAAQ+C,QACxBb,EAAWlB,GAAKhB,EAAQgD,QACjBd,CACT"}